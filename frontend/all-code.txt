# Table of Contents

1. [App.tsx](#file-1-app-tsx)
2. [Modules/Auth/LoginPage.tsx](#file-2-modules-auth-loginpage-tsx)
3. [Modules/Auth/RegisterPage.tsx](#file-3-modules-auth-registerpage-tsx)
4. [Modules/BookPage/BookSidebar.tsx](#file-4-modules-bookpage-booksidebar-tsx)
5. [Modules/BookPage/Chapters.tsx](#file-5-modules-bookpage-chapters-tsx)
6. [Modules/BookPage/Konva/KonvaStage.tsx](#file-6-modules-bookpage-konva-konvastage-tsx)
7. [Modules/BookPage/Konva/components/Tools.tsx](#file-7-modules-bookpage-konva-components-tools-tsx)
8. [Modules/BookPage/Konva/functions/getElementsUnderMouse.ts](#file-8-modules-bookpage-konva-functions-getelementsundermouse-ts)
9. [Modules/BookPage/Konva/functions/getPos.ts](#file-9-modules-bookpage-konva-functions-getpos-ts)
10. [Modules/BookPage/Konva/functions/measureTextWidth.tsx](#file-10-modules-bookpage-konva-functions-measuretextwidth-tsx)
11. [Modules/BookPage/Konva/functions/processElements.ts](#file-11-modules-bookpage-konva-functions-processelements-ts)
12. [Modules/BookPage/Konva/konvaAtoms.ts](#file-12-modules-bookpage-konva-konvaatoms-ts)
13. [Modules/BookPage/Konva/modules/BookTextLayers/HighlightLayer.tsx](#file-13-modules-bookpage-konva-modules-booktextlayers-highlightlayer-tsx)
14. [Modules/BookPage/Konva/modules/BookTextLayers/HoverHighlightLayer.tsx](#file-14-modules-bookpage-konva-modules-booktextlayers-hoverhighlightlayer-tsx)
15. [Modules/BookPage/Konva/modules/BookTextLayers/HoverOptionsTab.tsx](#file-15-modules-bookpage-konva-modules-booktextlayers-hoveroptionstab-tsx)
16. [Modules/BookPage/Konva/modules/BookTextLayers/MainLayer.tsx](#file-16-modules-bookpage-konva-modules-booktextlayers-mainlayer-tsx)
17. [Modules/BookPage/Konva/modules/BookTextLayers/TextLayer.tsx](#file-17-modules-bookpage-konva-modules-booktextlayers-textlayer-tsx)
18. [Modules/BookPage/Konva/modules/NotesLayer/MainNotesLayer.tsx](#file-18-modules-bookpage-konva-modules-noteslayer-mainnoteslayer-tsx)
19. [Modules/BookPage/Konva/modules/ToolBar/ColorPicker.tsx](#file-19-modules-bookpage-konva-modules-toolbar-colorpicker-tsx)
20. [Modules/BookPage/Konva/modules/ToolBar/SliderControl.tsx](#file-20-modules-bookpage-konva-modules-toolbar-slidercontrol-tsx)
21. [Modules/BookPage/Konva/modules/ToolBar/ToolBar.config.ts](#file-21-modules-bookpage-konva-modules-toolbar-toolbar-config-ts)
22. [Modules/BookPage/Konva/modules/ToolBar/ToolBar.tsx](#file-22-modules-bookpage-konva-modules-toolbar-toolbar-tsx)
23. [Modules/BookPage/Konva/modules/ToolBar/ToolBarItem.tsx](#file-23-modules-bookpage-konva-modules-toolbar-toolbaritem-tsx)
24. [Modules/BookPage/Konva/shapes/Arrow/ArrowShape.tsx](#file-24-modules-bookpage-konva-shapes-arrow-arrowshape-tsx)
25. [Modules/BookPage/Konva/shapes/Arrow/CreateArrow.tsx](#file-25-modules-bookpage-konva-shapes-arrow-createarrow-tsx)
26. [Modules/BookPage/Konva/shapes/Arrow/CustomArrowsTransformer.tsx](#file-26-modules-bookpage-konva-shapes-arrow-customarrowstransformer-tsx)
27. [Modules/BookPage/Konva/shapes/Arrow/RenderArrow.tsx](#file-27-modules-bookpage-konva-shapes-arrow-renderarrow-tsx)
28. [Modules/BookPage/Konva/shapes/CanvaElement.tsx](#file-28-modules-bookpage-konva-shapes-canvaelement-tsx)
29. [Modules/BookPage/Konva/shapes/Circle/Circle.tsx](#file-29-modules-bookpage-konva-shapes-circle-circle-tsx)
30. [Modules/BookPage/Konva/shapes/Circle/RenderCircle.tsx](#file-30-modules-bookpage-konva-shapes-circle-rendercircle-tsx)
31. [Modules/BookPage/Konva/shapes/Circle/createCircle.tsx](#file-31-modules-bookpage-konva-shapes-circle-createcircle-tsx)
32. [Modules/BookPage/Konva/shapes/CustomTransformer.tsx](#file-32-modules-bookpage-konva-shapes-customtransformer-tsx)
33. [Modules/BookPage/Konva/shapes/Rectangle/Rectangle.tsx](#file-33-modules-bookpage-konva-shapes-rectangle-rectangle-tsx)
34. [Modules/BookPage/Konva/shapes/Rectangle/RenderRectangle.tsx](#file-34-modules-bookpage-konva-shapes-rectangle-renderrectangle-tsx)
35. [Modules/BookPage/Konva/shapes/Rectangle/createRectangle.tsx](#file-35-modules-bookpage-konva-shapes-rectangle-createrectangle-tsx)
36. [Modules/BookPage/Konva/shapes/RenderCanvaElement.tsx](#file-36-modules-bookpage-konva-shapes-rendercanvaelement-tsx)
37. [Modules/BookPage/Konva/shapes/Text/CreateText.tsx](#file-37-modules-bookpage-konva-shapes-text-createtext-tsx)
38. [Modules/BookPage/Konva/shapes/Text/RenderText.tsx](#file-38-modules-bookpage-konva-shapes-text-rendertext-tsx)
39. [Modules/BookPage/Konva/shapes/Text/TextElement.tsx](#file-39-modules-bookpage-konva-shapes-text-textelement-tsx)
40. [Modules/BookPage/MainPage.tsx](#file-40-modules-bookpage-mainpage-tsx)
41. [Modules/BookPage/Notes/Notes.tsx](#file-41-modules-bookpage-notes-notes-tsx)
42. [Modules/BookPage/Notes/components/CardView.tsx](#file-42-modules-bookpage-notes-components-cardview-tsx)
43. [Modules/BookPage/Notes/components/EmptyState.tsx](#file-43-modules-bookpage-notes-components-emptystate-tsx)
44. [Modules/BookPage/Notes/components/NoteActions.tsx](#file-44-modules-bookpage-notes-components-noteactions-tsx)
45. [Modules/BookPage/Notes/components/SearchFilter.tsx](#file-45-modules-bookpage-notes-components-searchfilter-tsx)
46. [Modules/BookPage/Notes/components/TimelineView.tsx](#file-46-modules-bookpage-notes-components-timelineview-tsx)
47. [Modules/BookPage/Notes/types.ts](#file-47-modules-bookpage-notes-types-ts)
48. [Modules/BookPage/Notes/utils.ts](#file-48-modules-bookpage-notes-utils-ts)
49. [Modules/BookPage/ProgressBar.tsx](#file-49-modules-bookpage-progressbar-tsx)
50. [Modules/BookPage/RightHand.tsx](#file-50-modules-bookpage-righthand-tsx)
51. [Modules/BookPage/functions/preprocessText.ts](#file-51-modules-bookpage-functions-preprocesstext-ts)
52. [Modules/BookmarksPage/BookmarksPage.tsx](#file-52-modules-bookmarkspage-bookmarkspage-tsx)
53. [Modules/CollectionsPage/components/CollectionCard.tsx](#file-53-modules-collectionspage-components-collectioncard-tsx)
54. [Modules/CollectionsPage/components/CollectionForm.tsx](#file-54-modules-collectionspage-components-collectionform-tsx)
55. [Modules/CollectionsPage/components/CollectionsList.tsx](#file-55-modules-collectionspage-components-collectionslist-tsx)
56. [Modules/CollectionsPage/index.ts](#file-56-modules-collectionspage-index-ts)
57. [Modules/CollectionsPage/pages/CollectionDetailPage.tsx](#file-57-modules-collectionspage-pages-collectiondetailpage-tsx)
58. [Modules/CollectionsPage/pages/CollectionsPage.tsx](#file-58-modules-collectionspage-pages-collectionspage-tsx)
59. [Modules/FavoritesPage/FavoritesPage.tsx](#file-59-modules-favoritespage-favoritespage-tsx)
60. [Modules/HistoryPage/ReadingHistoryPage.tsx](#file-60-modules-historypage-readinghistorypage-tsx)
61. [Modules/HomePage/HomePage.tsx](#file-61-modules-homepage-homepage-tsx)
62. [Modules/LibraryPage/BookCard.tsx](#file-62-modules-librarypage-bookcard-tsx)
63. [Modules/LibraryPage/BookCardSkeleton.tsx](#file-63-modules-librarypage-bookcardskeleton-tsx)
64. [Modules/LibraryPage/BookCards.tsx](#file-64-modules-librarypage-bookcards-tsx)
65. [Modules/LibraryPage/BookInfoPage.tsx](#file-65-modules-librarypage-bookinfopage-tsx)
66. [Modules/LibraryPage/LibraryPage.tsx](#file-66-modules-librarypage-librarypage-tsx)
67. [Modules/LibraryPage/Sidebar.tsx](#file-67-modules-librarypage-sidebar-tsx)
68. [Modules/LibraryPage/components/BookActionsMenu.tsx](#file-68-modules-librarypage-components-bookactionsmenu-tsx)
69. [Modules/LibraryPage/importBook.tsx](#file-69-modules-librarypage-importbook-tsx)
70. [Modules/ProfilePage/ProfilePage.tsx](#file-70-modules-profilepage-profilepage-tsx)
71. [Modules/ReadingPage/CurrentlyReadingPage.tsx](#file-71-modules-readingpage-currentlyreadingpage-tsx)
72. [Modules/Settings/Settings.tsx](#file-72-modules-settings-settings-tsx)
73. [Modules/SettingsPage/SettingsPage.tsx](#file-73-modules-settingspage-settingspage-tsx)
74. [Modules/UserDataPage/Dashboard.tsx](#file-74-modules-userdatapage-dashboard-tsx)
75. [Modules/UserDataPage/components/DashboardHeader.tsx](#file-75-modules-userdatapage-components-dashboardheader-tsx)
76. [Modules/UserDataPage/components/GenreDistributionChart.tsx](#file-76-modules-userdatapage-components-genredistributionchart-tsx)
77. [Modules/UserDataPage/components/ReadingProgressChart.tsx](#file-77-modules-userdatapage-components-readingprogresschart-tsx)
78. [Modules/UserDataPage/components/RecentActivity.tsx](#file-78-modules-userdatapage-components-recentactivity-tsx)
79. [Modules/UserDataPage/components/StatCards.tsx](#file-79-modules-userdatapage-components-statcards-tsx)
80. [ThemeProvider.tsx](#file-80-themeprovider-tsx)
81. [api/bookTrackingApi.ts](#file-81-api-booktrackingapi-ts)
82. [api/collectionsApi.ts](#file-82-api-collectionsapi-ts)
83. [api/trackingApi.ts](#file-83-api-trackingapi-ts)
84. [atoms/themeAtom.ts](#file-84-atoms-themeatom-ts)
85. [atoms.ts](#file-85-atoms-ts)
86. [components/ui/alert.tsx](#file-86-components-ui-alert-tsx)
87. [components/ui/badge.tsx](#file-87-components-ui-badge-tsx)
88. [components/ui/button.tsx](#file-88-components-ui-button-tsx)
89. [components/ui/card.tsx](#file-89-components-ui-card-tsx)
90. [components/ui/collapsible.tsx](#file-90-components-ui-collapsible-tsx)
91. [components/ui/dialog.tsx](#file-91-components-ui-dialog-tsx)
92. [components/ui/dropdown-menu.tsx](#file-92-components-ui-dropdown-menu-tsx)
93. [components/ui/input.tsx](#file-93-components-ui-input-tsx)
94. [components/ui/label.tsx](#file-94-components-ui-label-tsx)
95. [components/ui/popover.tsx](#file-95-components-ui-popover-tsx)
96. [components/ui/progress.tsx](#file-96-components-ui-progress-tsx)
97. [components/ui/scroll-area.tsx](#file-97-components-ui-scroll-area-tsx)
98. [components/ui/select.tsx](#file-98-components-ui-select-tsx)
99. [components/ui/separator.tsx](#file-99-components-ui-separator-tsx)
100. [components/ui/skeleton.tsx](#file-100-components-ui-skeleton-tsx)
101. [components/ui/slider.tsx](#file-101-components-ui-slider-tsx)
102. [components/ui/switch.tsx](#file-102-components-ui-switch-tsx)
103. [components/ui/tabs.tsx](#file-103-components-ui-tabs-tsx)
104. [components/ui/textarea.tsx](#file-104-components-ui-textarea-tsx)
105. [components/ui/toast.tsx](#file-105-components-ui-toast-tsx)
106. [components/ui/toaster.tsx](#file-106-components-ui-toaster-tsx)
107. [components/ui/tooltip.tsx](#file-107-components-ui-tooltip-tsx)
108. [endPointTypes/apiClient.ts](#file-108-endpointtypes-apiclient-ts)
109. [endPointTypes/endpointTypes.ts](#file-109-endpointtypes-endpointtypes-ts)
110. [endPointTypes/inputMap.ts](#file-110-endpointtypes-inputmap-ts)
111. [endPointTypes/typeGuards.tsx](#file-111-endpointtypes-typeguards-tsx)
112. [endPointTypes/types.ts](#file-112-endpointtypes-types-ts)
113. [hooks/use-toast.ts](#file-113-hooks-use-toast-ts)
114. [hooks/useSettings.ts](#file-114-hooks-usesettings-ts)
115. [hooks/useSidebar.ts](#file-115-hooks-usesidebar-ts)
116. [hooks/userAuth.tsx](#file-116-hooks-userauth-tsx)
117. [lib/utils.ts](#file-117-lib-utils-ts)
118. [main.tsx](#file-118-main-tsx)
119. [preprocess/epub/extractToc.ts](#file-119-preprocess-epub-extracttoc-ts)
120. [preprocess/epub/htmlToBookElements.ts](#file-120-preprocess-epub-htmltobookelements-ts)
121. [preprocess/epub/preprocessEpub.ts](#file-121-preprocess-epub-preprocessepub-ts)


---

<h2 id="file-1-app-tsx">File 1: App.tsx</h2>

```typescript
// src/App.jsx
import { BrowserRouter as Router, Routes, Route } from "react-router-dom";
import MainPage from "./Modules/BookPage/MainPage";
import LibraryPage from "./Modules/LibraryPage/LibraryPage";
import RegisterPage from "./Modules/Auth/RegisterPage";
import LoginPage from "./Modules/Auth/LoginPage";
import Dashboard from "./Modules/UserDataPage/Dashboard";
import CurrentlyReadingPage from "./Modules/ReadingPage/CurrentlyReadingPage";
import FavoritesPage from "./Modules/FavoritesPage/FavoritesPage";
import BookmarksPage from "./Modules/BookmarksPage/BookmarksPage";
import ReadingHistoryPage from "./Modules/HistoryPage/ReadingHistoryPage";
import { Toaster } from "./components/ui/toaster";
import { ThemeProvider } from "./ThemeProvider";
import { CollectionsPage, CollectionDetailPage } from './Modules/CollectionsPage';
import SettingsPage from "./Modules/SettingsPage/SettingsPage";
import ProfilePage from "./Modules/ProfilePage/ProfilePage";
import HomePage from "./Modules/HomePage/HomePage";

function App() {
    return (
        <ThemeProvider defaultTheme="dark" storageKey="vite-ui-theme">
            <Router>
                <Routes>
                    <Route path="/register" element={<RegisterPage />} />
                    <Route path="/login" element={<LoginPage />} />
                    <Route path="/book" element={<MainPage />} />
                    <Route path="/library" element={<LibraryPage />} />
                    <Route path="/statistics" element={<Dashboard />} />
                    <Route path="/reading" element={<CurrentlyReadingPage />} />
                    <Route path="/favorites" element={<FavoritesPage />} />
                    <Route path="/bookmarks" element={<BookmarksPage />} />
                    <Route path="/history" element={<ReadingHistoryPage />} />
                    <Route path="/collections" element={<CollectionsPage />} />
                    <Route path="/collections/:id" element={<CollectionDetailPage />} />
                    <Route path="/settings" element={<SettingsPage />} />
                    <Route path="/profile" element={<ProfilePage />} />
                    <Route path="/" element={<HomePage />} />
                </Routes>
                <Toaster />
            </Router>
        </ThemeProvider>
    );
}

export default App;

```

<div style='page-break-after: always;'></div>

<h2 id="file-2-modules-auth-loginpage-tsx">File 2: Modules/Auth/LoginPage.tsx</h2>

```typescript
// src/pages/Login.tsx
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import axios from "axios";
import { useAtom } from "jotai";
import { accessTokenAtom, userAtom } from "../../atoms";
import { useToast } from "../../hooks/use-toast";
import { Button } from "../../components/ui/button";
import { Input } from "../../components/ui/input";
import { Label } from "../../components/ui/label";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../../components/ui/card";
import { useAtom as useJotaiAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import { BookOpen } from "lucide-react";

export default function LoginPage() {
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const [loading, setLoading] = useState(false);
    const [_, setAccessToken] = useAtom(accessTokenAtom);
    const [__, setUser] = useAtom(userAtom);
    const navigate = useNavigate();
    const { toast } = useToast();
    const [themeMode] = useJotaiAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setLoading(true);

        try {
            const response = await axios.post("/api/auth/login", {
                username,
                password,
            });

            const { access_token, user: userData } = response.data;
            
            // Save token to localStorage and state
            localStorage.setItem("token", access_token);
            setAccessToken(access_token);
            
            // Save user data to state
            setUser(userData);
            
            toast({
                title: "Login successful",
                description: `Welcome back, ${username}!`,
                duration: 3000,
            });
            
            navigate("/");
        } catch (error) {
            console.error("Login error:", error);
            toast({
                title: "Login failed",
                description: "Invalid username or password",
                variant: "destructive",
                duration: 5000,
            });
        } finally {
            setLoading(false);
        }
    };

    return (
        <div className={cn(
            "min-h-screen flex items-center justify-center p-4",
            isDarkMode ? "bg-gray-950" : "bg-amber-50"
        )}>
            <Card className={cn(
                "w-full max-w-md",
                isDarkMode ? "bg-gray-900 border-gray-800 text-gray-100" : "bg-white"
            )}>
                <CardHeader className="space-y-1">
                    <div className="flex items-center justify-center mb-2">
                        <BookOpen className={cn(
                            "h-12 w-12",
                            isDarkMode ? "text-amber-500" : "text-amber-600"
                        )} />
                    </div>
                    <CardTitle className="text-2xl font-bold text-center">
                        Login to Your Account
                    </CardTitle>
                    <CardDescription className={cn(
                        "text-center",
                        isDarkMode ? "text-gray-400" : "text-gray-500"
                    )}>
                        Enter your credentials to access your library
                    </CardDescription>
                </CardHeader>
                <form onSubmit={handleLogin}>
                    <CardContent className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="username" className={isDarkMode ? "text-gray-300" : ""}>
                                Username
                            </Label>
                            <Input
                                id="username"
                                placeholder="Enter your username"
                                value={username}
                                onChange={(e) => setUsername(e.target.value)}
                                required
                                className={isDarkMode ? "bg-gray-800 border-gray-700 text-white" : ""}
                            />
                        </div>
                        <div className="space-y-2">
                            <Label htmlFor="password" className={isDarkMode ? "text-gray-300" : ""}>
                                Password
                            </Label>
                            <Input
                                id="password"
                                type="password"
                                placeholder="Enter your password"
                                value={password}
                                onChange={(e) => setPassword(e.target.value)}
                                required
                                className={isDarkMode ? "bg-gray-800 border-gray-700 text-white" : ""}
                            />
                        </div>
                    </CardContent>
                    <CardFooter className="flex flex-col space-y-4">
                        <Button 
                            type="submit" 
                            className="w-full" 
                            disabled={loading}
                        >
                            {loading ? "Logging in..." : "Login"}
                        </Button>
                        <div className="text-center text-sm">
                            <span className={isDarkMode ? "text-gray-400" : "text-gray-500"}>
                                Don't have an account?{" "}
                            </span>
                            <Button 
                                variant="link" 
                                className={cn(
                                    "p-0",
                                    isDarkMode ? "text-amber-500" : "text-amber-600"
                                )}
                                onClick={() => navigate("/register")}
                            >
                                Register
                            </Button>
                        </div>
                    </CardFooter>
                </form>
            </Card>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-3-modules-auth-registerpage-tsx">File 3: Modules/Auth/RegisterPage.tsx</h2>

```typescript
// src/pages/Register.tsx
import React, { useState } from "react";
import axios from "axios";
import { useMutation } from "@tanstack/react-query";
import { useNavigate, Link } from "react-router-dom";
import { useAtom } from "jotai";
import { accessTokenAtom, userAtom } from "../../atoms";

const Register: React.FC = () => {
    const [user, setUser] = useAtom(userAtom);
    const [username, setUsername] = useState("");
    const [password, setPassword] = useState("");
    const [confirmPassword, setConfirmPassword] = useState("");
    const navigate = useNavigate();
    const [errorMessage, setErrorMessage] = useState("");

    // Define the mutation function
    const registerUser = async () => {
        if (password !== confirmPassword) {
            throw new Error("Passwords do not match.");
        }
        const response = await axios.post("/api/auth/register", {
            username,
            password,
        });
        return response.data;
    };

    // Use the useMutation hook with the mutation function
    const mutation = useMutation({
        mutationFn: registerUser,
        onSuccess: (data) => {
            console.log("Registered successfully:", data);
            setUser(data);
            navigate("/");
        },
        onError: (error: any) => {
            setErrorMessage(error.response?.data?.message || error.message);
        },
    });

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        mutation.mutate();
    };

    return (
        <div className="min-h-screen flex items-center justify-center bg-amber-50">
            <div className="max-w-md w-full bg-white rounded-lg shadow-lg p-8 border-t-8 border-amber-600 transform transition-all duration-300 hover:shadow-xl">
                <div className="text-center mb-8">
                    <h2 className="text-3xl font-serif font-bold text-amber-800">Join Our Library</h2>
                    <p className="text-gray-600 mt-2">Create an account to start your reading journey</p>
                </div>
                
                {errorMessage && (
                    <div className="mb-6 text-red-500 text-center bg-red-50 p-3 rounded-md border border-red-200">
                        {errorMessage}
                    </div>
                )}
                
                <form onSubmit={handleSubmit} className="space-y-6">
                    <div>
                        <label
                            htmlFor="username"
                            className="block text-sm font-medium text-gray-700 mb-1"
                        >
                            Username
                        </label>
                        <input
                            type="text"
                            id="username"
                            className="w-full px-4 py-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent transition-all duration-200"
                            value={username}
                            onChange={(e) => setUsername(e.target.value)}
                            required
                        />
                    </div>
                    <div>
                        <label
                            htmlFor="password"
                            className="block text-sm font-medium text-gray-700 mb-1"
                        >
                            Password
                        </label>
                        <input
                            type="password"
                            id="password"
                            className="w-full px-4 py-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent transition-all duration-200"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required
                        />
                    </div>
                    <div>
                        <label
                            htmlFor="confirmPassword"
                            className="block text-sm font-medium text-gray-700 mb-1"
                        >
                            Confirm Password
                        </label>
                        <input
                            type="password"
                            id="confirmPassword"
                            className="w-full px-4 py-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent transition-all duration-200"
                            value={confirmPassword}
                            onChange={(e) => setConfirmPassword(e.target.value)}
                            required
                        />
                    </div>
                    <button
                        type="submit"
                        className="w-full flex justify-center py-3 px-4 border border-transparent rounded-md shadow-sm text-white bg-amber-600 hover:bg-amber-700 font-medium transition-colors duration-200"
                    >
                        Register
                    </button>
                </form>
                
                <div className="mt-8 text-center">
                    <div className="relative">
                        <div className="absolute inset-0 flex items-center">
                            <div className="w-full border-t border-gray-300"></div>
                        </div>
                        <div className="relative flex justify-center text-sm">
                            <span className="px-2 bg-white text-gray-500">Already have an account?</span>
                        </div>
                    </div>
                    <Link
                        to="/login"
                        className="mt-4 inline-block text-amber-600 hover:text-amber-800 font-medium transition-colors duration-200"
                    >
                        Sign in
                    </Link>
                </div>
            </div>
        </div>
    );
};

export default Register;

```

<div style='page-break-after: always;'></div>

<h2 id="file-4-modules-bookpage-booksidebar-tsx">File 4: Modules/BookPage/BookSidebar.tsx</h2>

```typescript
import {
    ChevronLeft,
    ChevronRight,
    Home,
    Library,
    BookMarked,
    Star,
    History,
    LayoutDashboard,
    Settings,
    User
} from "lucide-react";
import React, { useState, useEffect } from "react";
import { Button } from "../../components/ui/button";
import { ScrollArea } from "../../components/ui/scroll-area";
import { NavigateFunction, useNavigate, useLocation } from "react-router-dom";
import { cn } from "../../lib/utils";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { Separator } from "../../components/ui/separator";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "../../components/ui/tooltip";

type BookSidebarProps = {
    isCollapsed: boolean;
    toggleCollapse: () => void;
};

type SidebarButtonProps = {
    icon: React.ElementType;
    label: string;
    isCollapsed: boolean;
    navigate: NavigateFunction;
    route: string;
    isActive?: boolean;
    textVisible?: boolean;
};

const SidebarButton = ({
    icon: Icon,
    label,
    isCollapsed,
    navigate,
    route,
    isActive = false,
    textVisible = true
}: SidebarButtonProps) => {
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    
    return (
        <TooltipProvider>
            <Tooltip delayDuration={300}>
                <TooltipTrigger asChild>
                    <Button
                        variant="ghost"
                        size="sm"
                        className={cn(
                            "w-full justify-start",
                            isActive && (isDarkMode 
                                ? "bg-gray-800 text-white" 
                                : "bg-amber-100 text-gray-900"),
                            !isActive && (isDarkMode 
                                ? "text-gray-300 hover:text-white hover:bg-gray-800" 
                                : "text-gray-700 hover:text-gray-900 hover:bg-amber-50")
                        )}
                        onClick={() => navigate(route)}
                    >
                        <Icon size={20} className={isActive ? "text-amber-600" : ""} />
                        {!isCollapsed && textVisible && (
                            <span className="ml-2 transition-opacity duration-150 opacity-100">
                                {label}
                            </span>
                        )}
                    </Button>
                </TooltipTrigger>
                {isCollapsed && <TooltipContent side="right">{label}</TooltipContent>}
            </Tooltip>
        </TooltipProvider>
    );
};

export default function BookSidebar({
    isCollapsed,
    toggleCollapse
}: BookSidebarProps) {
    const navigate = useNavigate();
    const location = useLocation();
    const [textVisible, setTextVisible] = useState(!isCollapsed);
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    // Handle text visibility based on sidebar state
    useEffect(() => {
        if (isCollapsed) {
            setTextVisible(false);
        } else {
            // Small delay to ensure text appears after sidebar expands
            const timer = setTimeout(() => {
                setTextVisible(true);
            }, 150); // Half of the sidebar transition duration
            return () => clearTimeout(timer);
        }
    }, [isCollapsed]);

    // Check if a route is active
    const isRouteActive = (route: string) => {
        if (route === '/') {
            return location.pathname === '/';
        }
        return location.pathname.startsWith(route);
    };

    return (
        <aside
            className={cn(
                "h-screen flex flex-col transition-all duration-300 border-r",
                isDarkMode 
                    ? "bg-gray-900 border-gray-800" 
                    : "bg-white border-gray-200",
                isCollapsed ? "w-16" : "w-64"
            )}
        >
            <div className="p-2">
                <Button
                    variant="ghost"
                    onClick={toggleCollapse}
                    className={cn(
                        "w-full justify-start p-2",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white hover:bg-gray-800" 
                            : "text-gray-600 hover:text-gray-900 hover:bg-amber-50"
                    )}
                >
                    {isCollapsed ? (
                        <ChevronLeft size={20} />
                    ) : (
                        <ChevronRight size={20} />
                    )}
                    {!isCollapsed && textVisible && (
                        <span className="ml-2 transition-opacity duration-150 opacity-100">
                            Collapse
                        </span>
                    )}
                </Button>
            </div>

            <ScrollArea className="flex-grow">
                <div className="space-y-1 p-2">
                    <SidebarButton
                        icon={Home}
                        label="Home"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/"
                        isActive={isRouteActive('/')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={Library}
                        label="Library"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/library"
                        isActive={isRouteActive('/library')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={BookMarked}
                        label="Currently Reading"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/reading"
                        isActive={isRouteActive('/reading')}
                        textVisible={textVisible}
                    />
                    
                    <Separator className={cn(
                        "my-2",
                        isDarkMode ? "bg-gray-800" : "bg-gray-200"
                    )} />
                    
                    <SidebarButton
                        icon={Star}
                        label="Favorites"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/favorites"
                        isActive={isRouteActive('/favorites')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={History}
                        label="Reading History"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/history"
                        isActive={isRouteActive('/history')}
                        textVisible={textVisible}
                    />
                    
                    <Separator className={cn(
                        "my-2",
                        isDarkMode ? "bg-gray-800" : "bg-gray-200"
                    )} />
                    
                    <SidebarButton
                        icon={LayoutDashboard}
                        label="Statistics"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/statistics"
                        isActive={isRouteActive('/statistics')}
                        textVisible={textVisible}
                    />
                </div>
            </ScrollArea>

            <div className={cn(
                "p-2 border-t",
                isDarkMode ? "border-gray-800" : "border-gray-200"
            )}>
                <SidebarButton
                    icon={Settings}
                    label="Settings"
                    isCollapsed={isCollapsed}
                    navigate={navigate}
                    route="/settings"
                    isActive={isRouteActive('/settings')}
                    textVisible={textVisible}
                />
                <SidebarButton
                    icon={User}
                    label="Profile"
                    isCollapsed={isCollapsed}
                    navigate={navigate}
                    route="/profile"
                    isActive={isRouteActive('/profile')}
                    textVisible={textVisible}
                />
            </div>
        </aside>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-5-modules-bookpage-chapters-tsx">File 5: Modules/BookPage/Chapters.tsx</h2>

```typescript
import { Button } from "../../components/ui/button";
import { ChaptersData } from "../../endPointTypes/types";
import { ChevronLeft, ChevronRight, ChevronDown, BookOpen, Menu } from "lucide-react";
import { useState, useEffect } from "react";
import { cn } from "../../lib/utils";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { ScrollArea } from "../../components/ui/scroll-area";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "../../components/ui/tooltip";

type ChaptersProps = {
    chapters: ChaptersData[] | undefined;
    handleChapterClick: (chapterId: string) => void;
    currentChapterId?: string;
};

export default function Chapters({
    chapters,
    handleChapterClick,
    currentChapterId,
}: ChaptersProps) {
    console.log("chapters", chapters);
    // Track expanded chapters
    const [expandedChapters, setExpandedChapters] = useState<Record<string, boolean>>({});
    // Track if sidebar is expanded
    const [sidebarExpanded, setSidebarExpanded] = useState(true);
    // Get current theme
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    
    // Group chapters by parent-child relationship
    const chapterTree = buildChapterTree(chapters || []);
    
    // Initialize with current chapter's path expanded
    useEffect(() => {
        if (currentChapterId && chapters) {
            const newExpandedState = {...expandedChapters};
            
            // Find the current chapter's ancestors and expand them
            const expandParents = (chapters: ChaptersData[], targetId: string) => {
                for (const chapter of chapters) {
                    if (chapter.id === targetId) {
                        return true;
                    }
                    
                    // If this chapter has children and the target is among them
                    if (chapter.indentLevel !== undefined && chapter.indentLevel < getChapterIndentLevel(targetId, chapters)) {
                        const possibleParent = chapters.some(ch => 
                            ch.id === targetId && 
                            ch.indentLevel !== undefined && 
                            chapter.indentLevel !== undefined &&
                            ch.indentLevel > chapter.indentLevel
                        );
                        
                        if (possibleParent) {
                            newExpandedState[chapter.id] = true;
                        }
                    }
                }
                return false;
            };
            
            expandParents(chapters, currentChapterId);
            setExpandedChapters(newExpandedState);
        }
    }, [currentChapterId, chapters]);
    
    // Toggle chapter expansion
    const toggleChapter = (chapterId: string, event: React.MouseEvent) => {
        event.stopPropagation();
        setExpandedChapters(prev => ({
            ...prev,
            [chapterId]: !prev[chapterId]
        }));
    };
    
    // Toggle sidebar expansion
    const toggleSidebar = () => {
        setSidebarExpanded(!sidebarExpanded);
    };
    
    // Check if a chapter has children
    const hasChildren = (chapter: ChaptersData, allChapters: ChaptersData[]) => {
        if (chapter.indentLevel === undefined) return false;
        
        const chapterIndex = allChapters.findIndex(ch => ch.id === chapter.id);
        if (chapterIndex === -1 || chapterIndex === allChapters.length - 1) return false;
        
        const nextChapter = allChapters[chapterIndex + 1];
        return nextChapter.indentLevel !== undefined && 
               nextChapter.indentLevel > chapter.indentLevel;
    };
    
    // Get chapter indent level by ID
    const getChapterIndentLevel = (chapterId: string, allChapters: ChaptersData[]) => {
        const chapter = allChapters.find(ch => ch.id === chapterId);
        return chapter?.indentLevel ?? 0;
    };
    
    // Build a hierarchical structure of chapters
    function buildChapterTree(chapters: ChaptersData[]) {
        return chapters.filter(chapter => {
            return !chapter.indentLevel || chapter.indentLevel === 0 || 
                  (expandedChapters[getParentChapterId(chapter, chapters) || ''] !== false);
        });
    }
    
    // Find parent chapter ID
    function getParentChapterId(chapter: ChaptersData, allChapters: ChaptersData[]): string | null {
        if (!chapter.indentLevel || chapter.indentLevel === 0) return null;
        
        const chapterIndex = allChapters.findIndex(ch => ch.id === chapter.id);
        if (chapterIndex === -1) return null;
        
        // Look backward to find the parent (with lower indent level)
        for (let i = chapterIndex - 1; i >= 0; i--) {
            if (allChapters[i]?.indentLevel !== undefined && 
                chapter.indentLevel !== undefined &&
                allChapters[i]?.indentLevel < chapter.indentLevel) {
                return allChapters[i]?.id;
            }
        }
        
        return null;
    }
    
    // Determine if a chapter should be visible based on parent expansion state
    const isChapterVisible = (chapter: ChaptersData) => {
        if (!chapter.indentLevel || chapter.indentLevel === 0) return true;
        
        const parentId = getParentChapterId(chapter, chapters || []);
        if (!parentId) return true;
        
        return !!expandedChapters[parentId];
    };

    return (
        <aside
            className={cn(
                "h-screen border-r pr-2  flex flex-col transition-all duration-300 border-l",
                isDarkMode 
                    ? "bg-gray-900 border-gray-800" 
                    : "bg-white border-gray-200",
                sidebarExpanded ? "w-64" : "w-16"
            )}
        >
            <div className="p-2">
                <Button
                    variant="ghost"
                    onClick={toggleSidebar}
                    className={cn(
                        "w-full justify-start p-2",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white hover:bg-gray-800" 
                            : "text-gray-600 hover:text-gray-900 hover:bg-amber-50"
                    )}
                >
                    {sidebarExpanded ? (
                        <ChevronRight size={20} />
                    ) : (
                        <ChevronLeft size={20} />
                    )}
                    {sidebarExpanded && (
                        <span className="ml-2 transition-opacity duration-150 opacity-100">
                            Contents
                        </span>
                    )}
                </Button>
            </div>

            <ScrollArea className="flex-grow">
                <div className="space-y-1 p-2">
                    {sidebarExpanded && (
                        chapters?.map((chapter, index) => {
                            const isVisible = isChapterVisible(chapter);
                            const hasChildChapters = hasChildren(chapter, chapters);
                            const isExpanded = expandedChapters[chapter.id];
                            const isActive = currentChapterId === chapter.id;
                            const indentLevel = chapter.indentLevel ?? 0;
                                
                            if (!isVisible && indentLevel > 0) {
                                return null;
                            }

                            return (
                                <div key={index} className="relative">
                                    <div className="flex items-center">
                                        <div 
                                            style={{
                                                paddingLeft: `${indentLevel * 12}px`
                                            }}
                                            className="flex-grow flex items-center"
                                        >
                                            {hasChildChapters && (
                                                <button
                                                    onClick={(e) => toggleChapter(chapter.id, e)}
                                                    className={cn(
                                                        "mr-1.5 h-5 w-5 flex items-center justify-center flex-shrink-0 rounded",
                                                        isDarkMode 
                                                            ? "text-gray-400 hover:text-white hover:bg-gray-700" 
                                                            : "text-gray-500 hover:text-gray-900 hover:bg-gray-100"
                                                    )}
                                                >
                                                    <ChevronDown
                                                        size={16}
                                                        className={cn(
                                                            "transition-transform duration-200",
                                                            !isExpanded && "-rotate-90"
                                                        )}
                                                    />
                                                </button>
                                            )}
                                            
                                            <Button
                                                variant="ghost"
                                                size="sm"
                                                className={cn(
                                                    "justify-start flex-grow w-full text-left",
                                                    !hasChildChapters && "pl-6",
                                                    isActive && (isDarkMode 
                                                        ? "bg-gray-800 text-white" 
                                                        : "bg-amber-100 text-gray-900"),
                                                    !isActive && (isDarkMode 
                                                        ? "text-gray-300 hover:text-white hover:bg-gray-800" 
                                                        : "text-gray-700 hover:text-gray-900 hover:bg-amber-50")
                                                )}
                                                onClick={() => handleChapterClick(chapter.id)}
                                            >
                                                <span className="truncate">{chapter.title}</span>
                                            </Button>
                                        </div>
                                    </div>
                                </div>
                            );
                        })
                    )}
                </div>
            </ScrollArea>

            {!sidebarExpanded && (
                <TooltipProvider>
                    <div className="flex flex-col items-center py-4">
                        <Tooltip>
                            <TooltipTrigger asChild>
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className={cn(
                                        "h-8 w-8 mb-2",
                                        isDarkMode 
                                            ? "text-gray-400 hover:text-white hover:bg-gray-800" 
                                            : "text-gray-600 hover:text-gray-900 hover:bg-amber-50"
                                    )}
                                    onClick={() => setSidebarExpanded(true)}
                                >
                                    <BookOpen size={18} />
                                </Button>
                            </TooltipTrigger>
                            <TooltipContent side="right">Show Contents</TooltipContent>
                        </Tooltip>
                    </div>
                </TooltipProvider>
            )}
        </aside>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-6-modules-bookpage-konva-konvastage-tsx">File 6: Modules/BookPage/Konva/KonvaStage.tsx</h2>

```typescript
import { useAtom } from "jotai";
import Konva from "konva";
import { KonvaEventObject } from "konva/lib/Node";
import {
  useEffect,
  useRef,
  useState,
  useImperativeHandle,
  forwardRef,
} from "react";
import { Stage } from "react-konva";
import { ChaptersData } from "../../../endPointTypes/types";
import { useSettings } from "../../../hooks/useSettings";
import { ProcessedElement } from "../../../preprocess/epub/htmlToBookElements";
import Chapters from "../Chapters";
import Tools from "./components/Tools";
import { isPointInPolygon } from "./functions/getElementsUnderMouse";
import { getPos } from "./functions/getPos";
import {
  activeToolAtom,
  canvaElementsAtom,
  currentHighlightAtom,
  hoveredItemsAtom,
  newArrowAtom,
  offsetPositionAtom,
  scaleAtom,
  selectedItemsIdsAtom,
  navigationSourceAtom,
  lockPageUpdatesAtom,
  displayPageAtom,
} from "./konvaAtoms";
import HoverHighlightLayer from "./modules/BookTextLayers/HoverHighlightLayer";
import HoverOptionsTab from "./modules/BookTextLayers/HoverOptionsTab";
import MainLayer, { MainLayerRef } from "./modules/BookTextLayers/MainLayer";
import MainNotesLayer, {
  MainNotesLayerRef,
} from "./modules/NotesLayer/MainNotesLayer";
import ToolBar from "./modules/ToolBar/ToolBar";
import { throttle } from "lodash";

export type VisibleArea = {
  x: number;
  y: number;
  width: number;
  height: number;
};
// ... other type definitions

type KonvaStageProps = {
  bookElements: ProcessedElement[];
  chaptersData: ChaptersData[] | undefined;
  onPageChange?: (page: number, position: number) => void;
  onNavigate?: (page: number) => void;
  totalPages: number;
};

const KonvaStage = forwardRef<
  { navigateToPage: (page: number) => void },
  KonvaStageProps
>(
  (
    { bookElements, chaptersData, onPageChange, onNavigate, totalPages },
    ref
  ) => {
    const { settings } = useSettings();
    const width = 1200;
    const [activeTool] = useAtom(activeToolAtom);
    const stageRef = useRef<any>(null);
    const [scale, setScale] = useAtom(scaleAtom); // State to handle scale
    const [isDragging, setIsDragging] = useState(false); // New state to track dragging
    const [offsetPosition, setOffsetPosition] = useAtom(offsetPositionAtom);
    const viewportBuffer = 200;
    const mainNotesLayerRef = useRef<MainNotesLayerRef | null>(null);
    const [, setHoveredItems] = useAtom(hoveredItemsAtom);
    const [newArrow] = useAtom(newArrowAtom);
    const [canvaElements] = useAtom(canvaElementsAtom);
    const [selectedItemsIds] = useAtom(selectedItemsIdsAtom);
    const [currentHighlight] = useAtom(currentHighlightAtom);
    const mainLayerRef = useRef<MainLayerRef | null>(null);
    const dragPosRef = useRef({ x: 0, y: 0 });
    const [navigationSource, setNavigationSource] =
      useAtom(navigationSourceAtom);
    const [lockPageUpdates, setLockPageUpdates] = useAtom(lockPageUpdatesAtom);
    const [displayPage, setDisplayPage] = useAtom(displayPageAtom);
    useEffect(() => {}, [canvaElements]);

    const [visibleArea, setVisibleArea] = useState<VisibleArea>({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
    });

    useEffect(() => {
      // Add event listener to the document to catch keydown events
      document.addEventListener("keydown", handleKeyDown);

      // Cleanup event listener on component unmount
      return () => {
        document.removeEventListener("keydown", handleKeyDown);
      };
    }, []);
    useEffect(() => {
      const stage = stageRef.current;
      if (stage) {
        stage.on("wheel", handleWheel); // Attach wheel handler
      }

      return () => {
        if (stage) {
          stage.off("wheel", handleWheel); // Clean up listener
        }
      };
    }, []);

    const handleKeyDown = (e: KeyboardEvent) => {
      if (mainNotesLayerRef.current) {
        mainNotesLayerRef.current.handleKeyDown(e);
      }
    };

    const handlePanWheel = (e: Konva.KonvaEventObject<WheelEvent>) => {
      // Set the navigation source to scroll
      setNavigationSource("scroll");

      const stage = stageRef.current;
      if (!stage) return;

      // Prevent default scrolling behavior
      e.evt.preventDefault();

      // Get the pointer position (optional, depends on how you want to calculate movement)
      const pointer = stage.getPointerPosition();
      if (!pointer) return;

      // Calculate vertical movement based on the wheel delta
      const dy = e.evt.deltaY;

      // Update the offset position to pan vertically
      setOffsetPosition((prev) => ({
        x: prev.x, // No horizontal movement
        y: prev.y - dy, // Move vertically based on the wheel delta
      }));

      stage.batchDraw();
    };

    const handleControlWheel = (e: Konva.KonvaEventObject<WheelEvent>) => {
      e.evt.preventDefault();
      const stage = stageRef.current;

      if (!stage) return;

      const oldScale = stage.scaleX();
      const pointer = stage.getPointerPosition();

      if (!pointer) return;

      const scaleBy = 1.1;
      const direction = e.evt.deltaY > 0 ? -1 : 1;
      const newScale = direction > 0 ? oldScale * scaleBy : oldScale / scaleBy;

      // Limit the scale range
      const minScale = 0.5;
      const maxScale = 3;
      const clampedScale = Math.max(minScale, Math.min(maxScale, newScale));

      // Calculate the scaling factor
      const scaleFactor = clampedScale / oldScale;

      // Adjust the offset position to keep the zoom centered on the pointer
      const newPos = {
        x: pointer.x - (pointer.x - stage.x()) * scaleFactor,
        y: pointer.y - (pointer.y - stage.y()) * scaleFactor,
      };

      // Update state
      setScale(clampedScale);
      setOffsetPosition(newPos);
    };

    const handleWheel = (e: Konva.KonvaEventObject<WheelEvent>) => {
      if (e.evt.ctrlKey) {
        handleControlWheel(e);
      } else {
        handlePanWheel(e);
      }
    };

    const handleMouseDownForPan = () => {
      const stage = stageRef.current;
      setIsDragging(true);
      const pos = stage.getPointerPosition();
      if (pos) {
        dragPosRef.current = pos;
      }
    };

    const offsetPositionRef = useRef({ x: 0, y: 0 });
    useEffect(() => {
      offsetPositionRef.current = offsetPosition;
    }, [offsetPosition]);
    const handleMouseMoveForPan = () => {
      // Set navigation source to scroll
      setNavigationSource("scroll");

      const stage = stageRef.current;
      if (!stage || !isDragging) return;

      const pointer = stage.getPointerPosition();
      if (!pointer || !dragPosRef.current) return;

      // Calculate deltas by comparing pointer position with the stage's current position
      const dx = (pointer.x - dragPosRef.current.x) / scale;
      const dy = (pointer.y - dragPosRef.current.y) / scale;
      dragPosRef.current = {
        x: dragPosRef.current.x + dx * scale,
        y: dragPosRef.current.y + dy * scale,
      };
      // Update offset position based on deltas
      setOffsetPosition((prev) => ({
        x: prev.x + dx * scale,
        y: prev.y + dy * scale,
      }));

      stage.batchDraw();
    };

    useEffect(() => {
      const stage = stageRef.current;
      if (!stage) return;
      stage.position({
        x: offsetPosition.x,
        y: offsetPosition.y,
      });
      updateVisibleArea();
    }, [offsetPosition]);

    useEffect(() => {
      const stage = stageRef.current;
      if (!stage) return;
      stage.scale({ x: scale, y: scale });
      stage.position(offsetPosition);
      stage.batchDraw();
    }, [scale, offsetPosition]);

    const handleMouseUpForPan = () => {
      setIsDragging(false);
    };

    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
      if ((e.evt.target as HTMLElement).closest(".progress-bar-container")) {
        return;
      }

      if (activeTool === "Pan" || e.evt.buttons === 4) {
        handleMouseDownForPan();
        e.evt.preventDefault();
        return;
      }

      if (mainLayerRef.current) {
        mainLayerRef.current.handleMouseDown(e);
      }
      if (mainNotesLayerRef.current) {
        mainNotesLayerRef.current.handleMouseDown(e);
      }
    };

    const removeHoversNotUnderMouse = (e: KonvaEventObject<MouseEvent>) => {
      const pos = getPos(offsetPosition, scale, e);
      if (!pos) return;
      console.log("Removing hovers not under mouse", pos);
      setHoveredItems((prevItems) => {
        const filteredItems = prevItems.filter((item) => {
          const isInPolygon = isPointInPolygon(pos, item.points);

          const isArrowRelated =
            newArrow &&
            (item.id === newArrow.arrowElement.startId ||
              item.id === newArrow.arrowElement.endId);
          return (
            ((activeTool === "Arrow" || activeTool === "Select") &&
              (isInPolygon || isArrowRelated)) ||
            (item.id === currentHighlight.id &&
              (currentHighlight.editing || currentHighlight.creating))
          );
        });
        console.log("Filtered items", filteredItems);
        return filteredItems;
      });
    };

    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
      removeHoversNotUnderMouse(e);
      if (activeTool === "Pan" || e.evt.buttons === 4) {
        handleMouseMoveForPan();
        e.evt.preventDefault();
        return;
      }
      if (mainLayerRef.current) {
        mainLayerRef.current.handleMouseMove(e);
      }
      if (mainNotesLayerRef.current) {
        mainNotesLayerRef.current.handleMouseMove(e);
      }
    };

    const handleMouseUp = (e: KonvaEventObject<MouseEvent>) => {
      if (activeTool === "Pan" || e.evt.buttons === 4) {
        handleMouseUpForPan();
        e.evt.preventDefault();
        return;
      }
      if (mainLayerRef.current) {
        mainLayerRef.current.handleMouseUp();
      }
      if (mainNotesLayerRef.current) {
        mainNotesLayerRef.current.handleMouseUp(e);
      }
    };

    const handleDoubleClick = (e: KonvaEventObject<MouseEvent>) => {
      if (mainNotesLayerRef.current) {
        mainNotesLayerRef.current.handleDoubleClick(e);
      }
    };

    const updateVisibleArea = () => {
      if (!stageRef.current) return;

      const stage = stageRef.current;

      const visibleArea = {
        x: (-stage.x() - viewportBuffer) / scale,
        y: (-stage.y() - viewportBuffer) / scale,
        width: (window.innerWidth + viewportBuffer * 2) / scale,
        height: (window.innerHeight + viewportBuffer * 2) / scale,
      };
      setVisibleArea(visibleArea);
    };

    const easeInOutCubic = (t: number) => {
      return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
    };

    const smoothScroll = (
      targetX: number,
      targetY: number,
      duration: number
    ) => {
      const start = performance.now();
      const initialOffset = { ...offsetPositionRef.current };
      const deltaX = targetX - initialOffset.x;
      const deltaY = targetY - initialOffset.y;

      const animateScroll = (currentTime: number) => {
        const elapsed = currentTime - start;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = easeInOutCubic(progress);

        setOffsetPosition({
          x: initialOffset.x + deltaX * easeProgress,
          y: initialOffset.y + deltaY * easeProgress,
        });

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        }
      };

      requestAnimationFrame(animateScroll);
    };
    const handleChapterClick = (chapterId: string) => {
      console.log("handleChapterClick", chapterId);
      // Find the chapter and chapters data
      const chapter = chaptersData?.find((c) => c.id === chapterId);
      if (!chapter || !chaptersData) return;

      const chapterIndex = chaptersData.findIndex((c) => c.id === chapter.id);
      const targetY = -chapterIndex * 200 * (settings?.fontSize || 16) * scale;
      smoothScroll(offsetPosition.x, targetY, 500);
    };

    const navigateToPage = (page: number) => {
      if (!settings) return;

      // Don't bother with UI callbacks or locks
      // Just directly calculate the position and move there
      const linesPerPage = Math.floor(window.innerHeight / settings.fontSize);
      const targetLine = (page - 1) * linesPerPage;
      const targetY = -targetLine * settings.fontSize * scale;

      // Just update position directly
      setOffsetPosition({ x: offsetPosition.x, y: targetY });

      // Let the ProgressBar component handle its own UI updates
    };

    // Update on position change with throttling
    useEffect(() => {
      if (!settings) return;
      
      // Get the font size from settings with a fallback value
      const fontSize = settings.fontSize || 16;
      
      // Calculate the current line based on vertical position and scale
      const currentLine = Math.floor(-offsetPosition.y / fontSize / scale);

      // Calculate how many lines fit in a page
      const linesPerPage = Math.floor(window.innerHeight / fontSize / scale);

      // Calculate the current page (1-based)
      const currentPage = Math.min(
        Math.max(1, Math.floor(currentLine / linesPerPage) + 1),
        totalPages
      );
      if (onPageChange) {
        onPageChange(currentPage, offsetPosition.y);
      }
    }, [offsetPosition, scale, settings]); // Add scale and settings as dependencies

    useImperativeHandle(
      ref,
      () => ({
        navigateToPage,
      }),
      [settings, scale, offsetPosition]
    );

    return (
      <>
        <Chapters
          chapters={chaptersData}
          handleChapterClick={handleChapterClick}
        />
        <div className="w-full flex flex-col items-center relative h-screen overflow-y-scroll custom-scrollbar">
          <div className="h-screen w-full relative">
            <Tools />
            <ToolBar selectedItemsIds={selectedItemsIds} />
            <HoverOptionsTab />
            <Stage
              width={window.innerWidth}
              style={{
                backgroundColor: settings?.backgroundColor || "#111111",
              }}
              height={window.innerHeight}
              ref={stageRef}
              scaleX={scale}
              scaleY={scale}
              draggable={false}
              onMouseDown={handleMouseDown}
              onMouseMove={handleMouseMove}
              onMouseUp={handleMouseUp}
              onDblClick={handleDoubleClick}
            >
              <MainLayer
                visibleArea={visibleArea}
                bookElements={bookElements}
                fontSize={settings?.fontSize || 16}
                width={width}
                ref={mainLayerRef}
              />
              <HoverHighlightLayer />

              <MainNotesLayer ref={mainNotesLayerRef} />
            </Stage>
          </div>
        </div>
      </>
    );
  }
);

export default KonvaStage;

```

<div style='page-break-after: always;'></div>

<h2 id="file-7-modules-bookpage-konva-components-tools-tsx">File 7: Modules/BookPage/Konva/components/Tools.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { activeToolAtom } from "../konvaAtoms";

import {
    Hand,
    MousePointer,
    Square,
    Diamond,
    Circle,
    ArrowRight,
    Minus,
    Pipette,
    Type,
    Image,
    Eraser,
} from "lucide-react";
import {
    Tooltip,
    TooltipContent,
    TooltipProvider,
    TooltipTrigger,
} from "@radix-ui/react-tooltip";
import { ScrollArea } from "@radix-ui/react-scroll-area";
import { Button } from "../../../../components/ui/button";

export type DrawingToolNames =
    | "Pan"
    | "Select"
    | "Rectangle"
    | "Circle"
    | "Arrow"
    | "Text"

type DrawingTool = {
    name: DrawingToolNames;
    icon: JSX.Element;
};

export default function Tools() {
    const [activeTool, setActiveTool] = useAtom(activeToolAtom);

    const activateTool = (tool: DrawingToolNames) => {
        setActiveTool(tool);
        console.log(`${tool} tool activated`);
    };

    const tools: DrawingTool[] = [
        { name: "Pan", icon: <Hand size={20} /> },
        { name: "Select", icon: <MousePointer size={20} /> },
        { name: "Rectangle", icon: <Square size={20} /> },
        { name: "Circle", icon: <Circle size={20} /> },
        { name: "Arrow", icon: <ArrowRight size={20} /> },
        { name: "Text", icon: <Type size={20} /> },
    ];

    return (
        <TooltipProvider>
            <div className="fixed top-4 left-1/2 transform -translate-x-1/2 z-50">
                <div className="bg-card text-card-foreground rounded-lg shadow-lg p-2">
                    <ScrollArea className="w-full whitespace-nowrap">
                        <div className="flex space-x-1">
                            {tools.map((tool) => (
                                <Tooltip key={tool.name}>
                                    <TooltipTrigger asChild>
                                        <Button
                                            variant={
                                                activeTool === tool.name
                                                    ? "default"
                                                    : "ghost"
                                            }
                                            size="icon"
                                            onClick={() =>
                                                activateTool(tool.name)
                                            }
                                            className="w-10 h-10"
                                        >
                                            {tool.icon}
                                            <span className="sr-only">
                                                {tool.name}
                                            </span>
                                        </Button>
                                    </TooltipTrigger>
                                    <TooltipContent side="bottom" >
                                        <p className="text-gray-300 mt-2">{tool.name}</p>
                                    </TooltipContent>
                                </Tooltip>
                            ))}
                        </div>
                    </ScrollArea>
                </div>
            </div>
        </TooltipProvider>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-8-modules-bookpage-konva-functions-getelementsundermouse-ts">File 8: Modules/BookPage/Konva/functions/getElementsUnderMouse.ts</h2>

```typescript
import { ArrowHover } from "../konvaAtoms";
import { FullHighlight } from "../modules/BookTextLayers/HighlightLayer";

export const getHighlightUnderMouse = (
    highlightElements: FullHighlight[] | ArrowHover[],
    pos: { x: number; y: number }
) => {
    return highlightElements.filter((highlight) =>
        highlight.rects?.some((rect) => {
            return (
                pos.x >= rect.x - 10 &&
                pos.x <= rect.x + rect.width + 10 &&
                pos.y >= rect.y - 10 &&
                pos.y <= rect.y + rect.height + 10
            );
        })
    );
};
export const getArrowHighlightsUnderMouse = (
    hoveredItems: ArrowHover[] | null,
    pos: { x: number; y: number }
) => {
    if (!hoveredItems) return [];

    return hoveredItems.filter((highlight) => {
        if (highlight.rects) {
            return highlight.rects.some((rect) => {
                return (
                    pos.x >= rect.x - 10 &&
                    pos.x <= rect.x + rect.width + 10 &&
                    pos.y >= rect.y - 10 &&
                    pos.y <= rect.y + rect.height + 10
                );
            });
        } else {
            return (
                pos.x >= highlight.points[0].x - 10 &&
                pos.x <= highlight.points[1].x &&
                pos.y >= highlight.points[0].y - 10 &&
                pos.y <= highlight.points[2].y + 10
            );
        }
    });
};
export const isPointInPolygon = (
    point: { x: number; y: number },
    polygon: { x: number; y: number }[]
) => {
    let isInside = false;
    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
        const xi = polygon[i].x,
            yi = polygon[i].y;
        const xj = polygon[j].x,
            yj = polygon[j].y;

        const intersect =
            yi > point.y !== yj > point.y &&
            point.x < ((xj - xi) * (point.y - yi)) / (yj - yi) + xi;
        if (intersect) isInside = !isInside;
    }
    return isInside;
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-9-modules-bookpage-konva-functions-getpos-ts">File 9: Modules/BookPage/Konva/functions/getPos.ts</h2>

```typescript
import Konva from "konva";

export const getPos = (
    offsetPosition: { x: number; y: number },
    scale: number,
    e: Konva.KonvaEventObject<MouseEvent>
) => {
    const stage = e.currentTarget?.getStage();
    const pointer = stage?.getPointerPosition();
    console.log("Mouse down pointer", pointer);
    console.log("Mouse down offsetPosition", offsetPosition);
    if (!pointer) return null;

    return {
        x: (pointer.x - offsetPosition.x) / scale,
        y: (pointer.y - offsetPosition.y) / scale,
    };
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-10-modules-bookpage-konva-functions-measuretextwidth-tsx">File 10: Modules/BookPage/Konva/functions/measureTextWidth.tsx</h2>

```typescript
import Konva from "konva";

export const measureTextWidth = (
    text: string,
    fontSize = 16,
    fontFamily = "Arial"
) => {
    const tempText = new Konva.Text({
        text: text,
        fontSize: fontSize,
        fontFamily: fontFamily,
        visible: false, // No need to render it
    });

    return tempText.getTextWidth(); // Use getTextWidth for accurate measurement
};
const charWidthCache = new Map<string, { char: string; width: number; cumulativeWidth: number }[]>();

export const measureCharacterWidths = (
    text: string,
    fontSize = 16,
    fontFamily = "Arial",
    strokeWidth = 1
) => {
    const key = `${text}_${fontSize}_${fontFamily}_${strokeWidth}`;
    if (charWidthCache.has(key)) return charWidthCache.get(key)!;

    const tempText = new Konva.Text({
        text: "",
        fontSize: fontSize,
        fontFamily: fontFamily,
        visible: false,
    });

    const widths = [];
    let cumulativeWidth = 0;

    for (let i = 0; i < text.length; i++) {
        const substring = text.substring(0, i + 1);
        tempText.text(substring);
        const substringWidth = tempText.getTextWidth() + strokeWidth;
        const charWidth = substringWidth - cumulativeWidth;
        cumulativeWidth = substringWidth;

        widths.push({
            char: text[i],
            width: charWidth,
            cumulativeWidth: substringWidth,
        });
    }

    charWidthCache.set(key, widths);
    return widths;
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-11-modules-bookpage-konva-functions-processelements-ts">File 11: Modules/BookPage/Konva/functions/processElements.ts</h2>

```typescript

```

<div style='page-break-after: always;'></div>

<h2 id="file-12-modules-bookpage-konva-konvaatoms-ts">File 12: Modules/BookPage/Konva/konvaAtoms.ts</h2>

```typescript
import {atom} from 'jotai';

import {CanvaElementSkeleton, Highlight, SettingsType, SpecificArrowElement, StartType} from '../../../endPointTypes/types';

import {DrawingToolNames} from './components/Tools';
import {FullHighlight, HighlightRect} from './modules/BookTextLayers/HighlightLayer';

export type ArrowHover = {
  points: HighlightPoints[]; id: string;
  type: StartType;
  rects?: HighlightRect[];
};

export type HighlightPoints = {
  x: number; y: number;
};

export const activeToolAtom = atom<DrawingToolNames>('Select');
export const stageStateAtom = atom({
  isDrawing: false,
  currentShape: null,
});
export const offsetPositionAtom = atom({
  x: -300,
  y: -200,
});
export type CurrentHighlight = {
  id?: string;
  editing: boolean;
  creating: boolean;
  mousePosition: { x: number; y: number };
  offsetPosition: { x: number; y: number };
  initialX?: number;
  initialY?: number;
};

export const highlightsAtom = atom<Highlight[]>([]);
export const highlightElementsAtom = atom<FullHighlight[]>([]);
export const currentHighlightAtom = atom<CurrentHighlight>({
  id: undefined,
  editing: false,
  creating: false,
  mousePosition: {x: 0, y: 0},
  offsetPosition: {x: 0, y: 0},
});
export const arrowsAtom = atom<SpecificArrowElement[]>([]);
export const hoveredItemsAtom = atom<ArrowHover[]>([]);
export const newArrowAtom = atom<SpecificArrowElement|null>(null);
export const canvaElementsAtom = atom<CanvaElementSkeleton[]>([]);
export const selectedArrowIdsAtom = atom<string[]>([]);
export const selectedItemsIdsAtom = atom<string[]>([]);
export const scaleAtom = atom(1);
export const bookIdAtom = atom<string|null>(null);
export const settingsAtom = atom<SettingsType|undefined>(undefined);
export const navigationSourceAtom = atom<'scroll' | 'progressBar' | null>(null);
export const lockPageUpdatesAtom = atom<boolean>(false);
export const displayPageAtom = atom<number>(1);

```

<div style='page-break-after: always;'></div>

<h2 id="file-13-modules-bookpage-konva-modules-booktextlayers-highlightlayer-tsx">File 13: Modules/BookPage/Konva/modules/BookTextLayers/HighlightLayer.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { KonvaEventObject } from "konva/lib/Node";
import {
    ForwardedRef,
    forwardRef,
    useEffect,
    useImperativeHandle,
    useState,
} from "react";
import { Rect } from "react-konva";
import { ProcessedElement } from "../../../../../preprocess/epub/htmlToBookElements";
import { VisibleArea } from "../../KonvaStage";
import { getHighlightUnderMouse } from "../../functions/getElementsUnderMouse";
import { getPos } from "../../functions/getPos";
import { measureTextWidth } from "../../functions/measureTextWidth";
import {
    activeToolAtom,
    currentHighlightAtom,
    HighlightPoints,
    highlightElementsAtom,
    highlightsAtom,
    hoveredItemsAtom,
    offsetPositionAtom,
    scaleAtom,
    settingsAtom,
} from "../../konvaAtoms";

export type FullHighlight = {
    rects: HighlightRect[];
    points: HighlightPoints[];
    id: string;
    type: "bookText";
    highlightedText?: string;
};

export type HighlightRect = {
    y: number;
    x: number;
    width: number;
    height: number;
    fill: string;
    opacity: number;
};
type HighlightLayerProps = {
    visibleArea: VisibleArea;
    fontSize: number;
    processedElements: ProcessedElement[];
};

export type HighlightLayerRef = {
    handleMouseMove(e: KonvaEventObject<MouseEvent>): void;
    handleMouseDown(e: KonvaEventObject<MouseEvent>): void;
};

function HighlightLayer(
    { visibleArea, fontSize, processedElements }: HighlightLayerProps,
    ref: ForwardedRef<HighlightLayerRef>
) {
    const [highlights] = useAtom(highlightsAtom);

    const [highlightElements, setHighlightElements] = useAtom(highlightElementsAtom);
    const [virtualizedHighlights, setVirtualizedHighlights] = useState<
        JSX.Element[]
    >([]);
    const [hoveredItems, setHoveredItems] = useAtom(hoveredItemsAtom);
    const [activeTool] = useAtom(activeToolAtom);
    const [scale] = useAtom(scaleAtom);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [settings] = useAtom(settingsAtom);
    const [currentHighlight, setCurrentHighlight] =
        useAtom(currentHighlightAtom);
    useImperativeHandle(
        ref,
        () => ({
            handleMouseMove(e: KonvaEventObject<MouseEvent>) {
                if (activeTool !== "Arrow" && activeTool !== "Select") return;
                const pos = getPos(offsetPosition, scale, e);
                if (!pos) return;
                const highlightsUnderMouse = getHighlightUnderMouse(
                    highlightElements,
                    pos
                );
                if (highlightsUnderMouse.length > 0) {
                    const firstHighlight = highlightsUnderMouse[0];

                    // Check if the first highlight under the mouse is already hovered
                    const isAlreadyHovered = hoveredItems.some(
                        (highlight) => highlight.id === firstHighlight.id
                    );
                    console.log("isAlreadyHovered", isAlreadyHovered);

                    if (isAlreadyHovered) {
                        // If it's already hovered, refresh its position in the hovered list
                        setHoveredItems((prevHighlights) =>{
                            const newhovers =  [
                            ...prevHighlights.filter(
                                    (highlight) =>
                                        highlight.id !== firstHighlight.id
                                ),
                                firstHighlight,
                            ];
                            console.log("newhovers", newhovers);
                            return newhovers;
                        });
                    } else {
                        // If it's a new highlight, update hoveredHighlight to the first highlight under the mouse
                        setHoveredItems((prevHighlights) => [
                            ...prevHighlights,
                            firstHighlight,
                        ]);
                    }
                } else {
                    // If no highlights are under the mouse and hoveredHighlight exists, do nothing
                    if (!hoveredItems) {
                        return;
                    }
                }
            },
            handleMouseDown(e: KonvaEventObject<MouseEvent>) {
                //#endregion
                if (currentHighlight.creating) return;
                const pos = getPos(offsetPosition, scale, e);
                if (!pos) return;
                const highlightsUnderMouse = getHighlightUnderMouse(
                    highlightElements,
                    pos
                );
                if (
                    highlightsUnderMouse.length === 0 ||
                    activeTool !== "Select"
                ) {
                    setCurrentHighlight({
                        id: undefined,
                        editing: false,
                        creating: false,
                        mousePosition: { x: 0, y: 0 },
                        offsetPosition: { x: 0, y: 0 },
                    });
                    setHoveredItems([]);
                    return;
                }
                const mousePosInViewport = {
                    x: e.evt.offsetX,
                    y: e.evt.offsetY,
                };
                console.log("highlightElements", highlightElements);
                console.log("highlights", highlights);

                setCurrentHighlight({
                    id: highlightsUnderMouse[0].id,
                    editing: true,
                    creating: false,
                    mousePosition: pos,
                    offsetPosition: mousePosInViewport,
                });
            },
        }),
        [
            highlightElements,
            currentHighlight,
            hoveredItems,
            activeTool,
            scale,
            offsetPosition,
            settings,
        ]
    );

    useEffect(() => {
        setHighlightElements(createHighlightElements());
    }, [highlights, fontSize, settings]);
    useEffect(() => {
        setVirtualizedHighlights(
            highlightElements.flatMap((highlightElement) =>
                highlightElement.rects
                    .filter(
                        (element) =>
                            element.x + element.width > visibleArea.x &&
                            element.x < visibleArea.x + visibleArea.width &&
                            element.y + element.height > visibleArea.y &&
                            element.y < visibleArea.y + visibleArea.height
                    )
                    .flatMap((element, index) => (
                        <Rect
                            key={highlightElement.id + index}
                            x={element.x}
                            y={element.y}
                            width={element.width}
                            height={element.height}
                            fill={element.fill}
                            opacity={element.opacity}
                        />
                    ))
            )
        );
    }, [visibleArea, highlightElements, fontSize, settings]);
    const createHighlightElements = (): FullHighlight[] => {
        return highlights.map((highlight) => {
            const rects: HighlightRect[] = [];

            // Determine the actual start and end positions
            const startY = Math.min(highlight.startingY, highlight.endY);
            const endY = Math.max(highlight.startingY, highlight.endY);

            let startX, endX;

            // Adjust startingX and endX based on the direction
            if (highlight.startingY < highlight.endY) {
                startX = highlight.startingX;
                endX = highlight.endX;
            } else if (highlight.startingY > highlight.endY) {
                startX = highlight.endX;
                endX = highlight.startingX;
            } else {
                // Same line, adjust startX and endX
                startX = Math.min(highlight.startingX, highlight.endX);
                endX = Math.max(highlight.startingX, highlight.endX);
            }

            const range = endY - startY;

            const leftPoints = [];
            const rightPoints = [];

            // Collect points and rects in one loop
            for (let i = 0; i <= range; i++) {
                const currentLineIndex = startY + i;
                const text = processedElements[currentLineIndex].text;
                const letterWidth =
                    measureTextWidth(text, fontSize, settings?.fontFamily) / text.length;

                let currentX = 0;
                let lineWidth = text.length * letterWidth;

                if (i === 0) {
                    // First line
                    currentX = startX * letterWidth;
                    if (range === 0) {
                        // Single-line highlight
                        lineWidth = (endX - startX + 1) * letterWidth;
                    } else {
                        lineWidth = text.length * letterWidth - currentX;
                    }
                } else if (i === range) {
                    // Last line
                    currentX = 0;
                    lineWidth = (endX + 1) * letterWidth;
                } else {
                    // Middle lines (full line)
                    currentX = 0;
                    lineWidth = text.length * letterWidth;
                }

                const x = currentX + 600;
                const y = currentLineIndex * fontSize + 200;
                const height = fontSize;

                // Add rectangle to rects array
                rects.push({
                    y: y,
                    x: x,
                    width: lineWidth,
                    height: height,
                    fill: "yellow",
                    opacity: 0.5,
                });

                // Collect the left and right points
                leftPoints.push({ x: x, y: y }); // Top-left corner
                leftPoints.push({ x: x, y: y + height }); // Bottom-left corner
                rightPoints.push({ x: x + lineWidth, y: y }); // Top-right corner
                rightPoints.push({ x: x + lineWidth, y: y + height }); // Bottom-right corner

                // Collect the bottom points
            }
            leftPoints.reverse();
            // Reverse the leftPoints to maintain clockwise order
            // Combine the points
            const polygonPoints = [
                leftPoints[leftPoints.length - 1],
                ...rightPoints,
                ...leftPoints.slice(0, leftPoints.length - 1),
            ];

            return {
                id: highlight.id,
                points: polygonPoints,
                rects: rects,
                type: "bookText",
                highlightedText: highlight.highlightedText
            };
        });
    };

    return <>{virtualizedHighlights}</>;
}
export default forwardRef(HighlightLayer);

```

<div style='page-break-after: always;'></div>

<h2 id="file-14-modules-bookpage-konva-modules-booktextlayers-hoverhighlightlayer-tsx">File 14: Modules/BookPage/Konva/modules/BookTextLayers/HoverHighlightLayer.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { useEffect, useState } from "react";
import { Layer, Shape } from "react-konva";
import { hoveredItemsAtom } from "../../konvaAtoms";

type HoverHighlightLayerProps = {
    // Define your prop types here
};

export default function HoverHighlightLayer({}: HoverHighlightLayerProps) {
    const [hoveredItems] = useAtom(hoveredItemsAtom);

    const [renderedHover, setRenderedHover] = useState<JSX.Element[]>([]);
    const createHighlightHover = () => {

        if (!hoveredItems) {
            setRenderedHover([]);
            return;
        }
        //const scaleY = 1.1;
        //const scaleX = 1.25;

        setRenderedHover(
            hoveredItems.map((hover) => (
                <Shape
                    sceneFunc={(context, shape) => {
                        context.beginPath();

                        // Calculate the center of the shape
                        const centerX =
                            hover.points.reduce((sum, p) => sum + p.x, 0) /
                            hover.points.length;
                        const centerY =
                            hover.points.reduce((sum, p) => sum + p.y, 0) /
                            hover.points.length;

                        // Translate the context to the center
                        context.translate(centerX, centerY);

                        

                        // Translate back from the center
                        context.translate(-centerX, -centerY);

                        // Draw the scaled shape
                        hover.points.forEach((point, index) => {
                            const scaledX = point.x;
                            const scaledY = point.y;
                            if (index === 0) {
                                context.moveTo(scaledX, scaledY);
                            } else {
                                context.lineTo(scaledX, scaledY);
                            }
                        });

                        context.closePath();
                        context.fillStrokeShape(shape);
                    }}
                    fill="red"
                    stroke="black"
                    strokeWidth={2}
                    opacity={0.5}
                />
            ))
        );
    };

    useEffect(() => {
        createHighlightHover();
    }, [hoveredItems]);
    return <Layer>{renderedHover}</Layer>;
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-15-modules-bookpage-konva-modules-booktextlayers-hoveroptionstab-tsx">File 15: Modules/BookPage/Konva/modules/BookTextLayers/HoverOptionsTab.tsx</h2>

```typescript
import { useAtom, useSetAtom } from "jotai";
import { useState, useEffect } from "react";
import { FiEdit, FiMessageCircle, FiSave, FiTrash2, FiX, FiCopy } from "react-icons/fi"; // Added FiCopy
import { Button } from "../../../../../components/ui/button";
import { Card } from "../../../../../components/ui/card"; // Import Card for styling
import { Textarea } from "../../../../../components/ui/textarea"; // Import Textarea from shadcn
import {
    arrowsAtom,
    bookIdAtom,
    canvaElementsAtom,
    currentHighlightAtom,
    highlightsAtom,
    hoveredItemsAtom,
} from "../../konvaAtoms";
import createArrow from "../../shapes/Arrow/CreateArrow";
import CreateText from "../../shapes/Text/CreateText";
import { useToast } from "../../../../../hooks/use-toast";
type HoverOptionsTabProps = {};

export default function HoverOptionsTab({}: HoverOptionsTabProps) {
    const [currentHighlight, setCurrentHighlight] =
        useAtom(currentHighlightAtom);
    const [highlights] = useAtom(highlightsAtom);
    const setHighlights = useSetAtom(highlightsAtom);
    const setHoveredItems = useSetAtom(hoveredItemsAtom);
    const [canvaElements, setCanvaElements] = useAtom(canvaElementsAtom);
    const [arrowElements, setArrowElements] = useAtom(arrowsAtom);
    const [isAddingNote, setIsAddingNote] = useState(false);
    const [noteText, setNoteText] = useState("");
    const [bookId] = useAtom(bookIdAtom);
    const [currentHighlightText, setCurrentHighlightText] = useState("");
    const { toast } = useToast();
    // Get the highlighted text when currentHighlight changes
    useEffect(() => {
        if (currentHighlight.id) {
            const highlight = highlights.find(h => h.id === currentHighlight.id);
            if (highlight?.highlightedText) {
                setCurrentHighlightText(highlight.highlightedText);
            }
        }
    }, [currentHighlight, highlights]);
    
    const deleteHighlight = () => {
        setHighlights((highlights) =>
            highlights.filter(
                (highlight) => highlight.id !== currentHighlight.id
            )
        );
        setHoveredItems([]);

        setCurrentHighlight({
            id: undefined,
            editing: false,
            creating: false,
            mousePosition: { x: 0, y: 0 },
            offsetPosition: { x: 0, y: 0 },
        });
    };

    
    const addComment = () => {
        setIsAddingNote(true);
    };

    const handleSaveNote = () => {
        if (noteText.trim() === "") {
            // Optionally, you can add validation or error handling here
            return;
        }
        if (!bookId) return;

        console.log("Save Note", noteText);
        const textX = currentHighlight.mousePosition.x + 400;
        const textY = currentHighlight.mousePosition.y ;
        const newNoteText = CreateText({
            x: textX,
            y: textY,
            bookId: bookId,
            text: noteText,
            fill: "black",
            strokeColor: "white",
        });
        const newNoteArrow = createArrow({
            points: [
                {
                    x: currentHighlight.mousePosition.x,
                    y: currentHighlight.mousePosition.y,
                },
                { x: textX, y: textY },
            ],
            bookId,
            startId: currentHighlight.id,
            endId: newNoteText.id,
            startType: "bookText",
            endType: "text",
        });
        setCanvaElements([...canvaElements, newNoteText]);
        setArrowElements([...arrowElements, newNoteArrow]);
        // Reset the state
        setNoteText("");
        setIsAddingNote(false);
        setCurrentHighlight({
            ...currentHighlight,
            editing: false,
        });
    };

    const handleCancelNote = () => {
        setNoteText("");
        setIsAddingNote(false);
    };

    const copyHighlightedText = () => {
        if (currentHighlightText) {
            navigator.clipboard.writeText(currentHighlightText)
                .then(() => {
                    // Show success message if you have a toast component
                    toast?.({
                        title: "Text copied",
                        description: "Highlighted text copied to clipboard",
                    });
                })
                .catch(err => {
                    console.error('Could not copy text: ', err);
                });
        }
    };

    return (
        <div className="absolute z-50">
            {!currentHighlight.creating && currentHighlight.editing ? (
                <Card
                    style={{
                        position: "absolute",
                        top: currentHighlight.offsetPosition.y,
                        left: currentHighlight.offsetPosition.x,
                    }}
                    className="w-64"
                >
                    <div className="divide-y divide-gray-200">
                        {currentHighlightText && (
                            <div className="p-3">
                                <p className="text-sm font-medium text-gray-700 mb-1">Highlighted Text:</p>
                                <p className="text-sm text-gray-600 italic mb-2 line-clamp-3">{currentHighlightText}</p>
                                <Button
                                    variant="outline"
                                    size="sm"
                                    onClick={copyHighlightedText}
                                    className="flex items-center gap-1 text-xs"
                                >
                                    <FiCopy className="h-3 w-3" /> Copy Text
                                </Button>
                            </div>
                        )}
                        {!isAddingNote && (
                            <div
                                className="flex items-center gap-2 p-3 rounded-lg hover:bg-gray-100 cursor-pointer"
                                onClick={addComment}
                            >
                                <FiMessageCircle className="text-gray-500" />
                                <span>Add Note</span>
                            </div>
                        )}
                        {isAddingNote && (
                            <div className="p-3">
                                <Textarea
                                    value={noteText}
                                    onChange={(e) =>
                                        setNoteText(e.target.value)
                                    }
                                    placeholder="Enter your note..."
                                    className="mb-2"
                                />
                                <div className="flex justify-end gap-2">
                                    <Button
                                        variant="secondary"
                                        size="sm"
                                        onClick={handleCancelNote}
                                        className="flex items-center gap-1"
                                    >
                                        <FiX /> Cancel
                                    </Button>
                                    <Button
                                        size="sm"
                                        onClick={handleSaveNote}
                                        className="flex items-center gap-1"
                                    >
                                        <FiSave /> Save
                                    </Button>
                                </div>
                            </div>
                        )}
                        <div
                            className="flex items-center gap-2 p-3 rounded-lg hover:bg-red-100 cursor-pointer text-red-600"
                            onClick={deleteHighlight}
                        >
                            <FiTrash2 className="text-red-600" />
                            <span>Delete</span>
                        </div>
                    </div>
                </Card>
            ) : null}
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-16-modules-bookpage-konva-modules-booktextlayers-mainlayer-tsx">File 16: Modules/BookPage/Konva/modules/BookTextLayers/MainLayer.tsx</h2>

```typescript
import { KonvaEventObject } from "konva/lib/Node";
import { ForwardedRef, forwardRef, useImperativeHandle, useRef } from "react";
import { Layer } from "react-konva";
import { VisibleArea } from "../../KonvaStage";

import HighlightLayer, { HighlightLayerRef } from "./HighlightLayer";
import TextLayer, { TextLayerRef } from "./TextLayer";
import { ProcessedElement } from "../../../../../preprocess/epub/htmlToBookElements";

type MainLayerProps = {
    bookElements: ProcessedElement[];
    visibleArea: VisibleArea;
    fontSize: number;
    width: number;
};

export type MainLayerRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
};

function MainLayer(
    { bookElements, visibleArea, fontSize, width }: MainLayerProps,
    ref: ForwardedRef<MainLayerRef>
) {
    const highlightComponentRef = useRef<HighlightLayerRef | null>(null);
    const textComponentRef = useRef<TextLayerRef | null>(null);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
    }));
    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        if (highlightComponentRef.current) {
            highlightComponentRef.current.handleMouseDown(e);
        }
        if (textComponentRef.current) {
            textComponentRef.current.handleMouseDown(e);
        }
    };
    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        if (textComponentRef.current) {
            textComponentRef.current.handleMouseMove(e);
        }
        if (highlightComponentRef.current) {
            highlightComponentRef.current.handleMouseMove(e);
        }
    };
    const handleMouseUp = () => {
        if (textComponentRef.current) {
            textComponentRef.current.handleMouseUp();
        }
    };

    return (
        <Layer>
            <HighlightLayer
                ref={highlightComponentRef}
                processedElements={bookElements}
                visibleArea={visibleArea}
                fontSize={fontSize}
            />
            <TextLayer
                ref={textComponentRef}
                processedElements={bookElements}
                visibleArea={visibleArea}
                fontSize={fontSize}
                width={width}
            />
        </Layer>
    );
}
export default forwardRef(MainLayer);

```

<div style='page-break-after: always;'></div>

<h2 id="file-17-modules-bookpage-konva-modules-booktextlayers-textlayer-tsx">File 17: Modules/BookPage/Konva/modules/BookTextLayers/TextLayer.tsx</h2>

```typescript
import {
    ForwardedRef,
    forwardRef,
    useEffect,
    useImperativeHandle,
    useState,
} from "react";
import { Text } from "react-konva";
import { v4 as uuidv4 } from "uuid";

import { useAtom } from "jotai";
import { KonvaEventObject } from "konva/lib/Node";
import { ProcessedElement } from "../../../../../preprocess/epub/htmlToBookElements";
import { VisibleArea } from "../../KonvaStage";
import { getPos } from "../../functions/getPos";
import {
    measureCharacterWidths,
    measureTextWidth,
} from "../../functions/measureTextWidth";
import {
    activeToolAtom,
    bookIdAtom,
    currentHighlightAtom,
    highlightsAtom,
    offsetPositionAtom,
    scaleAtom,
} from "../../konvaAtoms";
import { useSettings } from "../../../../../hooks/useSettings";

type TextLayerProps = {
    visibleArea: VisibleArea;
    fontSize: number;
    width: number;
    processedElements: ProcessedElement[];
};
// Specific element types

export type TextLayerRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
};

type BookTextElement = {
    x: number;
    y: number;
    width: number;
    height: number;
    text: string;
    fontSize: number;
    fill: string;
    fontFamily: string;
    strokeColor: string;
    strokeWidth: number;
    opacity: number;
};

function TextLayer(
    { visibleArea, processedElements }: TextLayerProps,
    ref: ForwardedRef<TextLayerRef>
) {
    const [textElements, setTextElements] = useState<BookTextElement[]>([]);
    const [virtualizedText, setVirtualizedText] = useState<JSX.Element[]>([]);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [_, setHighlights] = useAtom(highlightsAtom);
    const [currentHighlight, setCurrentHighlight] =
        useAtom(currentHighlightAtom);
    const [activeTool] = useAtom(activeToolAtom);
    const [scale] = useAtom(scaleAtom);
    const [initialOffset] = useState({ x: 600, y: 200 });
    const { settings } = useSettings();
    const [bookId] = useAtom(bookIdAtom);
    const fontSize = settings?.fontSize;
    const fontFamily = settings?.fontFamily;
    useImperativeHandle(
        ref,
        () => ({
            handleMouseDown(e: KonvaEventObject<MouseEvent>) {
                if (!bookId) return;
                if (!fontSize) return;
                const pos = getPos(offsetPosition, scale, e);
                if (!pos) return;
                if (activeTool !== "Select") return;
                if (!e.target.attrs.text) return;
                const currentId = uuidv4() as string;
                const element = Math.floor(
                    (pos.y - initialOffset.y) / fontSize
                );
                const textElement = textElements[element];
                const textElementCords = [
                    textElement.x,
                    textElement.x +
                        measureTextWidth(textElement.text, fontSize, fontFamily),
                ];
                if (pos.x < textElementCords[0] || pos.x > textElementCords[1])
                    return;
                setCurrentHighlight({
                    id: currentId,
                    editing: false,
                    creating: true,
                    mousePosition: { x: pos.x, y: pos.y },
                    offsetPosition: { x: e.evt.offsetX, y: e.evt.offsetY },
                });
                
                // Calculate the starting positions
                const startingX = calculateXPositionInText(
                    e.target.attrs.text,
                    e.target.attrs.x,
                    pos.x,
                    scale
                );
                const startingY = Math.floor(
                    (e.target.attrs.y - initialOffset.y) / fontSize
                );
                
                setHighlights((oldHighlights) => [
                    ...oldHighlights,
                    {
                        bookId: bookId,
                        id: currentId,
                        startingX: startingX,
                        startingY: startingY,
                        endX: startingX,
                        endY: startingY,
                        // Initialize with the character at the starting position
                        highlightedText: e.target.attrs.text.charAt(startingX) || ''
                    },
                ]);
            },
            handleMouseMove(e: KonvaEventObject<MouseEvent>) {
                if (!fontSize) return;

                if (!currentHighlight.creating) return;
                const currentHighlightId = currentHighlight.id;
                if (!e.target.attrs.text) return;
                const pos = getPos(offsetPosition, scale, e);
                if (!pos) return;
                const element = Math.floor(
                    (pos.y - initialOffset.y) / fontSize
                );
                const textElement = textElements[element];
                const textElementCords = [
                    textElement.x,
                    textElement.x +
                        measureTextWidth(textElement.text, fontSize, fontFamily),
                ];
                if (pos.x < textElementCords[0] || pos.x > textElementCords[1])
                    return;
                setHighlights((highlights) => {
                    if (!fontSize) return highlights;
                    const newHighlights = [...highlights];
                    const highlight = newHighlights.find(
                        (highlight) => currentHighlightId === highlight.id
                    );

                    if (!highlight) return highlights;
                    const xPos = calculateXPositionInText(
                        e.target.attrs.text,
                        e.target.attrs.x,
                        pos.x,
                        scale
                    );

                    const yPos = Math.floor(
                        (e.target.attrs.y - initialOffset.y) / fontSize
                    );

                    // Update only if the positions are different
                    highlight.endX = xPos;
                    highlight.endY = yPos;
                    
                    // Update the highlighted text when dragging
                    highlight.highlightedText = extractHighlightedText(
                        processedElements,
                        highlight.startingY,
                        highlight.startingX,
                        highlight.endY,
                        highlight.endX
                    );
                    
                    return newHighlights;
                });
            },
            handleMouseUp() {
                setCurrentHighlight((currentHighlight) =>
                    currentHighlight.creating || currentHighlight.editing
                        ? {
                              id: currentHighlight.id,
                              editing: true,
                              creating: false,
                              mousePosition: currentHighlight.mousePosition,
                              offsetPosition: currentHighlight.offsetPosition,
                          }
                        : {
                              id: undefined,
                              editing: false,
                              creating: false,
                              mousePosition: { x: 0, y: 0 },
                              offsetPosition: { x: 0, y: 0 },
                          }
                );
            },
        }),
        [
            setCurrentHighlight,
            setHighlights,

            currentHighlight,
            activeTool,
            scale,
            offsetPosition,
            settings,
            fontSize,
            fontFamily,
        ]
    );

    const calculateXPositionInText = (
        text: string,
        textStartingX: number,
        mouseStartingX: number,
        scale: number
    ) => {
        if (!settings) return 0;
        const characterWidths = measureCharacterWidths(
            text,
            fontSize,
            settings.fontFamily
        );
        //const textWidth = measureTextWidth(text, fontSize, settings.fontFamily);
        const mouseRelativeX = (mouseStartingX - textStartingX) * scale;
        // Find the character corresponding to the mouse position
        let posInText = 0;

        for (let i = 0; i < characterWidths.length; i++) {
            const { cumulativeWidth } = characterWidths[i];
            if (mouseRelativeX < cumulativeWidth) {
                posInText = i;
                break;
            }
        }

        return posInText;
    };

    useEffect(() => {
        setTextElements(createTextElements());
    }, [processedElements, settings]);

    useEffect(() => {
        setVirtualizedText(
            textElements
                .filter(
                    (element) =>
                        element.x + element.width > visibleArea.x &&
                        element.x < visibleArea.x + visibleArea.width &&
                        element.y + element.height > visibleArea.y &&
                        element.y < visibleArea.y + visibleArea.height
                )
                .map((element, index) => (
                    <Text
                        key={index}
                        x={element.x}
                        y={element.y}
                        width={element.width}
                        height={element.height}
                        fill={element.fill}
                        text={element.text}
                        fontSize={element.fontSize}
                        fontFamily={element.fontFamily}
                    />
                ))
        );
    }, [visibleArea, textElements, offsetPosition, scale, settings]);
    const createTextElements = (): BookTextElement[] => {
        if (!settings) return [];
        if (!fontSize) return [];
        // Process the text elements from the book

        // Render the text elements with highlights
        return processedElements.map((textElement) => {
            // Check if this textElement falls within any highlight region

            return {
                id: uuidv4(),
                type: "bookText",
                x: textElement.lineX + initialOffset.x,
                y: textElement.lineY * fontSize + initialOffset.y,
                width: textElement.lineWidth,
                height: fontSize * settings.lineHeight,
                text: textElement.text,
                fontSize: fontSize,
                fill: settings.textColor,
                fontFamily: settings.fontFamily,
                strokeColor: "black",
                strokeWidth: 1,
                opacity: 1,
                outgoingArrowIds: [],
                incomingArrowIds: [],
                points: [
                    {
                        x: textElement.lineX + initialOffset.x,
                        y:
                            textElement.lineY * fontSize * settings.lineHeight +
                            initialOffset.y,
                    },
                    {
                        x:
                            textElement.lineX +
                            textElement.lineWidth +
                            initialOffset.x,
                        y:
                            textElement.lineY * fontSize * settings.lineHeight +
                            initialOffset.y,
                    },
                    {
                        x:
                            textElement.lineX +
                            textElement.lineWidth +
                            initialOffset.x,
                        y:
                            textElement.lineY * fontSize * settings.lineHeight +
                            initialOffset.y +
                            fontSize * settings.lineHeight,
                    },
                    {
                        x: textElement.lineX + initialOffset.x,
                        y:
                            textElement.lineY * fontSize * settings.lineHeight +
                            initialOffset.y +
                            fontSize * settings.lineHeight,
                    },
                ],
            };
        });
    };

    return <>{virtualizedText}</>;
}

export default forwardRef(TextLayer);

// Add this helper function to extract the highlighted text
const extractHighlightedText = (
    elements: ProcessedElement[],
    startY: number,
    startX: number,
    endY: number,
    endX: number
): string => {
    // Ensure proper ordering of start and end positions
    const actualStartY = Math.min(startY, endY);
    const actualEndY = Math.max(startY, endY);
    let actualStartX = startY <= endY ? startX : endX;
    let actualEndX = startY <= endY ? endX : startX;
    
    // Single line highlight
    if (actualStartY === actualEndY) {
        if (actualStartX > actualEndX) {
            [actualStartX, actualEndX] = [actualEndX, actualStartX];
        }
        const line = elements[actualStartY]?.text || '';
        return line.substring(actualStartX, actualEndX + 1);
    }
    
    // Multi-line highlight
    let result = '';
    for (let i = actualStartY; i <= actualEndY; i++) {
        const line = elements[i]?.text || '';
        if (i === actualStartY) {
            // First line - from start position to end of line
            result += line.substring(actualStartX) + ' ';
        } else if (i === actualEndY) {
            // Last line - from start of line to end position
            result += line.substring(0, actualEndX + 1);
        } else {
            // Middle lines - entire line
            result += line + ' ';
        }
    }
    
    return result.trim();
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-18-modules-bookpage-konva-modules-noteslayer-mainnoteslayer-tsx">File 18: Modules/BookPage/Konva/modules/NotesLayer/MainNotesLayer.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { KonvaEventObject } from "konva/lib/Node";
import { ForwardedRef, forwardRef, useImperativeHandle, useRef } from "react";
import { Layer } from "react-konva";
import { activeToolAtom } from "../../konvaAtoms";

import { Html } from "react-konva-utils";
import ArrowShape, { ArrowShapeRef } from "../../shapes/Arrow/ArrowShape";
import CanvasElement, { CanvaElementRef } from "../../shapes/CanvaElement";

type MainNotesLayerProps = {
    // Define your prop types here
};

export type ShapeType = "Rectangle" | "Circle" | "Arrow" | "Line" | "Text";

export type MainNotesLayerRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleDoubleClick: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: (e: KonvaEventObject<MouseEvent>) => void;
    handleKeyDown: (e: KeyboardEvent) => void;
};

function MainNotesLayer(
    {}: MainNotesLayerProps,
    ref: ForwardedRef<MainNotesLayerRef>
) {
    const [activeTool] = useAtom(activeToolAtom);

    const arrowShapeRef = useRef<ArrowShapeRef | null>(null);
    const canvasElementRef = useRef<CanvaElementRef | null>(null);
    // Handle Mouse Down
    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        canvasElementRef.current?.handleMouseDown(e);
    };

    const inputRef = useRef<HTMLInputElement | null>(null);

    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (
            canvasElementRef.current &&
            canvasElementRef.current.handleInputChange
        ) {
            canvasElementRef.current.handleInputChange(e);
        }
    };

    const handleKeyDown = (e: KeyboardEvent) => {
        canvasElementRef.current?.handleKeyDown(e);
    };

    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        if (activeTool === "Arrow" && arrowShapeRef.current) {
            arrowShapeRef.current.handleMouseMove(e);
        }
        canvasElementRef.current?.handleMouseMove(e);
    };

    const handleMouseUp = (e: KonvaEventObject<MouseEvent>) => {
        if (activeTool === "Arrow" && arrowShapeRef.current) {
            arrowShapeRef.current.handleMouseUp(e);
        }
        canvasElementRef.current?.handleMouseUp();
    };

    const handleDoubleClick = (e: KonvaEventObject<MouseEvent>) => {
        canvasElementRef.current?.handleDoubleClick(e);
    };

    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleKeyDown,
        handleDoubleClick,
    }));

    return (
        <>
            <Layer>
                <Html>
                    <input
                        ref={inputRef}
                        type="text"
                        style={{
                            display: "none",
                            position: "absolute",
                            backgroundColor: "#27272a", // zinc-800
                            color: "#d1d5db", // gray-300
                            border: "0", // gray-300 border
                            outline: "none", // Removes default outline for focus states
                        }}
                        onChange={handleInputChange}
                    />
                </Html>
                {/* Render arrows */}
                <ArrowShape ref={arrowShapeRef} />
                {/* Render text items */}
                <CanvasElement
                    ref={canvasElementRef}
                    inputRef={inputRef}
                    arrowShapeRef={arrowShapeRef}
                />
            </Layer>
        </>
    );
}

export default forwardRef(MainNotesLayer);

```

<div style='page-break-after: always;'></div>

<h2 id="file-19-modules-bookpage-konva-modules-toolbar-colorpicker-tsx">File 19: Modules/BookPage/Konva/modules/ToolBar/ColorPicker.tsx</h2>

```typescript
import { Check } from "lucide-react";
import { motion } from "framer-motion";

type ColorPickerProps = {
    selectedColor: string;
    onChange: (color: string) => void;
    colors: string[];
};

const ColorPicker = ({ selectedColor, onChange, colors }: ColorPickerProps) => {
    return (
        <div className="flex flex-col gap-3">
            <div className="grid grid-cols-5 gap-2">
                {colors.map((color) => (
                    <motion.button
                        key={color}
                        className={`relative h-8 w-8 rounded-full transition-all duration-200 flex items-center justify-center`}
                        style={{ backgroundColor: color }}
                        onClick={() => onChange(color)}
                        whileHover={{ scale: 1.1 }}
                        whileTap={{ scale: 0.95 }}
                    >
                        {selectedColor === color && (
                            <motion.div
                                initial={{ scale: 0 }}
                                animate={{ scale: 1 }}
                                className={`flex items-center justify-center`}
                            >
                                <Check 
                                    className={`h-4 w-4 ${
                                        color === "#ffffff" || color === "#ffec99" || color === "#b2f2bb" || color === "#ffc9c9" || color === "#a5d8ff"
                                            ? "text-black"
                                            : "text-white"
                                    }`} 
                                />
                            </motion.div>
                        )}
                    </motion.button>
                ))}
            </div>
            <div>
                <input
                    type="color"
                    value={selectedColor}
                    onChange={(e) => onChange(e.target.value)}
                    className="w-full h-8 cursor-pointer"
                />
            </div>
        </div>
    );
};

export default ColorPicker;

```

<div style='page-break-after: always;'></div>

<h2 id="file-20-modules-bookpage-konva-modules-toolbar-slidercontrol-tsx">File 20: Modules/BookPage/Konva/modules/ToolBar/SliderControl.tsx</h2>

```typescript
import { Slider } from "../../../../../components/ui/slider";

type SliderControlProps = {
    id: string;
    min: number;
    max: number;
    step: number;
    value: number;
    onChange: (value: number) => void;
};

const SliderControl = ({
    id,
    min,
    max,
    step,
    value,
    onChange,
}: SliderControlProps) => {
    return (
        <Slider
            id={id}
            min={min}
            max={max}
            step={step}
            value={[value]}
            onValueChange={(values) => onChange(values[0])}
            className="py-0.5"
        />
    );
};

export default SliderControl;

```

<div style='page-break-after: always;'></div>

<h2 id="file-21-modules-bookpage-konva-modules-toolbar-toolbar-config-ts">File 21: Modules/BookPage/Konva/modules/ToolBar/ToolBar.config.ts</h2>

```typescript
// ToolBar.config.ts

export const toolbarConfig: any = {
    rect: [
        {
            groupName: "Stroke",
            controls: [
                {
                    property: "strokeColor",
                    label: "Stroke Color",
                    type: "color",
                },
                {
                    property: "strokeWidth",
                    label: "Stroke Width",
                    type: "number",
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                },
            ],
        },
        {
            groupName: "Fill",
            controls: [
                { property: "fill", label: "Fill Color", type: "color" },
            ],
        },
        {
            groupName: "Effects",
            controls: [
                {
                    property: "rectElement.roughness",
                    label: "Roughness",
                    type: "number",
                    min: 0,
                    max: 5,
                    step: 0.1,
                },
                {
                    property: "rectElement.fillStyle",
                    label: "Fill Style",
                    type: "select",
                    options: ["hachure", "solid", "zigzag", "cross-hatch"],
                },
                {
                    property: "rectElement.hachureGap",
                    label: "Hachure Gap",
                    type: "number",
                    min: 0,
                    max: 20,
                    step: 0.5,
                },
                {
                    property: "rectElement.hachureAngle",
                    label: "Hachure Angle",
                    type: "number",
                    min: 0,
                    max: 360,
                    step: 2,
                },
            ],
        },
    ],
    text: [
        // Similar grouping for text elements
    ],
    arrow: [
        {
            groupName: "Stroke",
            controls: [
                {
                    property: "stroke",
                    label: "Stroke Color",
                    type: "color",
                },
                {
                    property: "strokeWidth",
                    label: "Stroke Width",
                    type: "number",
                    min: 0.1,
                    max: 10,
                    step: 0.1,
                },
                {
                    property: "strokeStyle",
                    label: "Stroke Style",
                    type: "select",
                    options: ["solid", "dashed", "dotted"],
                },
            ],
        },
        {
            groupName: "Fill",
            controls: [
                {
                    property: "fill",
                    label: "Fill Color",
                    type: "color",
                },
                {
                    property: "fillStyle",
                    label: "Fill Style",
                    type: "select",
                    options: [
                        "solid",
                        "hachure",
                        "cross-hatch",
                        "zigzag",
                        "dots",
                        "dashed",
                        "zigzag-line",
                    ],
                },
                {
                    property: "fillWeight",
                    label: "Fill Weight",
                    type: "number",
                    min: 0,
                    max: 20,
                    step: 0.5,
                },
            ],
        },
        {
            groupName: "Effects",
            controls: [
                {
                    property: "roughness",
                    label: "Roughness",
                    type: "number",
                    min: 0,
                    max: 5,
                    step: 0.1,
                },
                {
                    property: "hachureGap",
                    label: "Hachure Gap",
                    type: "number",
                    min: 0,
                    max: 20,
                    step: 0.5,
                },
                {
                    property: "hachureAngle",
                    label: "Hachure Angle",
                    type: "number",
                    min: 0,
                    max: 360,
                    step: 2,
                },
            ],
        },
        {
            groupName: "Arrow Properties",
            controls: [
                {
                    property: "startType",
                    label: "Start Type",
                    type: "select",
                    options: ["arrow", "circle", "square", "none"],
                },
                {
                    property: "endType",
                    label: "End Type",
                    type: "select",
                    options: ["arrow", "circle", "square", "none"],
                },
            ],
        },
    ],
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-22-modules-bookpage-konva-modules-toolbar-toolbar-tsx">File 22: Modules/BookPage/Konva/modules/ToolBar/ToolBar.tsx</h2>

```typescript
import { useState, useRef, useEffect } from "react";
import { useAtom } from "jotai";
import { 
    ChevronDown, 
    ChevronRight, 
    ChevronUp, 
    GripVertical, 
    Trash2, 
    X, 
    Type, 
    Bold, 
    Italic, 
    Underline, 
    AlignLeft, 
    AlignCenter, 
    AlignRight, 
    AlignJustify,
    Palette,
    Circle,
    Square,
    ArrowUpRight
} from "lucide-react";
import { motion, AnimatePresence, useDragControls } from "framer-motion";
import { arrowsAtom, canvaElementsAtom } from "../../konvaAtoms";
import { toolbarConfig } from "./ToolBar.config";
import { Button } from "../../../../../components/ui/button";
import {
    Card,
    CardContent,
    CardHeader,
    CardTitle,
} from "../../../../../components/ui/card";
import {
    Collapsible,
    CollapsibleContent,
    CollapsibleTrigger,
} from "../../../../../components/ui/collapsible";
import { ScrollArea } from "../../../../../components/ui/scroll-area";
import ToolBarItem from "./ToolBarItem";
import {
    Tooltip,
    TooltipContent,
    TooltipProvider,
    TooltipTrigger,
} from "../../../../../components/ui/tooltip";
import { Separator } from "../../../../../components/ui/separator";
import { 
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "../../../../../components/ui/select";
import { Slider } from "../../../../../components/ui/slider";
import { Input } from "../../../../../components/ui/input";
import { Popover, PopoverContent, PopoverTrigger } from "../../../../../components/ui/popover";
import { CanvaElementSkeleton, CircleElement, SpecificCircleElement } from "../../../../../endPointTypes/types";
import { measureTextWidth } from "../../functions/measureTextWidth";

type ToolBarProps = {
    selectedItemsIds: string[];
};

export default function ToolBar({ selectedItemsIds }: ToolBarProps) {
    const [canvaElements, setCanvaElements] = useAtom(canvaElementsAtom);
    const [arrows, setArrows] = useAtom(arrowsAtom);
    const [openGroups, setOpenGroups] = useState<string[]>([]);
    const [minimized, setMinimized] = useState(false);
    const [position, setPosition] = useState({ x: 16, y: 16 });
    const dragControls = useDragControls();
    const cardRef = useRef<HTMLDivElement>(null);

    // Text formatting state
    const [fontFamily, setFontFamily] = useState("Inter");
    const [fontSize, setFontSize] = useState(16);
    const [isBold, setIsBold] = useState(false);
    const [isItalic, setIsItalic] = useState(false);
    const [isUnderlined, setIsUnderlined] = useState(false);
    const [textAlign, setTextAlign] = useState("left");
    const [textColor, setTextColor] = useState("#000000");
   let controlShape: any = canvaElements.find(
     (element) => element.id === selectedItemsIds[0]
   );
    // Track window dimensions to ensure the toolbar stays in bounds
    const [windowSize, setWindowSize] = useState({
        width: window.innerWidth,
        height: window.innerHeight
    });

    // Add a resize listener
    useEffect(() => {
        const handleResize = () => {
            setWindowSize({
                width: window.innerWidth,
                height: window.innerHeight
            });
        };

        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    // Ensure the toolbar stays in bounds when window is resized
    useEffect(() => {
        if (cardRef.current) {
            const cardWidth = cardRef.current.offsetWidth;
            const cardHeight = cardRef.current.offsetHeight;
            
            // Adjust position if needed to stay in bounds
            let newX = position.x;
            let newY = position.y;
            
            if (newX + cardWidth > windowSize.width) {
                newX = windowSize.width - cardWidth - 16;
            }
            
            if (newY + cardHeight > windowSize.height) {
                newY = windowSize.height - cardHeight - 16;
            }
            
            if (newX !== position.x || newY !== position.y) {
                setPosition({ x: newX, y: newY });
            }
        }
    }, [windowSize, position, minimized]);

    // Load text formatting settings from selected element
    useEffect(() => {
        if (controlShape && controlShape.type === 'text') {
            // Get properties from the main element
            setTextColor(controlShape.fill || '#000000');
            
            // Get properties from the textElement if it exists
            if (controlShape.textElement) {
                setFontFamily(controlShape.textElement.fontFamily || 'Inter');
                setFontSize(controlShape.textElement.fontSize || 16);
                setIsItalic(controlShape.textElement.fontStyle === "italic");
                setIsUnderlined(controlShape.textElement.textDecoration === "underline");
            }
        }
    }, [selectedItemsIds, controlShape]);

    // Add radius state for circles
    const [radius, setRadius] = useState(50);
    const [hachureGap, setHachureGap] = useState(5);
    const [hachureAngle, setHachureAngle] = useState(45);
    const [roughness, setRoughness] = useState(1);
    const [fillStyle, setFillStyle] = useState("solid");
    
    // Load circle properties when a circle is selected
    useEffect(() => {
        if (controlShape && controlShape.type === 'circle' && controlShape.circleElement) {
            // Set circle specific properties
            setRadius(controlShape.circleElement.radius || 50);
            setHachureGap(controlShape.circleElement.hachureGap || 5);
            setHachureAngle(controlShape.circleElement.hachureAngle || 45);
            setRoughness(controlShape.circleElement.roughness || 1);
            setFillStyle(controlShape.circleElement.fillStyle || "solid");
            
            // Set common properties
            setTextColor(controlShape.fill || '#000000');
        }
    }, [selectedItemsIds, controlShape]);

    // Add rectangle state variables (similar to circle state variables)
    const [rectColor, setRectColor] = useState("#000000");

    // Add useEffect to load rectangle properties
    useEffect(() => {
        if (controlShape && controlShape.type === 'rect' && controlShape.rectElement) {
            // Set rectangle specific properties
            setRoughness(controlShape.rectElement.roughness || 1);
            setFillStyle(controlShape.rectElement.fillStyle || "solid");
            setHachureGap(controlShape.rectElement.hachureGap || 5);
            setHachureAngle(controlShape.rectElement.hachureAngle || 45);
            
            // Set common properties
            setRectColor(controlShape.fill || '#000000');
        }
    }, [selectedItemsIds, controlShape]);

    // Add arrow state variables
    const [arrowStrokeWidth, setArrowStrokeWidth] = useState(2);
    const [arrowStrokeStyle, setArrowStrokeStyle] = useState("solid");
    const [arrowRoughness, setArrowRoughness] = useState(1);
    const [arrowColor, setArrowColor] = useState("#000000");
    const [arrowFillStyle, setArrowFillStyle] = useState("solid");
    const [arrowStartType, setArrowStartType] = useState("none");
    const [arrowEndType, setArrowEndType] = useState("arrow");

    // Add useEffect to load arrow properties
    useEffect(() => {
        if (controlShape && controlShape.type === 'arrow') {
            // Set arrow specific properties
            setArrowStrokeWidth(controlShape.strokeWidth || 2);
            setArrowStrokeStyle(controlShape.strokeStyle || "solid");
            setArrowRoughness(controlShape.roughness || 1);
            setArrowColor(controlShape.stroke || '#000000');
            setArrowFillStyle(controlShape.fillStyle || "solid");
            
            // Set arrow endpoint types if they exist
            if (controlShape.arrowElement) {
                setArrowStartType(controlShape.arrowElement.startType || "none");
                setArrowEndType(controlShape.arrowElement.endType || "arrow");
            }
        }
    }, [selectedItemsIds, controlShape]);

    const updateItems = (property: { [key: string]: any }) => {
        setCanvaElements((elements) =>
            elements.map((element) =>
                selectedItemsIds.includes(element.id)
                    ? { ...element, ...property }
                    : element
            )
        );
        setArrows((elements) =>
            elements.map((element) =>
                selectedItemsIds.includes(element.id)
                    ? { ...element, ...property }
                    : element
            )
        );
    };

    // Text formatting handlers
    const updateTextFormat = (property: { [key: string]: any }) => {
        if (controlShape.type === 'text') {
            // Handle properties that go directly on the CanvaElementSkeleton
            const canvasProps: { [key: string]: any } = {};
            // Handle properties that go in the textElement
            const textProps: { [key: string]: any } = {};
            
            Object.entries(property).forEach(([key, value]) => {
                // Properties that should be on the main canvas element
                if (['fill', 'opacity', 'rotation', 'x', 'y', 'width', 'height'].includes(key)) {
                    canvasProps[key] = value;
                } 
                // Properties that belong in the textElement
                else if (['fontFamily', 'fontSize', 'text', 'fontWeight', 'fontStyle', 'textDecoration'].includes(key)) {
                    textProps[key] = value;
                }
            });
            
            // Update the main canvas element
            if (Object.keys(canvasProps).length > 0) {
                setCanvaElements((elements) =>
                    elements.map((element) =>
                        selectedItemsIds.includes(element.id)
                            ? { ...element, ...canvasProps }
                            : element
                    )
                );
            }
            
            // Update the textElement property
            if (Object.keys(textProps).length > 0) {
                // First update the textElement properties
                setCanvaElements((elements) =>
                    elements.map((element) => {
                        if (selectedItemsIds.includes(element.id) && element.type === 'text') {
                            return {
                                ...element,
                                textElement: {
                                    ...element.textElement,
                                    ...textProps
                                }
                            } as CanvaElementSkeleton;
                        }
                        return element;
                    })
                );
                
                // Then recalculate dimensions for each selected text element
                selectedItemsIds.forEach(id => {
                    const element = canvaElements.find(el => el.id === id);
                    if (element && element.type === 'text') {
                        // Calculate new dimensions based on text content and font properties
                        const text = element.textElement.text || '';
                        const fontSize = textProps.fontSize || element.textElement.fontSize;
                        const fontFamily = textProps.fontFamily || element.textElement.fontFamily;
                        
                        // Calculate new width based on text content
                        const textWidth = measureTextWidth(text, fontSize, fontFamily);
                        const newWidth = Math.max(textWidth + 20, 60);
                        const newHeight = Math.max(fontSize * 1.5, 30);
                        
                        // Update element dimensions
                        setCanvaElements((elements) =>
                            elements.map((el) => {
                                if (el.id === id) {
                                    return {
                                        ...el,
                                        width: newWidth,
                                        height: newHeight,
                                        points: [
                                            { x: el.x, y: el.y },
                                            { x: el.x + newWidth, y: el.y },
                                            { x: el.x + newWidth, y: el.y + newHeight },
                                            { x: el.x, y: el.y + newHeight }
                                        ]
                                    };
                                }
                                return el;
                            })
                        );
                    }
                });
            }
        } else {
            // For non-text elements, just update the main properties
            updateItems(property);
        }
    };

    const toggleBold = () => {
        const newValue = !isBold;
        setIsBold(newValue);
        updateTextFormat({ fontWeight: newValue ? 'bold' : 'normal' });
    };

    const toggleItalic = () => {
        const newValue = !isItalic;
        setIsItalic(newValue);
        updateTextFormat({ fontStyle: newValue ? 'italic' : 'normal' });
    };

    const toggleUnderline = () => {
        const newValue = !isUnderlined;
        setIsUnderlined(newValue);
        updateTextFormat({ textDecoration: newValue ? 'underline' : 'none' });
    };

    const handleFontFamilyChange = (value: string) => {
        setFontFamily(value);
        updateTextFormat({ fontFamily: value });
    };

    const handleFontSizeChange = (value: number[]) => {
        const newSize = value[0];
        setFontSize(newSize);
        updateTextFormat({ fontSize: newSize });
    };


    const handleTextColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const newColor = e.target.value;
        setTextColor(newColor);
        updateTextFormat({ fill: newColor });
    };

    // Update circle properties
    const updateCircleFormat = (property: { [key: string]: any }) => {
        if (controlShape.type === 'circle') {
            // Handle properties that go directly on the CanvaElementSkeleton
            const canvasProps: { [key: string]: any } = {};
            // Handle properties that go in the circleElement
            const circleProps: { [key: string]: any } = {};
            
            Object.entries(property).forEach(([key, value]) => {
                // Properties that should be on the main canvas element
                if (['fill', 'opacity', 'rotation', 'x', 'y', 'width', 'height', 'strokeWidth', 'stroke'].includes(key)) {
                    canvasProps[key] = value;
                } 
                // Properties that belong in the circleElement
                else if (['radius', 'fillStyle', 'roughness', 'seed', 'hachureGap', 'hachureAngle'].includes(key)) {
                    circleProps[key] = value;
                }
            });
            
            // Update the main canvas element
            if (Object.keys(canvasProps).length > 0) {
                setCanvaElements((elements) =>
                    elements.map((element) =>
                        selectedItemsIds.includes(element.id)
                            ? { ...element, ...canvasProps }
                            : element
                    )
                );
            }
            
            // Update the circleElement property
            if (Object.keys(circleProps).length > 0) {
                setCanvaElements((elements) =>
                    elements.map((element) => {
                        if (selectedItemsIds.includes(element.id) && element.type === 'circle') {
                            return {
                                ...element,
                                circleElement: {
                                    ...element.circleElement,
                                    ...circleProps
                                }
                            } as CanvaElementSkeleton;
                        }
                        return element;
                    })
                );
            }
        } else {
            // For non-circle elements, just update the main properties
            updateItems(property);
        }
    };
    
    // Handle radius change for circles
    const handleRadiusChange = (value: number[]) => {
        const newRadius = value[0];
        setRadius(newRadius);
        updateCircleFormat({ radius: newRadius });
    };
    
    // Handle hachure gap change for circles
    const handleHachureGapChange = (value: number[]) => {
        const newGap = value[0];
        setHachureGap(newGap);
        updateCircleFormat({ hachureGap: newGap });
    };
    
    // Handle hachure angle change for circles
    const handleHachureAngleChange = (value: number[]) => {
        const newAngle = value[0];
        setHachureAngle(newAngle);
        updateCircleFormat({ hachureAngle: newAngle });
    };
    
    // Handle roughness change for circles
    const handleRoughnessChange = (value: number[]) => {
        const newRoughness = value[0];
        setRoughness(newRoughness);
        updateCircleFormat({ roughness: newRoughness });
    };
    
    // Handle fill style change for circles
    const handleFillStyleChange = (value: string) => {
        setFillStyle(value);
        updateCircleFormat({ fillStyle: value });
    };
    
    // Handle circle color change
    const handleCircleColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const newColor = e.target.value;
        setTextColor(newColor);
        updateCircleFormat({ fill: newColor });
    };

    // Add function to update rectangle properties
    const updateRectFormat = (property: { [key: string]: any }) => {
        if (controlShape.type === 'rect') {
            // Handle properties that go directly on the CanvaElementSkeleton
            const canvasProps: { [key: string]: any } = {};
            // Handle properties that go in the rectElement
            const rectProps: { [key: string]: any } = {};
            
            Object.entries(property).forEach(([key, value]) => {
                // Properties that should be on the main canvas element
                if (['fill', 'opacity', 'rotation', 'x', 'y', 'width', 'height', 'strokeWidth', 'strokeColor'].includes(key)) {
                    canvasProps[key] = value;
                } 
                // Properties that belong in the rectElement
                else if (['fillStyle', 'roughness', 'seed', 'hachureGap', 'hachureAngle'].includes(key)) {
                    rectProps[key] = value;
                }
            });
            
            // Update the main canvas element
            if (Object.keys(canvasProps).length > 0) {
                setCanvaElements((elements) =>
                    elements.map((element) =>
                        selectedItemsIds.includes(element.id)
                            ? { ...element, ...canvasProps }
                            : element
                    )
                );
            }
            
            // Update the rectElement property
            if (Object.keys(rectProps).length > 0) {
                setCanvaElements((elements) =>
                    elements.map((element) => {
                        if (selectedItemsIds.includes(element.id) && element.type === 'rect') {
                            return {
                                ...element,
                                rectElement: {
                                    ...element.rectElement,
                                    ...rectProps
                                }
                            } as CanvaElementSkeleton;
                        }
                        return element;
                    })
                );
            }
        } else {
            // For non-rectangle elements, just update the main properties
            updateItems(property);
        }
    };

    // Add handler functions for rectangle properties
    const handleRectFillStyleChange = (value: string) => {
        setFillStyle(value);
        updateRectFormat({ fillStyle: value });
    };

    const handleRectRoughnessChange = (value: number[]) => {
        const newRoughness = value[0];
        setRoughness(newRoughness);
        updateRectFormat({ roughness: newRoughness });
    };

    const handleRectHachureGapChange = (value: number[]) => {
        const newGap = value[0];
        setHachureGap(newGap);
        updateRectFormat({ hachureGap: newGap });
    };

    const handleRectHachureAngleChange = (value: number[]) => {
        const newAngle = value[0];
        setHachureAngle(newAngle);
        updateRectFormat({ hachureAngle: newAngle });
    };

    const handleRectColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const newColor = e.target.value;
        setRectColor(newColor);
        updateRectFormat({ fill: newColor });
    };

    // Add function to update arrow properties
    const updateArrowFormat = (property: { [key: string]: any }) => {
        if (controlShape.type === 'arrow') {
            // Handle properties that go directly on the CurveElementSkeleton
            const curveProps: { [key: string]: any } = {};
            // Handle properties that go in the arrowElement
            const arrowProps: { [key: string]: any } = {};
            
            Object.entries(property).forEach(([key, value]) => {
                // Properties that should be on the main curve element
                if (['stroke', 'strokeWidth', 'strokeStyle', 'roughness', 'fill', 'fillStyle', 'hachureGap', 'hachureAngle'].includes(key)) {
                    curveProps[key] = value;
                } 
                // Properties that belong in the arrowElement
                else if (['startType', 'endType'].includes(key)) {
                    arrowProps[key] = value;
                }
            });
            
            // Update the main curve element
            if (Object.keys(curveProps).length > 0) {
                setArrows((elements) =>
                    elements.map((element) =>
                        selectedItemsIds.includes(element.id)
                            ? { ...element, ...curveProps }
                            : element
                    )
                );
            }
            
            // Update the arrowElement property
            if (Object.keys(arrowProps).length > 0) {
                setArrows((elements) =>
                    elements.map((element) => {
                        if (selectedItemsIds.includes(element.id) && element.type === 'arrow') {
                            return {
                                ...element,
                                arrowElement: {
                                    ...element.arrowElement,
                                    ...arrowProps
                                }
                            };
                        }
                        return element;
                    })
                );
            }
        }
    };

    // Add handler functions for arrow properties
    const handleArrowStrokeWidthChange = (value: number[]) => {
        const newWidth = value[0];
        setArrowStrokeWidth(newWidth);
        updateArrowFormat({ strokeWidth: newWidth });
    };

    const handleArrowStrokeStyleChange = (value: string) => {
        setArrowStrokeStyle(value);
        updateArrowFormat({ strokeStyle: value });
    };

    const handleArrowRoughnessChange = (value: number[]) => {
        const newRoughness = value[0];
        setArrowRoughness(newRoughness);
        updateArrowFormat({ roughness: newRoughness });
    };

    const handleArrowColorChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        const newColor = e.target.value;
        setArrowColor(newColor);
        updateArrowFormat({ stroke: newColor });
    };


    const handleArrowEndTypeChange = (value: string) => {
        setArrowEndType(value);
        updateArrowFormat({ endType: value });
    };

    if (!controlShape)
        controlShape = arrows.find(
            (element) => element.id === selectedItemsIds[0]
        );

    if (!selectedItemsIds.length || !controlShape) {
        return null;
    }

    const controls = toolbarConfig[controlShape.type] || [];
    const isTextElement = controlShape.type === 'text';
    const isCircleElement = controlShape.type === 'circle';
    const isRectElement = controlShape.type === 'rect';
    const isArrowElement = controlShape.type === 'arrow';

    const toggleGroup = (groupName: string) => {
        setOpenGroups((prev) =>
            prev.includes(groupName)
                ? prev.filter((g) => g !== groupName)
                : [...prev, groupName]
        );
    };

    const deleteSelectedItems = () => {
        setCanvaElements((elements) =>
            elements.filter((element) => !selectedItemsIds.includes(element.id))
        );
        setArrows((elements) =>
            elements.filter((element) => !selectedItemsIds.includes(element.id))
        );
    };

    const handleDragStart = (event: React.PointerEvent<HTMLDivElement>) => {
        dragControls.start(event);
    };

    // Get proper element type display name
    const getElementTypeDisplayName = () => {
        if (controlShape.type === 'text') return 'Text';
        if (controlShape.type === 'image') return 'Image';
        if (controlShape.type === 'shape') return 'Shape';
        if (controlShape.type === 'arrow') return 'Arrow';
        return controlShape.type.charAt(0).toUpperCase() + controlShape.type.slice(1);
    };

    return (
        <motion.div
            className="absolute z-50"
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ 
                opacity: 1, 
                scale: 1,
                x: position.x,
                y: position.y
            }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            drag
            dragControls={dragControls}
            dragListener={false}
            dragMomentum={false}
            dragConstraints={{
                left: 0,
                right: windowSize.width - (cardRef.current?.offsetWidth || 300),
                top: 0,
                bottom: windowSize.height - (cardRef.current?.offsetHeight || 400)
            }}
            onDragEnd={(_, info) => {
                setPosition((prev) => ({
                    x: prev.x + info.offset.x,
                    y: prev.y + info.offset.y
                }));
            }}
        >
            <Card 
                ref={cardRef}
                className="w-72 bg-card/95 text-card-foreground backdrop-blur-sm shadow-lg border-primary/20"
                style={{ display: "flex", flexDirection: "column" }}
            >
                <CardHeader 
                    className="p-3 flex flex-row items-center justify-between space-y-0 border-b cursor-move flex-shrink-0"
                    onPointerDown={handleDragStart}
                >
                    <div className="flex items-center gap-2">
                        <GripVertical className="h-4 w-4 text-muted-foreground" />
                        <CardTitle className="text-sm font-medium">
                            {minimized ? `Element: ${getElementTypeDisplayName()}` : 'Element Properties'}
                        </CardTitle>
                    </div>
                    <div className="flex items-center gap-1">
                        <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6"
                            onClick={() => setMinimized(!minimized)}
                        >
                            {minimized ? <ChevronDown className="h-3 w-3" /> : <ChevronUp className="h-3 w-3" />}
                        </Button>
                        <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6 hover:bg-destructive/10 hover:text-destructive"
                            onClick={() => deleteSelectedItems()}
                        >
                            <X className="h-3 w-3" />
                        </Button>
                    </div>
                </CardHeader>
                
                <AnimatePresence>
                    {!minimized && (
                        <motion.div
                            initial={{ height: 0, opacity: 0 }}
                            animate={{ height: 'auto', opacity: 1 }}
                            exit={{ height: 0, opacity: 0 }}
                            transition={{ duration: 0.2 }}
                            className="overflow-hidden"
                        >
                            <CardContent className="p-0">
                                <ScrollArea className="h-64" type="always">
                                    <div className="p-3 space-y-2">
                                        {/* Circle formatting tools */}
                                        {isCircleElement && (
                                            <Collapsible
                                                open={openGroups.includes("Circle Properties")}
                                                onOpenChange={() => toggleGroup("Circle Properties")}
                                                className="mb-1"
                                            >
                                                <CollapsibleTrigger asChild>
                                                    <Button
                                                        variant="ghost"
                                                        className="w-full justify-between py-2 px-3 text-sm h-8 bg-muted/50 hover:bg-muted"
                                                    >
                                                        <div className="flex items-center">
                                                            <Circle className="h-4 w-4 mr-2" />
                                                            Circle Properties
                                                        </div>
                                                        <motion.div
                                                            animate={{ rotate: openGroups.includes("Circle Properties") ? 180 : 0 }}
                                                            transition={{ duration: 0.2 }}
                                                        >
                                                            <ChevronDown className="h-4 w-4" />
                                                        </motion.div>
                                                    </Button>
                                                </CollapsibleTrigger>
                                                <CollapsibleContent className="py-2 px-3 space-y-3 border-l-2 border-muted ml-2 mt-1">
                                                    {/* Radius */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Radius</label>
                                                            <span className="text-xs font-medium">{radius}px</span>
                                                        </div>
                                                        <Slider 
                                                            value={[radius]} 
                                                            min={5} 
                                                            max={200} 
                                                            step={1} 
                                                            onValueChange={handleRadiusChange} 
                                                        />
                                                    </div>
                                                    
                                                    {/* Fill Style */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Fill Style</label>
                                                        <Select value={fillStyle} onValueChange={handleFillStyleChange}>
                                                            <SelectTrigger className="w-full h-8 text-xs">
                                                                <SelectValue placeholder="Select Fill Style" />
                                                            </SelectTrigger>
                                                            <SelectContent>
                                                                <SelectItem value="solid">Solid</SelectItem>
                                                                <SelectItem value="hachure">Hachure</SelectItem>
                                                                <SelectItem value="cross-hatch">Cross-Hatch</SelectItem>
                                                                <SelectItem value="zigzag">Zigzag</SelectItem>
                                                                <SelectItem value="dots">Dots</SelectItem>
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                    
                                                    {/* Roughness */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Roughness</label>
                                                            <span className="text-xs font-medium">{roughness}</span>
                                                        </div>
                                                        <Slider 
                                                            value={[roughness]} 
                                                            min={0} 
                                                            max={3} 
                                                            step={0.1} 
                                                            onValueChange={handleRoughnessChange} 
                                                        />
                                                    </div>
                                                    
                                                    {fillStyle !== 'solid' && (
                                                        <>
                                                            {/* Hachure Gap */}
                                                            <div className="space-y-1">
                                                                <div className="flex justify-between">
                                                                    <label className="text-xs text-muted-foreground">Hachure Gap</label>
                                                                    <span className="text-xs font-medium">{hachureGap}px</span>
                                                                </div>
                                                                <Slider 
                                                                    value={[hachureGap]} 
                                                                    min={1} 
                                                                    max={20} 
                                                                    step={1} 
                                                                    onValueChange={handleHachureGapChange} 
                                                                />
                                                            </div>
                                                            
                                                            {/* Hachure Angle */}
                                                            <div className="space-y-1">
                                                                <div className="flex justify-between">
                                                                    <label className="text-xs text-muted-foreground">Hachure Angle</label>
                                                                    <span className="text-xs font-medium">{hachureAngle}°</span>
                                                                </div>
                                                                <Slider 
                                                                    value={[hachureAngle]} 
                                                                    min={0} 
                                                                    max={180} 
                                                                    step={5} 
                                                                    onValueChange={handleHachureAngleChange} 
                                                                />
                                                            </div>
                                                        </>
                                                    )}
                                                    
                                                    {/* Fill Color */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Fill Color</label>
                                                        <div className="flex items-center space-x-2">
                                                            <Popover>
                                                                <PopoverTrigger asChild>
                                                                    <Button 
                                                                        variant="outline" 
                                                                        size="sm" 
                                                                        className="h-8 flex items-center gap-2"
                                                                    >
                                                                        <div 
                                                                            className="w-4 h-4 rounded-sm border border-gray-300" 
                                                                            style={{ backgroundColor: textColor }}
                                                                        />
                                                                        <Palette className="h-4 w-4" />
                                                                        {textColor}
                                                                    </Button>
                                                                </PopoverTrigger>
                                                                <PopoverContent className="w-auto p-3">
                                                                    <div className="flex flex-col gap-2">
                                                                        <div className="grid grid-cols-5 gap-1">
                                                                            {["#000000", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", 
                                                                                "#FF00FF", "#00FFFF", "#FFA500", "#800080", "#008000",
                                                                                "#800000", "#008080", "#000080", "#FFC0CB", "#A52A2A",
                                                                                "#808080", "#C0C0C0", "#FFD700", "#4B0082", "#FFFFFF"
                                                                            ].map(color => (
                                                                                <div 
                                                                                    key={color}
                                                                                    className="w-6 h-6 rounded-sm border border-gray-300 cursor-pointer hover:scale-110 transition-transform"
                                                                                    style={{ backgroundColor: color }}
                                                                                    onClick={() => {
                                                                                        setTextColor(color);
                                                                                        updateCircleFormat({ fill: color });
                                                                                    }}
                                                                                />
                                                                            ))}
                                                                        </div>
                                                                        <div className="flex items-center mt-2">
                                                                            <label className="text-xs mr-2">Custom:</label>
                                                                            <Input
                                                                                type="color"
                                                                                value={textColor}
                                                                                onChange={handleCircleColorChange}
                                                                                className="w-8 h-8 p-0 border-0"
                                                                            />
                                                                            <Input 
                                                                                type="text" 
                                                                                value={textColor}
                                                                                onChange={(e) => {
                                                                                    const value = e.target.value;
                                                                                    if (/^#[0-9A-Fa-f]{0,6}$/.test(value)) {
                                                                                        setTextColor(value);
                                                                                        if (value.length === 7) {
                                                                                            updateCircleFormat({ fill: value });
                                                                                        }
                                                                                    }
                                                                                }}
                                                                                className="w-24 h-8 ml-2 text-xs"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </PopoverContent>
                                                            </Popover>
                                                        </div>
                                                    </div>
                                                </CollapsibleContent>
                                            </Collapsible>
                                        )}
                                        
                                        {/* Show text formatting tools if it's a text element */}
                                        {isTextElement && (
                                            <Collapsible
                                                open={openGroups.includes("Text Formatting")}
                                                onOpenChange={() => toggleGroup("Text Formatting")}
                                                className="mb-1"
                                            >
                                                <CollapsibleTrigger asChild>
                                                    <Button
                                                        variant="ghost"
                                                        className="w-full justify-between py-2 px-3 text-sm h-8 bg-muted/50 hover:bg-muted"
                                                    >
                                                        <div className="flex items-center">
                                                            <Type className="h-4 w-4 mr-2" />
                                                            Text Formatting
                                                        </div>
                                                        <motion.div
                                                            animate={{ rotate: openGroups.includes("Text Formatting") ? 180 : 0 }}
                                                            transition={{ duration: 0.2 }}
                                                        >
                                                            <ChevronDown className="h-4 w-4" />
                                                        </motion.div>
                                                    </Button>
                                                </CollapsibleTrigger>
                                                <CollapsibleContent className="py-2 px-3 space-y-3 border-l-2 border-muted ml-2 mt-1">
                                                    {/* Font Family */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Font Family</label>
                                                        <Select value={fontFamily} onValueChange={handleFontFamilyChange}>
                                                            <SelectTrigger className="w-full h-8 text-xs">
                                                                <SelectValue placeholder="Select Font" />
                                                            </SelectTrigger>
                                                            <SelectContent>
                                                                <SelectItem value="Inter">Inter</SelectItem>
                                                                <SelectItem value="Arial">Arial</SelectItem>
                                                                <SelectItem value="Times New Roman">Times New Roman</SelectItem>
                                                                <SelectItem value="Georgia">Georgia</SelectItem>
                                                                <SelectItem value="Courier New">Courier New</SelectItem>
                                                                <SelectItem value="Verdana">Verdana</SelectItem>
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                    
                                                    {/* Font Size */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Font Size</label>
                                                            <span className="text-xs font-medium">{fontSize}px</span>
                                                        </div>
                                                        <Slider 
                                                            value={[fontSize]} 
                                                            min={8} 
                                                            max={72} 
                                                            step={1} 
                                                            onValueChange={handleFontSizeChange} 
                                                        />
                                                    </div>
                                                    
                                                    {/* Text Style */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Text Style</label>
                                                        <div className="flex space-x-1">
                                                           
                                                            <TooltipProvider>
                                                                <Tooltip>
                                                                    <TooltipTrigger asChild>
                                                                        <Button 
                                                                            variant={isItalic ? "default" : "outline"} 
                                                                            size="icon" 
                                                                            className="h-8 w-8" 
                                                                            onClick={toggleItalic}
                                                                        >
                                                                            <Italic className="h-4 w-4" />
                                                                        </Button>
                                                                    </TooltipTrigger>
                                                                    <TooltipContent>
                                                                        <p>Italic</p>
                                                                    </TooltipContent>
                                                                </Tooltip>
                                                            </TooltipProvider>
                                                            
                                                            <TooltipProvider>
                                                                <Tooltip>
                                                                    <TooltipTrigger asChild>
                                                                        <Button 
                                                                            variant={isUnderlined ? "default" : "outline"} 
                                                                            size="icon" 
                                                                            className="h-8 w-8" 
                                                                            onClick={toggleUnderline}
                                                                        >
                                                                            <Underline className="h-4 w-4" />
                                                                        </Button>
                                                                    </TooltipTrigger>
                                                                    <TooltipContent>
                                                                        <p>Underline</p>
                                                                    </TooltipContent>
                                                                </Tooltip>
                                                            </TooltipProvider>
                                                        </div>
                                                    </div>
                                                    
                                                   
                                                    
                                                    {/* Text Color */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Text Color</label>
                                                        <div className="flex items-center space-x-2">
                                                            <Popover>
                                                                <PopoverTrigger asChild>
                                                                    <Button 
                                                                        variant="outline" 
                                                                        size="sm" 
                                                                        className="h-8 flex items-center gap-2"
                                                                    >
                                                                        <div 
                                                                            className="w-4 h-4 rounded-sm border border-gray-300" 
                                                                            style={{ backgroundColor: textColor }}
                                                                        />
                                                                        <Palette className="h-4 w-4" />
                                                                        {textColor}
                                                                    </Button>
                                                                </PopoverTrigger>
                                                                <PopoverContent className="w-auto p-3">
                                                                    <div className="flex flex-col gap-2">
                                                                        <div className="grid grid-cols-5 gap-1">
                                                                            {["#000000", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", 
                                                                              "#FF00FF", "#00FFFF", "#FFA500", "#800080", "#008000",
                                                                              "#800000", "#008080", "#000080", "#FFC0CB", "#A52A2A",
                                                                              "#808080", "#C0C0C0", "#FFD700", "#4B0082", "#FFFFFF"
                                                                            ].map(color => (
                                                                                <div 
                                                                                    key={color}
                                                                                    className="w-6 h-6 rounded-sm border border-gray-300 cursor-pointer hover:scale-110 transition-transform"
                                                                                    style={{ backgroundColor: color }}
                                                                                    onClick={() => {
                                                                                        setTextColor(color);
                                                                                        updateTextFormat({ fill: color });
                                                                                    }}
                                                                                />
                                                                            ))}
                                                                        </div>
                                                                        <div className="flex items-center mt-2">
                                                                            <label className="text-xs mr-2">Custom:</label>
                                                                            <Input
                                                                                type="color"
                                                                                value={textColor}
                                                                                onChange={handleTextColorChange}
                                                                                className="w-8 h-8 p-0 border-0"
                                                                            />
                                                                            <Input 
                                                                                type="text" 
                                                                                value={textColor}
                                                                                onChange={(e) => {
                                                                                    const value = e.target.value;
                                                                                    if (/^#[0-9A-Fa-f]{0,6}$/.test(value)) {
                                                                                        setTextColor(value);
                                                                                        if (value.length === 7) {
                                                                                            updateTextFormat({ fill: value });
                                                                                        }
                                                                                    }
                                                                                }}
                                                                                className="w-24 h-8 ml-2 text-xs"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </PopoverContent>
                                                            </Popover>
                                                        </div>
                                                    </div>
                                                </CollapsibleContent>
                                            </Collapsible>
                                        )}
                                        
                                        {/* Rectangle formatting tools */}
                                        {isRectElement && (
                                            <Collapsible
                                                open={openGroups.includes("Rectangle Properties")}
                                                onOpenChange={() => toggleGroup("Rectangle Properties")}
                                                className="mb-1"
                                            >
                                                <CollapsibleTrigger asChild>
                                                    <Button
                                                        variant="ghost"
                                                        className="w-full justify-between py-2 px-3 text-sm h-8 bg-muted/50 hover:bg-muted"
                                                    >
                                                        <div className="flex items-center">
                                                            <Square className="h-4 w-4 mr-2" />
                                                            Rectangle Properties
                                                        </div>
                                                        <motion.div
                                                            animate={{ rotate: openGroups.includes("Rectangle Properties") ? 180 : 0 }}
                                                            transition={{ duration: 0.2 }}
                                                        >
                                                            <ChevronDown className="h-4 w-4" />
                                                        </motion.div>
                                                    </Button>
                                                </CollapsibleTrigger>
                                                <CollapsibleContent className="py-2 px-3 space-y-3 border-l-2 border-muted ml-2 mt-1">
                                                    {/* Roughness */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Roughness</label>
                                                            <span className="text-xs font-medium">{roughness}</span>
                                                        </div>
                                                        <Slider 
                                                            value={[roughness]} 
                                                            min={0} 
                                                            max={3} 
                                                            step={0.1} 
                                                            onValueChange={handleRectRoughnessChange} 
                                                        />
                                                    </div>
                                                    
                                                    {/* Fill Style */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Fill Style</label>
                                                        <Select value={fillStyle} onValueChange={handleRectFillStyleChange}>
                                                            <SelectTrigger className="w-full h-8 text-xs">
                                                                <SelectValue placeholder="Select Fill Style" />
                                                            </SelectTrigger>
                                                            <SelectContent>
                                                                <SelectItem value="solid">Solid</SelectItem>
                                                                <SelectItem value="hachure">Hachure</SelectItem>
                                                                <SelectItem value="cross-hatch">Cross-Hatch</SelectItem>
                                                                <SelectItem value="zigzag">Zigzag</SelectItem>
                                                                <SelectItem value="dots">Dots</SelectItem>
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                    
                                                    {fillStyle !== 'solid' && (
                                                        <>
                                                            {/* Hachure Gap */}
                                                            <div className="space-y-1">
                                                                <div className="flex justify-between">
                                                                    <label className="text-xs text-muted-foreground">Hachure Gap</label>
                                                                    <span className="text-xs font-medium">{hachureGap}px</span>
                                                                </div>
                                                                <Slider 
                                                                    value={[hachureGap]} 
                                                                    min={1} 
                                                                    max={20} 
                                                                    step={1} 
                                                                    onValueChange={handleRectHachureGapChange} 
                                                                />
                                                            </div>
                                                            
                                                            {/* Hachure Angle */}
                                                            <div className="space-y-1">
                                                                <div className="flex justify-between">
                                                                    <label className="text-xs text-muted-foreground">Hachure Angle</label>
                                                                    <span className="text-xs font-medium">{hachureAngle}°</span>
                                                                </div>
                                                                <Slider 
                                                                    value={[hachureAngle]} 
                                                                    min={0} 
                                                                    max={180} 
                                                                    step={5} 
                                                                    onValueChange={handleRectHachureAngleChange} 
                                                                />
                                                            </div>
                                                        </>
                                                    )}
                                                    
                                                    {/* Fill Color */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Fill Color</label>
                                                        <div className="flex items-center space-x-2">
                                                            <Popover>
                                                                <PopoverTrigger asChild>
                                                                    <Button 
                                                                        variant="outline" 
                                                                        size="sm" 
                                                                        className="h-8 flex items-center gap-2"
                                                                    >
                                                                        <div 
                                                                            className="w-4 h-4 rounded-sm border border-gray-300" 
                                                                            style={{ backgroundColor: rectColor }}
                                                                        />
                                                                        <Palette className="h-4 w-4" />
                                                                        {rectColor}
                                                                    </Button>
                                                                </PopoverTrigger>
                                                                <PopoverContent className="w-auto p-3">
                                                                    <div className="flex flex-col gap-2">
                                                                        <div className="grid grid-cols-5 gap-1">
                                                                            {["#000000", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", 
                                                                                "#FF00FF", "#00FFFF", "#FFA500", "#800080", "#008000",
                                                                                "#800000", "#008080", "#000080", "#FFC0CB", "#A52A2A",
                                                                                "#808080", "#C0C0C0", "#FFD700", "#4B0082", "#FFFFFF"
                                                                            ].map(color => (
                                                                                <div 
                                                                                    key={color}
                                                                                    className="w-6 h-6 rounded-sm border border-gray-300 cursor-pointer hover:scale-110 transition-transform"
                                                                                    style={{ backgroundColor: color }}
                                                                                    onClick={() => {
                                                                                        setRectColor(color);
                                                                                        updateRectFormat({ fill: color });
                                                                                    }}
                                                                                />
                                                                            ))}
                                                                        </div>
                                                                        <div className="flex items-center mt-2">
                                                                            <label className="text-xs mr-2">Custom:</label>
                                                                            <Input
                                                                                type="color"
                                                                                value={rectColor}
                                                                                onChange={handleRectColorChange}
                                                                                className="w-8 h-8 p-0 border-0"
                                                                            />
                                                                            <Input 
                                                                                type="text" 
                                                                                value={rectColor}
                                                                                onChange={(e) => {
                                                                                    const value = e.target.value;
                                                                                    if (/^#[0-9A-Fa-f]{0,6}$/.test(value)) {
                                                                                        setRectColor(value);
                                                                                        if (value.length === 7) {
                                                                                            updateRectFormat({ fill: value });
                                                                                        }
                                                                                    }
                                                                                }}
                                                                                className="w-24 h-8 ml-2 text-xs"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </PopoverContent>
                                                            </Popover>
                                                        </div>
                                                    </div>
                                                </CollapsibleContent>
                                            </Collapsible>
                                        )}
                                        
                                        {/* Arrow formatting tools */}
                                        {isArrowElement && (
                                            <Collapsible
                                                open={openGroups.includes("Arrow Properties")}
                                                onOpenChange={() => toggleGroup("Arrow Properties")}
                                                className="mb-1"
                                            >
                                                <CollapsibleTrigger asChild>
                                                    <Button
                                                        variant="ghost"
                                                        className="w-full justify-between py-2 px-3 text-sm h-8 bg-muted/50 hover:bg-muted"
                                                    >
                                                        <div className="flex items-center">
                                                            <ArrowUpRight className="h-4 w-4 mr-2" />
                                                            Arrow Properties
                                                        </div>
                                                        <motion.div
                                                            animate={{ rotate: openGroups.includes("Arrow Properties") ? 180 : 0 }}
                                                            transition={{ duration: 0.2 }}
                                                        >
                                                            <ChevronDown className="h-4 w-4" />
                                                        </motion.div>
                                                    </Button>
                                                </CollapsibleTrigger>
                                                <CollapsibleContent className="py-2 px-3 space-y-3 border-l-2 border-muted ml-2 mt-1">
                                                    {/* Stroke Width */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Stroke Width</label>
                                                            <span className="text-xs font-medium">{arrowStrokeWidth}px</span>
                                                        </div>
                                                        <Slider 
                                                            value={[arrowStrokeWidth]} 
                                                            min={1} 
                                                            max={10} 
                                                            step={1} 
                                                            onValueChange={handleArrowStrokeWidthChange} 
                                                        />
                                                    </div>
                                                    
                                                    {/* Stroke Style */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Stroke Style</label>
                                                        <Select value={arrowStrokeStyle} onValueChange={handleArrowStrokeStyleChange}>
                                                            <SelectTrigger className="w-full h-8 text-xs">
                                                                <SelectValue placeholder="Select Stroke Style" />
                                                            </SelectTrigger>
                                                            <SelectContent>
                                                                <SelectItem value="solid">Solid</SelectItem>
                                                                <SelectItem value="dashed">Dashed</SelectItem>
                                                                <SelectItem value="dotted">Dotted</SelectItem>
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                    
                                                    {/* Roughness */}
                                                    <div className="space-y-1">
                                                        <div className="flex justify-between">
                                                            <label className="text-xs text-muted-foreground">Roughness</label>
                                                            <span className="text-xs font-medium">{arrowRoughness}</span>
                                                        </div>
                                                        <Slider 
                                                            value={[arrowRoughness]} 
                                                            min={0} 
                                                            max={3} 
                                                            step={0.1} 
                                                            onValueChange={handleArrowRoughnessChange} 
                                                        />
                                                    </div>
                                                    
                                                  
                                                    
                                                    {/* Arrow End Type */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">End Type</label>
                                                        <Select value={arrowEndType} onValueChange={handleArrowEndTypeChange}>
                                                            <SelectTrigger className="w-full h-8 text-xs">
                                                                <SelectValue placeholder="Select End Type" />
                                                            </SelectTrigger>
                                                            <SelectContent>
                                                                <SelectItem value="none">None</SelectItem>
                                                                <SelectItem value="arrow">Arrow</SelectItem>
                                                                <SelectItem value="circle">Circle</SelectItem>
                                                                <SelectItem value="square">Square</SelectItem>
                                                            </SelectContent>
                                                        </Select>
                                                    </div>
                                                    
                                                    {/* Arrow Color */}
                                                    <div className="space-y-1">
                                                        <label className="text-xs text-muted-foreground">Arrow Color</label>
                                                        <div className="flex items-center space-x-2">
                                                            <Popover>
                                                                <PopoverTrigger asChild>
                                                                    <Button 
                                                                        variant="outline" 
                                                                        size="sm" 
                                                                        className="h-8 flex items-center gap-2"
                                                                    >
                                                                        <div 
                                                                            className="w-4 h-4 rounded-sm border border-gray-300" 
                                                                            style={{ backgroundColor: arrowColor }}
                                                                        />
                                                                        <Palette className="h-4 w-4" />
                                                                        {arrowColor}
                                                                    </Button>
                                                                </PopoverTrigger>
                                                                <PopoverContent className="w-auto p-3">
                                                                    <div className="flex flex-col gap-2">
                                                                        <div className="grid grid-cols-5 gap-1">
                                                                            {["#000000", "#FF0000", "#00FF00", "#0000FF", "#FFFF00", 
                                                                                "#FF00FF", "#00FFFF", "#FFA500", "#800080", "#008000",
                                                                                "#800000", "#008080", "#000080", "#FFC0CB", "#A52A2A",
                                                                                "#808080", "#C0C0C0", "#FFD700", "#4B0082", "#FFFFFF"
                                                                            ].map(color => (
                                                                                <div 
                                                                                    key={color}
                                                                                    className="w-6 h-6 rounded-sm border border-gray-300 cursor-pointer hover:scale-110 transition-transform"
                                                                                    style={{ backgroundColor: color }}
                                                                                    onClick={() => {
                                                                                        setArrowColor(color);
                                                                                        updateArrowFormat({ stroke: color });
                                                                                    }}
                                                                                />
                                                                            ))}
                                                                        </div>
                                                                        <div className="flex items-center mt-2">
                                                                            <label className="text-xs mr-2">Custom:</label>
                                                                            <Input
                                                                                type="color"
                                                                                value={arrowColor}
                                                                                onChange={handleArrowColorChange}
                                                                                className="w-8 h-8 p-0 border-0"
                                                                            />
                                                                            <Input 
                                                                                type="text" 
                                                                                value={arrowColor}
                                                                                onChange={(e) => {
                                                                                    const value = e.target.value;
                                                                                    if (/^#[0-9A-Fa-f]{0,6}$/.test(value)) {
                                                                                        setArrowColor(value);
                                                                                        if (value.length === 7) {
                                                                                            updateArrowFormat({ stroke: value });
                                                                                        }
                                                                                    }
                                                                                }}
                                                                                className="w-24 h-8 ml-2 text-xs"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                </PopoverContent>
                                                            </Popover>
                                                        </div>
                                                    </div>
                                               
                                                </CollapsibleContent>
                                            </Collapsible>
                                        )}
                                        
                                     
                                    </div>
                                </ScrollArea>
                                <div className="p-3 border-t">
                                    <Button
                                        variant="destructive"
                                        size="sm"
                                        className="w-full text-sm"
                                        onClick={deleteSelectedItems}
                                    >
                                        <Trash2 className="mr-2 h-4 w-4" />
                                        Delete Element
                                    </Button>
                                </div>
                            </CardContent>
                        </motion.div>
                    )}
                </AnimatePresence>
            </Card>
        </motion.div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-23-modules-bookpage-konva-modules-toolbar-toolbaritem-tsx">File 23: Modules/BookPage/Konva/modules/ToolBar/ToolBarItem.tsx</h2>

```typescript
import { motion } from "framer-motion";
import { Input } from "../../../../../components/ui/input";
import { Label } from "../../../../../components/ui/label";
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "../../../../../components/ui/select";
import ColorPicker from "./ColorPicker";
import SliderControl from "./SliderControl";
import { Popover, PopoverContent, PopoverTrigger } from "../../../../../components/ui/popover";
import { Check, ChevronDown } from "lucide-react";

type ToolBarItemProps = {
    controlItem: string | number;
    updateItems: (property: { [key: string]: any }) => void;
    controlType: "color" | "number" | "text" | "select";
    options?: string[];
    property: string;
    label: string;
};

const ToolBarItem = ({
    controlItem,
    updateItems,
    controlType,
    options = [],
    property,
    label,
}: ToolBarItemProps) => {
    const handleChange = (value: any) => {
        updateItems({ [property]: value });
    };

    const predefinedColors = [
        "#000000",
        "#ffffff",
        "#e03131",
        "#2f9e44",
        "#1971c2",
        "#f08c00",
        "#ffc9c9",
        "#b2f2bb",
        "#a5d8ff",
        "#ffec99",
    ];

    return (
        <div className="space-y-1.5">
            <Label htmlFor={property} className="text-xs font-medium">{label}</Label>
            
            {controlType === "color" && (
                <Popover>
                    <PopoverTrigger asChild>
                        <button
                            className="flex h-8 w-full items-center justify-between rounded-md border border-input bg-transparent px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
                        >
                            <div className="flex items-center gap-2">
                                <div 
                                    className="h-4 w-4 rounded-full" 
                                    style={{ backgroundColor: controlItem as string }}
                                />
                                <span>{controlItem as string}</span>
                            </div>
                            <ChevronDown className="h-4 w-4 opacity-50" />
                        </button>
                    </PopoverTrigger>
                    <PopoverContent className="w-auto p-3" align="start">
                        <ColorPicker
                            selectedColor={controlItem as string}
                            onChange={handleChange}
                            colors={predefinedColors}
                        />
                    </PopoverContent>
                </Popover>
            )}
            
            {controlType === "number" && (
                <div className="flex flex-col gap-1">
                    <SliderControl
                        id={property}
                        min={0}
                        max={10}
                        step={0.1}
                        value={controlItem as number}
                        onChange={handleChange}
                    />
                    <div className="flex justify-between items-center">
                        <span className="text-xs text-muted-foreground">0</span>
                        <Input
                            id={`${property}-input`}
                            type="number"
                            value={controlItem as number}
                            onChange={(e) => handleChange(parseFloat(e.target.value))}
                            className="h-7 w-16 text-xs"
                        />
                        <span className="text-xs text-muted-foreground">10</span>
                    </div>
                </div>
            )}
            
            {controlType === "text" && (
                <Input
                    id={property}
                    type="text"
                    value={controlItem as string}
                    onChange={(e) => handleChange(e.target.value)}
                    className="h-8"
                />
            )}
            
            {controlType === "select" && (
                <Select
                    value={controlItem as string}
                    onValueChange={handleChange}
                >
                    <SelectTrigger id={property} className="h-8">
                        <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                        {options.map((option) => (
                            <SelectItem 
                                key={option} 
                                value={option}
                                className="flex items-center gap-2"
                            >
                                <span className="text-sm">
                                    {option.charAt(0).toUpperCase() + option.slice(1)}
                                </span>
                                {option === controlItem && <Check className="h-3.5 w-3.5 ml-auto" />}
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            )}
        </div>
    );
};

export default ToolBarItem;

```

<div style='page-break-after: always;'></div>

<h2 id="file-24-modules-bookpage-konva-shapes-arrow-arrowshape-tsx">File 24: Modules/BookPage/Konva/shapes/Arrow/ArrowShape.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { KonvaEventObject } from "konva/lib/Node";
import { Vector2d } from "konva/lib/types";
import { ForwardedRef, forwardRef, useEffect, useImperativeHandle } from "react";
import { Circle } from "react-konva";
import { v4 as uuidv4 } from "uuid";

import {
    CanvaElementSkeleton,
    Point,
    ProcessedElement,
    SpecificArrowElement,
    StartType,
} from "../../../../../endPointTypes/types";
import { getArrowHighlightsUnderMouse, getHighlightUnderMouse } from "../../functions/getElementsUnderMouse";
import { getPos } from "../../functions/getPos";
import {
    activeToolAtom,
    ArrowHover,
    arrowsAtom,
    bookIdAtom,
    canvaElementsAtom,
    hoveredItemsAtom,
    highlightsAtom,
    newArrowAtom,
    offsetPositionAtom,
    scaleAtom,
    selectedArrowIdsAtom,
    highlightElementsAtom,
} from "../../konvaAtoms";
import createArrow from "./CreateArrow";
import RenderArrow from "./RenderArrow";

type ArrowShapeProps = {
    // Define your prop types here
};

export type ArrowShapeRef = {
     handleMouseDown(e: KonvaEventObject<MouseEvent>): void;
    handleMouseMove(e: KonvaEventObject<MouseEvent>): void;
    handleMouseUp(e: KonvaEventObject<MouseEvent>): void;
    handleElementAttachedToArrowMove(selectedTextId: string[]): void;
    handleArrowSelect(e: KonvaEventObject<MouseEvent>): void;
    handleSelectedArrowMove(id: string, newPoints: Point[]): void;
};

function ArrowShape({}: ArrowShapeProps, ref: ForwardedRef<ArrowShapeRef>) {
    const [activeTool] = useAtom(activeToolAtom);
    const [newArrow, setNewArrow] = useAtom(newArrowAtom);
    const [arrows, setArrows] = useAtom(arrowsAtom);
    const [hoveredItems, setHoveredItems] = useAtom(hoveredItemsAtom);
    const [highlightElements] = useAtom(highlightElementsAtom);
    const [canvasElements] = useAtom(canvaElementsAtom);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [scale] = useAtom(scaleAtom); // State to handle scale
    const [bookId] = useAtom(bookIdAtom);
    const size = 20;
    const [selectedArrowIds, setSelectedArrowIds] =
        useAtom(selectedArrowIdsAtom);
    useEffect(() => {
        console.log("naujas cia arrows", arrows);
    }, [arrows]);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleElementAttachedToArrowMove,
        handleArrowSelect,
        handleSelectedArrowMove,
    }));
    const calculateClosestPointOnShape = (
        element: CanvaElementSkeleton,
        arrowPointX: number,
        arrowPointY: number
    ) => {
        if (!element.points) return { x: 0, y: 0 };
        let minDistance = Infinity;
        let minPoints = element.points[0];
        element.points.forEach((point) => {
            if (distance(point, { x: arrowPointX, y: arrowPointY }) < minDistance) {
                minDistance = distance(point, { x: arrowPointX, y: arrowPointY });
                minPoints = point;
                console.log("minPoints", minPoints);
            }
        });
        return minPoints;
    };
    // Utility function to calculate the distance between two points
    const distance = (point1: Point, point2: Point) => {
        return Math.sqrt(
            (point1.x - point2.x) ** 2 + (point1.y - point2.y) ** 2
        );
    };
    const handleElementAttachedToArrowMove = (selectedTextId: string[]) => {
        console.log("selectedTextId", selectedTextId);
        console.log("canvasElements", canvasElements);
        console.log("arrows", arrows);
        setArrows((arrows) => {
            const elementsSelected = canvasElements.filter((element) =>
                selectedTextId.includes(element.id)
            );

            const updatingArrows = arrows.filter((arrow) =>
                elementsSelected.some(
                    (element) =>
                        element.id === arrow.arrowElement.startId ||
                        element.id === arrow.arrowElement.endId
                )
            );

            const otherArrows = arrows.filter(
                (arrow) => !updatingArrows.includes(arrow)
            );

            const updatedArrows = updatingArrows.map((arrow) => {
                let updatedPoints = [...arrow.points]; // Clone the points array

                // Find the position of the element for the startId and endId
                const startElement = canvasElements.find(
                    (el) => el.id === arrow.arrowElement.startId
                );
                const endElement = canvasElements.find(
                    (el) => el.id === arrow.arrowElement.endId
                );

                // Update the start position based on the start element's points
                if (startElement && selectedTextId.includes(startElement.id)) {
                    const startPoint = calculateClosestPointOnShape(
                        startElement,
                        arrow.points[0].x,
                        arrow.points[0].y
                    );
                    console.log("Start Point:", startPoint); // Debugging start point
                    updatedPoints[0] = startPoint;
                }
                if (endElement && selectedTextId.includes(endElement.id)) {
                    const endPoint = calculateClosestPointOnShape(
                        endElement,
                        arrow.points[1].x,
                        arrow.points[1].y
                    );
                    console.log("endElement:", endElement); // Debugging end point
                    console.log("End Point:", endPoint); // Debugging end point
                    updatedPoints[1] = endPoint;
                }

                return {
                    ...arrow,
                    points: updatedPoints,
                };
            });

            return [...otherArrows, ...updatedArrows];
        });
    };
    // Add a helper function to extract text content based on element type
    const getElementText = (element: CanvaElementSkeleton | undefined): string => {
        console.log("element", element)
        if (!element) return "Unknown";
        console.log("element.type", element.type)
        // Text element content is in the textElement.text property
        if (element.type === 'text' && element.textElement) {
            return element.textElement.text || "Text Element";
        }
        
        // For book text highlights, we need to get the text from the content
        if (element.type === 'bookText' && element.content) {
            return element.content || "Book Text";
        }
        
        // For shapes, we can use a default description or any associated label
        if (element.type === 'rect') {
            console.log("rect", element)
            return "Rectangle Shape";
        }
        
        if (element.type === 'circle') {
            return "Circle Shape";
        }
        console.log("element.type", element.type)
        
        // Fall back to a descriptive string based on type
        return `${element.type || "Unknown"} Element`;
    };
    useEffect(() => {
      console.log("Hovered items", hoveredItems);
    }, [hoveredItems]);
    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        console.log("Mouse down");
        if (!bookId) return;
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;
        const id = uuidv4();

        console.log("Mouse down at position:", pos);
        const hoveredItemsNew: ArrowHover | null = hoverItems(pos);
        console.log("hoveredItemsNew", hoveredItemsNew);
        const hoveredItemsNewArray: ArrowHover[] = hoveredItemsNew ? [hoveredItemsNew] : [];
        const highlightsCanvasUnderMouse = getArrowHighlightsUnderMouse(
          hoveredItemsNewArray,
          pos
        );
        const highlightHoversUnderMouse = getHighlightUnderMouse(
          highlightElements,
          pos
        );
        console.log("highlightHoversUnderMouse", highlightHoversUnderMouse);
        const highlightsUnderMouse = [...highlightHoversUnderMouse, ...highlightsCanvasUnderMouse];
        let startId: string | undefined = undefined;
        let type: StartType = undefined;
        console.log("highlightsUnderMouse", highlightsUnderMouse);
        if (highlightsUnderMouse.length > 0) {
            startId = highlightsUnderMouse[0].id;
            if (!highlightsUnderMouse[0].type) {
                type = "text";
            } else {
                type = highlightsUnderMouse[0].type;
            }
        }
        const arrow = createArrow({
            points: [
                { x: pos.x, y: pos.y },
                { x: pos.x, y: pos.y },
            ],
            bookId: bookId,
            startId,
            startType: type,
            id,
        });
        console.log("Created new arrow:", arrow);
        setNewArrow(arrow);
    };
    const handleMouseUp = (e: KonvaEventObject<MouseEvent>) => {
        if (!newArrow) {
            console.log("No new arrow to complete");
            return;
        }
        const pos = getPos(offsetPosition, scale, e);
        console.log("Mouse up at position:", pos);

        if (!pos) return;
        let arrow = {...newArrow}; // Create copy to avoid direct mutation
        const highlightsCanvasUnderMouse = getArrowHighlightsUnderMouse(
            hoveredItems,
            pos
        );
        const highlightHoversUnderMouse = getHighlightUnderMouse(
          highlightElements,
          pos
        );
        const highlightsUnderMouse = [
          ...highlightHoversUnderMouse,
          ...highlightsCanvasUnderMouse,
        ];

        
        // Get the end element if there's one under the mouse
        if (
            highlightsUnderMouse.length > 0 &&
            highlightsUnderMouse[0].id !== arrow.arrowElement.startId
        ) {
            arrow.arrowElement.endId = highlightsUnderMouse[0].id;
            if (highlightsUnderMouse[0].type) {
                arrow.arrowElement.endType = highlightsUnderMouse[0].type;
            } else {
                arrow.arrowElement.endType = "unknown";
            }
            
            // Find the start and end elements to extract their text content
            const startElement = canvasElements.find(
                (element) => element.id === arrow.arrowElement.startId
            );
            
            const endElement = canvasElements.find(
                (element) => element.id === arrow.arrowElement.endId
            );
            const startText = getElementText(startElement);
            const endText = getElementText(endElement);
            console.log("newFrom here startElement", startElement)
            console.log("newFrom here endElement", endElement)
            console.log("newFrom here startText", startText)
            console.log("newFrom here endText", endText)
            // Add text content to the arrow
            arrow.arrowElement.startElement = startElement;
            arrow.arrowElement.endElement = endElement;
        }

        console.log("Saving final arrow:", arrow);
        setArrows((prevArrows) => [...prevArrows, arrow]);
        setNewArrow(null);
    };
    const hoverItems = (pos: Vector2d) => {
        const highlightsUnderMouse = canvasElements.filter(
            (textItem) =>
                pos.x >= textItem.x - size &&
                pos.x <= textItem.x + textItem.width + size &&
                pos.y >= textItem.y - size &&
                pos.y <= textItem.y + textItem.height + size
        );
        console.log("highlightsUnderMouse", highlightsUnderMouse);
        if (highlightsUnderMouse.length > 0) {
            const firstHighlight = highlightsUnderMouse[0];
            console.log("firstHighlight", firstHighlight);
            // Check if the first highlight under the mouse is already hovered
            const isAlreadyHovered = highlightsUnderMouse.some(
              (highlight) => highlight.id === firstHighlight.id
            );
            const updatedHighlight = {
                points: [
                    { x: firstHighlight.x - size, y: firstHighlight.y - size },
                    {
                        x: firstHighlight.x + firstHighlight.width + size,
                        y: firstHighlight.y - size,
                    },
                    {
                        x: firstHighlight.x + firstHighlight.width + size,
                        y: firstHighlight.y + firstHighlight.height + size,
                    },
                    {
                        x: firstHighlight.x - size,
                        y: firstHighlight.y + firstHighlight.height + size,
                    },
                ],
                id: firstHighlight.id,
                type: firstHighlight.type,
            };
            if (isAlreadyHovered) {
                // If it's already hovered, refresh its position in the hovered list
                setHoveredItems((prevHighlights) => [
                    ...prevHighlights.filter(
                        (highlight) => highlight.id !== firstHighlight.id
                    ),
                    updatedHighlight,
                ]);
            } else {
                // If it's a new highlight, update hoveredHighlight to the first highlight under the mouse
                setHoveredItems((prevHighlights) => [
                    ...prevHighlights,
                    updatedHighlight,
                ]);
            }
            return updatedHighlight;

        }
        return  null
    };
    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        if (activeTool !== "Arrow" && activeTool !== "Select") return;
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;
        hoverItems(pos);
        if (!newArrow) {
            return;
        }
        const updatedArrow: SpecificArrowElement = {
            ...newArrow,
            points: [newArrow.points[0], { x: pos.x, y: pos.y }],
        };
        setNewArrow(updatedArrow);
    };

    const handleArrowSelect = (e: KonvaEventObject<MouseEvent>) => {
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;
        const arrowUnderMouse = arrows.filter(
            (arrow) =>
                pos.x >= Math.min(arrow.points[0].x, arrow.points[1].x) - size &&
                pos.x <= Math.max(arrow.points[0].x, arrow.points[1].x) + size &&
                pos.y >= Math.min(arrow.points[0].y, arrow.points[1].y) - size &&
                pos.y <= Math.max(arrow.points[0].y, arrow.points[1].y) + size
        );
        setSelectedArrowIds(arrowUnderMouse.map((arrow) => arrow.id));
    };
    const handleSelectedArrowMove = (id: string, newPoints: Point[]) => {
        setArrows((arrows) => {
            return arrows.map((arrow) => {
                if (arrow.id === id) {
                    return { ...arrow, points: newPoints };
                }
                return arrow;
            });
        });
    };
    const handleDragStartPoint = (
        arrowId: string,
        e: KonvaEventObject<MouseEvent>
    ) => {
        e.cancelBubble = false;
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;
        const foundArrow = arrows.find((arrow) => arrow.id === arrowId);
        if (!foundArrow) return;
        hoverItems(pos);
        handleSelectedArrowMove(arrowId, [
            { x: pos.x, y: pos.y },
            foundArrow.points[1],
        ]);
    };

    const handleDragEndPoint = (
        arrowId: string,
        e: KonvaEventObject<MouseEvent>
    ) => {
        e.cancelBubble = false;
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;
        const foundArrow = arrows.find((arrow) => arrow.id === arrowId);
        if (!foundArrow) return;
        hoverItems(pos);
        handleSelectedArrowMove(arrowId, [
            foundArrow.points[0],
            { x: pos.x, y: pos.y },
        ]);
    };

    const handleDragEnd = (
        arrowId: string,
        e: KonvaEventObject<MouseEvent>,
        which: "end" | "start"
    ) => {
        e.cancelBubble = false;
        const arrowToUpdate = arrows.find((arrow) => arrow.id === arrowId);
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;
        if (!arrowToUpdate) return;
        
        // Create a copy of the arrow for immutability
        const updatedArrow = { 
            ...arrowToUpdate,
            arrowElement: { ...arrowToUpdate.arrowElement }
        };
        
        const highlightsUnderMouse = hoveredItems.filter((highlight) => {
            if (highlight.rects) {
                return highlight.rects.some((rect) => {
                    return (
                        pos.x >= rect.x - size &&
                        pos.x <= rect.x + rect.width + size &&
                        pos.y >= rect.y - size &&
                        pos.y <= rect.y + rect.height + size
                    );
                });
            } else {
                return (
                    pos.x >= highlight.points[0].x - size &&
                    pos.x <= highlight.points[1].x + size &&
                    pos.y >= highlight.points[0].y - size &&
                    pos.y <= highlight.points[2].y + size
                );
            }
        });
        
        console.log("highlightsUnderMouse", highlightsUnderMouse, which);
        if (which === "start") {
            if (highlightsUnderMouse.length > 0) {
                updatedArrow.arrowElement.startId = highlightsUnderMouse[0].id;
                if (highlightsUnderMouse[0].type) {
                    updatedArrow.arrowElement.startType = highlightsUnderMouse[0].type;
                } else {
                    updatedArrow.arrowElement.startType = "unknown";
                }
                
                // Update the start text when the element changes
                const startElement = canvasElements.find(
                    (element) => element.id === updatedArrow.arrowElement.startId
                );
                updatedArrow.arrowElement.startText = getElementText(startElement);
            } else {
                updatedArrow.arrowElement.startId = undefined;
                updatedArrow.arrowElement.startType = undefined;
                updatedArrow.arrowElement.startText = "Unconnected";
            }
        }
        if (which === "end") {
            if (highlightsUnderMouse.length > 0) {
                updatedArrow.arrowElement.endId = highlightsUnderMouse[0].id;
                if (highlightsUnderMouse[0].type) {
                    updatedArrow.arrowElement.endType = highlightsUnderMouse[0].type;
                } else {
                    updatedArrow.arrowElement.endType = "unknown";
                }
                
                // Update the end text when the element changes
                const endElement = canvasElements.find(
                    (element) => element.id === updatedArrow.arrowElement.endId
                );
                updatedArrow.arrowElement.endText = getElementText(endElement);
            } else {
                updatedArrow.arrowElement.endId = undefined;
                updatedArrow.arrowElement.endType = undefined;
                updatedArrow.arrowElement.endText = "Unconnected";
            }
        }

        setArrows((prevArrows) => 
            prevArrows.map((prevArrow) => 
                prevArrow.id === arrowId ? updatedArrow : prevArrow
            )
        );
    };

    return (
        <>
            {arrows.map((arrow) => (
                <RenderArrow key={arrow.id} element={arrow} />
            ))}

            {selectedArrowIds.map((id) => {
                const selectedArrow = arrows.find((arrow) => arrow.id === id);
                if (!selectedArrow) return null;

                return (
                    <>
                        {/* Draggable Start Point - Circle */}
                        <Circle
                            key={`start-${id}`}
                            x={selectedArrow.points[0].x}
                            y={selectedArrow.points[0].y}
                            radius={8} // Adjust size to make it look like Excalidraw
                            fill="blue" // Color for the start point
                            stroke="white" // White stroke around the circle for better visibility
                            strokeWidth={2} // Thickness of the stroke
                            draggable
                            dragBoundFunc={() => {
                                return {
                                    x: selectedArrow.points[1].x,
                                    y: selectedArrow.points[1].y,
                                };
                            }}
                            onDragEnd={(e) => handleDragEnd(id, e, "start")}
                            onDragMove={(e) => handleDragStartPoint(id, e)}
                        />

                        {/* Draggable End Point - Circle */}
                        <Circle
                            key={`end-${id}`}
                            x={selectedArrow.points[1].x}
                            y={selectedArrow.points[1].y}
                            radius={8} // Adjust size to make it look like Excalidraw
                            fill="red" // Color for the end point
                            stroke="white" // White stroke around the circle for better visibility
                            strokeWidth={2} // Thickness of the stroke
                            draggable
                            dragBoundFunc={() => {
                                return {
                                    x: selectedArrow.points[0].x,
                                    y: selectedArrow.points[0].y,
                                };
                            }}
                            onDragEnd={(e) => handleDragEnd(id, e, "end")}
                            onDragMove={(e) => handleDragEndPoint(id, e)}
                        />
                    </>
                );
            })}

            {newArrow && newArrow.points && <RenderArrow element={newArrow} />}
        </>
    );
}

export default forwardRef(ArrowShape);

```

<div style='page-break-after: always;'></div>

<h2 id="file-25-modules-bookpage-konva-shapes-arrow-createarrow-tsx">File 25: Modules/BookPage/Konva/shapes/Arrow/CreateArrow.tsx</h2>

```typescript
// CreateArrow.ts
import { v4 as uuidv4 } from "uuid";
import {
    ArrowElement,
    Point,
    SpecificArrowElement,
} from "../../../../../endPointTypes/types";

type CreateArrowProps = {
    points: Point[]; // Array of points [x1, y1, x2, y2, ...]
    bookId: string;
} & Partial<Omit<SpecificArrowElement, "type" | "points">> &
    Partial<ArrowElement>;

export default function createArrow({
    points = [
        { x: 0, y: 0 },
        { x: 100, y: 100 },
    ],
    bookId,
    startId = undefined,
    endId = undefined,
    startType = undefined,
    endType = undefined,
    id = uuidv4(),
    fill = "black",
    text = undefined,
    roughness = 1,
    bowing = 0,
    seed = Math.floor(Math.random() * 100000),
    strokeWidth = 2,
    strokeStyle = "solid",
    stroke = "black",
    fillStyle = "solid",
    fillWeight = 1,
    hachureAngle = 45,
    hachureGap = 5,
    ...overrides
}: CreateArrowProps): SpecificArrowElement {
    return {
        type: "arrow",
        bookId,
        arrowElement: {
            type: "arrow",
            curveId: id,
            startId,
            endId,
            startType,
            endType,
        },
        points,
        id,
        fill,
        text,
        roughness,
        bowing,
        seed,
        strokeWidth,
        strokeStyle,
        stroke,
        fillStyle,
        fillWeight,
        hachureAngle,
        hachureGap,
        ...overrides,
    };
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-26-modules-bookpage-konva-shapes-arrow-customarrowstransformer-tsx">File 26: Modules/BookPage/Konva/shapes/Arrow/CustomArrowsTransformer.tsx</h2>

```typescript

```

<div style='page-break-after: always;'></div>

<h2 id="file-27-modules-bookpage-konva-shapes-arrow-renderarrow-tsx">File 27: Modules/BookPage/Konva/shapes/Arrow/RenderArrow.tsx</h2>

```typescript
// RenderArrow.tsx

import { Shape } from "react-konva";
import rough from "roughjs/bin/rough";
import { SpecificArrowElement } from "../../../../../endPointTypes/types";

// Define the component's props
type RenderArrowProps = {
    element: SpecificArrowElement;
};

// Helper function to draw arrowhead with styling
const drawArrowHead = (
    context: CanvasRenderingContext2D,
    relativeX2: number,
    relativeY2: number,
    angle: number,
    element: SpecificArrowElement
) => {
    const arrowLength = 10; // Length of the arrowhead lines
    const arrowAngle = Math.PI / 6; // 30 degrees

    // Calculate the two points for the arrowhead
    const arrowX1 = relativeX2 - arrowLength * Math.cos(angle - arrowAngle);
    const arrowY1 = relativeY2 - arrowLength * Math.sin(angle - arrowAngle);
    const arrowX2 = relativeX2 - arrowLength * Math.cos(angle + arrowAngle);
    const arrowY2 = relativeY2 - arrowLength * Math.sin(angle + arrowAngle);

    // Begin path for arrowhead
    context.beginPath();
    context.moveTo(relativeX2, relativeY2);
    context.lineTo(arrowX1, arrowY1);
    context.lineTo(arrowX2, arrowY2);
    context.closePath();

    // Set fill and stroke styles
    context.fillStyle = element.fill || "black";
    context.strokeStyle = element.stroke || "black";
    context.lineWidth = element.strokeWidth || 2;

    // Apply stroke style patterns if any
    switch (element.strokeStyle) {
        case "dashed":
            context.setLineDash([10, 5]);
            break;
        case "dotted":
            context.setLineDash([2, 3]);
            break;
        default:
            context.setLineDash([]);
    }

    // Fill and stroke the arrowhead
    context.fill();
    context.stroke();

    // Reset line dash
    context.setLineDash([]);
};

// RenderArrow Component
export default function RenderArrow({ element }: RenderArrowProps) {
    const points = element.points;

    // Ensure there are at least two points to form an arrow
    if (points.length < 2) {
        console.error("ArrowElement requires at least two points.");
        return null;
    }

    // Extract the first four points (x1, y1, x2, y2)
    const { x: x1, y: y1 } = points[0];
    const { x: x2, y: y2 } = points[1];

    // Calculate relative position for rendering within the Shape
    const relativeX2 = x2 - x1;
    const relativeY2 = y2 - y1;

    // Add a small console log to verify coordinates
    console.log("Drawing arrow from", x1, y1, "to", x2, y2, "with relative endpoint", relativeX2, relativeY2);

    return (
        <Shape
            key={element.id}
            id={element.id}
            x={x1}
            y={y1}
            sceneFunc={(context, shape) => {
                const canvas = context.canvas as unknown as HTMLCanvasElement;
                const roughCanvas = rough.canvas(canvas);

                // Draw the main line of the arrow with styling
                roughCanvas.line(0, 0, relativeX2, relativeY2, {
                    stroke: element.stroke || "white",
                    fill: element.stroke || "white",
                    strokeLineDash: element.strokeStyle === "dashed" ? [10, 5] : element.strokeStyle === "dotted" ? [2, 3] : [],
                    strokeWidth: element.strokeWidth || 2,
                    roughness: element.roughness || 1,
                    bowing: element.bowing || 1,
                    seed: element.seed,
                });

                // Calculate the angle of the line
                const angle = Math.atan2(relativeY2, relativeX2);

                // Draw the arrowhead with styling
                drawArrowHead(
                    context as unknown as CanvasRenderingContext2D,
                    relativeX2,
                    relativeY2,
                    angle,
                    element
                );

                // Finalize the shape
                context.fillStrokeShape(shape);
            }}
            // Optionally, you can add additional event handlers here
            // e.g., onClick, onMouseEnter, etc.
        />
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-28-modules-bookpage-konva-shapes-canvaelement-tsx">File 28: Modules/BookPage/Konva/shapes/CanvaElement.tsx</h2>

```typescript
import { useAtom } from "jotai";
import Konva from "konva";
import { KonvaEventObject } from "konva/lib/Node";
import {
    ForwardedRef,
    forwardRef,
    MutableRefObject,
    useImperativeHandle,
    useRef,
    useState,
} from "react";
import {
    isSpecificCircleElement,
    isSpecificRectElement,
    isSpecificTextElement,
} from "../../../../endPointTypes/typeGuards";
import { CanvaElementSkeleton, Point } from "../../../../endPointTypes/types";
import { getPos } from "../functions/getPos";
import {
    activeToolAtom,
    arrowsAtom,
    canvaElementsAtom,
    offsetPositionAtom,
    scaleAtom,
    selectedItemsIdsAtom,
} from "../konvaAtoms";
import { ArrowShapeRef } from "./Arrow/ArrowShape";
import Circle, { CircleRef } from "./Circle/Circle";
import CustomTransformer from "./CustomTransformer";
import Rectangle, { RectangleRef } from "./Rectangle/Rectangle";
import { renderCanvaElement } from "./RenderCanvaElement";
import TextElement, { TextElementRef } from "./Text/TextElement";

type CanvasElementProps = {
    arrowShapeRef: MutableRefObject<ArrowShapeRef | null>;
    inputRef: MutableRefObject<HTMLInputElement | null>;
};

export type CanvaElementRef = {
    handleMouseDown(e: KonvaEventObject<MouseEvent>): void;
    handleDoubleClick(e: KonvaEventObject<MouseEvent>): void;
    handleKeyDown(e: KeyboardEvent): void;
    handleInputChange:
        | ((e: React.ChangeEvent<HTMLInputElement>) => void)
        | undefined;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
};

function CanvasElement(
    { arrowShapeRef, inputRef }: CanvasElementProps,
    ref: ForwardedRef<CanvaElementRef>
) {
    const [canvaElements, setCanvaElements] = useAtom(canvaElementsAtom);
    const [selectedItemsIds, setSelectedItemsIds] =
        useAtom(selectedItemsIdsAtom);
    const [arrows] = useAtom(arrowsAtom);

    const [activeTool] = useAtom(activeToolAtom);
    const [, setIsEditing] = useState<boolean>(false);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [scale] = useAtom(scaleAtom); // State to handle scale
    const rectangleRef = useRef<RectangleRef | null>(null);
    const circleRef = useRef<CircleRef | null>(null);
    const textElementRef = useRef<TextElementRef | null>(null);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleDoubleClick,
        handleKeyDown,
        handleInputChange: textElementRef.current?.handleInputChange,
        handleMouseMove,
        handleMouseUp,
    }));

    const createElement = (element: CanvaElementSkeleton) => {
        setCanvaElements((prevItems) => [...prevItems, element]);
        setSelectedItemsIds([element.id]);
    };

    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        const stage = e.target.getStage();
        const transformer = stage?.findOne<Konva.Transformer>("Transformer");
        if (transformer) {
            const clickedOnTransformer =
                (e.target as unknown as Konva.Transformer) === transformer ||
                transformer?.children?.includes(e.target);
            if (clickedOnTransformer) {
                // Do not deselect if clicking on the transformer
                return;
            }
        }
        console.log("mouseDown", activeTool);
        // Check if the click is on the transformer or its children
        const pos = getPos(offsetPosition, scale, e);
        console.log("Mouse down at position:", pos, e);
        switch (activeTool) {
            case "Text":
                textElementRef.current?.handleMouseDown(e);
                break;
            case "Arrow":
                console.log("MouseDown onto Arrow", arrowShapeRef.current);
                arrowShapeRef.current?.handleMouseDown(e);
                break;
            case "Rectangle":
                rectangleRef.current?.handleMouseDown(e);
                break;
            case "Select":
                handleSelectToolMouseDown(e);
                break;
            case "Circle":
                circleRef.current?.handleMouseDown(e);
                break;
            default:
                setIsEditing(false);
                setSelectedItemsIds([]);
                break;
        }
    };

    const handleSelectToolMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        if (arrowShapeRef.current) {
            arrowShapeRef.current.handleArrowSelect(e);
        }
        const pos = getPos(offsetPosition, scale, e);

        if (!pos) return;

        const selectedItems = getItemsAtPosition(pos);
        setSelectedItemsIds(selectedItems.map((item) => item.id));

        //input blur
        if (inputRef.current) {
            inputRef.current.style.display = "none";
        }
    };

    const getItemsAtPosition = (pos: Point) => {
        console.log("canvaElemenets", canvaElements);
        const items = [
            ...canvaElements.filter((item) => {
                return (
                    pos.x >= item.x &&
                    pos.x <= item.x + item.width &&
                    pos.y >= item.y &&
                    pos.y <= item.y + item.height
                );
            }),
            ...arrows.filter((item) => {
                const { x: x1, y: y1 } = item.points[0];
                const { x: x2, y: y2 } = item.points[1];
                // Calculate the minimum and maximum x and y values
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);

                // Check if the position falls within the bounding box
                return (
                    pos.x >= minX &&
                    pos.x <= maxX &&
                    pos.y >= minY &&
                    pos.y <= maxY
                );
            }),
        ];
        console.log("getting items", items);
        return items;
    };

    const updateElement = (element: CanvaElementSkeleton) => {
        setCanvaElements((prevItems) => [
            ...prevItems.map((item) =>
                item.id === element.id ? element : item
            ),
        ]);
    };
    const deleteElement = (id: string) => {
        setCanvaElements((prevItems) =>
            prevItems.filter((item) => item.id !== id)
        );
        setSelectedItemsIds([]);
    };

    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        console.log("hi");
        rectangleRef.current?.handleMouseMove(e);
        circleRef.current?.handleMouseMove(e);
    };

    const handleMouseUp = () => {
        rectangleRef.current?.handleMouseUp();
        circleRef.current?.handleMouseUp();
        textElementRef.current?.handleMouseUp();
    };

    const handleDragMove = (e: KonvaEventObject<MouseEvent>) => {
        const node = e.target;
        const id = node.id();

        if (arrowShapeRef.current) {
            arrowShapeRef.current.handleElementAttachedToArrowMove(
                selectedItemsIds
            );
        }

        const element = canvaElements.find((el) => el.id === id);
        if (!element) return;

        let newAttrs: Partial<CanvaElementSkeleton> | undefined = {};

        if (isSpecificRectElement(element)) {
            newAttrs = rectangleRef.current?.handleDragMove(element, node);
        } else if (isSpecificCircleElement(element)) {
            newAttrs = circleRef.current?.handleDragMove(node);
        } else if (isSpecificTextElement(element)) {
            newAttrs = textElementRef.current?.handleDragMove(element, node);
        }
        if (!newAttrs) return;
        updateElementInState(id, newAttrs);
    };

    const handleDoubleClick = (e: KonvaEventObject<MouseEvent>) => {
        textElementRef.current?.handleDoubleClick(e);
    };

    const handleKeyDown = (e: KeyboardEvent) => {
        textElementRef.current?.handleKeyDown(e);
    };

    const updateElementInState = (
        id: string,
        newAttrs: Partial<CanvaElementSkeleton>
    ) => {
        setCanvaElements((elements) =>
            elements.map((el) => {
                if (el.id === id) {
                    return {
                        ...el,
                        ...newAttrs,
                        textElement: el.textElement
                            ? {
                                  ...el.textElement,
                                  ...newAttrs.textElement,
                              }
                            : undefined,
                        circleElement: el.circleElement
                            ? {
                                  ...el.circleElement,
                                  ...newAttrs.circleElement,
                                  fillStyle:
                                      newAttrs.circleElement?.fillStyle ??
                                      el.circleElement.fillStyle,
                              }
                            : undefined,
                        rectElement: el.rectElement
                            ? {
                                  ...el.rectElement,
                                  ...newAttrs.rectElement,
                              }
                            : undefined,
                        type: el.type, // Ensure the type remains the same
                    };
                }
                return el;
            })
        );
    };

    return (
        <>
            {canvaElements.map((element) =>
                renderCanvaElement(
                    element,
                    activeTool === "Select",
                    handleDragMove
                )
            )}
            <Rectangle
                createElement={createElement}
                updateElement={updateElement}
                ref={rectangleRef}
            />
            <Circle
                createElement={createElement}
                updateElement={updateElement}
                ref={circleRef}
            />
            <TextElement
                createElement={createElement}
                updateElement={updateElement}
                deleteElement={deleteElement}
                inputRef={inputRef}
                ref={textElementRef}
            />

            <CustomTransformer
                selectedIds={selectedItemsIds.filter(
                    (id) => !arrows.some((arrow) => arrow.id === id)
                )}
                updateElementInState={updateElementInState}
            />
        </>
    );
}

export default forwardRef(CanvasElement);

```

<div style='page-break-after: always;'></div>

<h2 id="file-29-modules-bookpage-konva-shapes-circle-circle-tsx">File 29: Modules/BookPage/Konva/shapes/Circle/Circle.tsx</h2>

```typescript
// src/components/CanvasElements/Circle/Circle.tsx

import { KonvaEventObject } from "konva/lib/Node";
import { v4 as uuidv4 } from "uuid";

import { useAtom } from "jotai";
import { Shape, ShapeConfig } from "konva/lib/Shape";
import { Stage } from "konva/lib/Stage";
import { ForwardedRef, forwardRef, useImperativeHandle, useState } from "react";
import {
    CanvaElementSkeleton,
    SpecificCircleElement,
} from "../../../../../endPointTypes/types";
import { getPos } from "../../functions/getPos";
import {
    activeToolAtom,
    bookIdAtom,
    offsetPositionAtom,
    scaleAtom,
} from "../../konvaAtoms";
import CreateCircle from "./createCircle";

type CircleProps = {
    createElement: (element: CanvaElementSkeleton) => void;
    updateElement: (element: CanvaElementSkeleton) => void;
};

export type CircleRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
    handleDragMove: (
        node: Shape<ShapeConfig> | Stage
    ) => Partial<CanvaElementSkeleton>;
};

function Circle(
    { createElement, updateElement }: CircleProps,
    ref: ForwardedRef<CircleRef>
) {
    const [activeTool] = useAtom(activeToolAtom);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [scale] = useAtom(scaleAtom);
    const [currentItem, setCurrentItem] =
        useState<SpecificCircleElement | null>(null);
    const [bookId] = useAtom(bookIdAtom);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleDragMove,
    }));

    const updateCircleElement = (
        element: SpecificCircleElement,
        pos: { x: number; y: number }
    ): SpecificCircleElement => {
        const { x: centerX, y: centerY } = element;
        const radius = Math.hypot(pos.x - centerX, pos.y - centerY);
        return {
            ...element,
            circleElement: {
                ...element.circleElement,
                radius,
            },
            height: radius * 2,
            width: radius * 2,
        };
    };

    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;
        if (!currentItem) return;
        const updatedCircle = updateCircleElement(currentItem, pos);
        updateElement(updatedCircle);
        console.log(updatedCircle);
    };

    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;
        if (!bookId) return;
        if (activeTool !== "Circle") return;
        const id = uuidv4();
        const newCircle = CreateCircle({
            x: pos.x,
            y: pos.y,
            bookId: bookId,
            id,
            radius: 0,
        });
        console.log("newCircle", newCircle);
        setCurrentItem(newCircle);
        createElement(newCircle);
    };

    const handleMouseUp = () => {
        setCurrentItem(null);
    };
    const handleDragMove = (
        node: Shape<ShapeConfig> | Stage
    ): Partial<SpecificCircleElement> => {
        const newAttrs = {
          x: node.x(),
          y: node.y(),
          points: [
            { x: node.x(), y: node.y() },
            { x: node.x() + node.attrs.width, y: node.y() },
            {
              x: node.x() + node.attrs.width,
              y: node.y() + node.attrs.height,
            },
            { x: node.x(), y: node.y() + node.attrs.height },
          ],
        };
        return newAttrs;
    };

    return null;
}

export default forwardRef(Circle);

```

<div style='page-break-after: always;'></div>

<h2 id="file-30-modules-bookpage-konva-shapes-circle-rendercircle-tsx">File 30: Modules/BookPage/Konva/shapes/Circle/RenderCircle.tsx</h2>

```typescript
// src/components/CanvasElements/Circle/RenderCircle.tsx

import { Shape } from "react-konva";
import { KonvaEventObject } from "konva/lib/Node";
import rough from "roughjs/bin/rough";
import { SpecificCircleElement } from "../../../../../endPointTypes/types";

type RenderCircleProps = {
    draggable: boolean;
    element: SpecificCircleElement;
    handleDragMove: ((e: KonvaEventObject<MouseEvent>) => void) | undefined;
};

export default function RenderCircle({
    draggable,
    element,
    handleDragMove,
}: RenderCircleProps) {
    return (
        <Shape
            key={element.id}
            id={element.id}
            x={element.x}
            y={element.y}
            width={element.width}
            height={element.height}
            opacity={element.opacity}
            draggable={draggable}
            attrs={{
                elementType: "circle",
                radius: element.circleElement.radius,
            }}
            onDragMove={handleDragMove}
            sceneFunc={(context) => {
                const canvas = context.canvas as unknown as HTMLCanvasElement;
                const roughCanvas = rough.canvas(canvas);
                context.save();
                // Move to the center of the bounding box
                context.translate(
                    element.circleElement.radius,
                    element.circleElement.radius
                );
                // Draw the circle at (0, 0) with the correct radius
                roughCanvas.circle(0, 0, element.circleElement.radius * 2, {
                    fill: element.fill,
                    stroke: element.strokeColor,
                    strokeWidth: element.strokeWidth,
                    roughness: element.circleElement.roughness,
                    fillStyle: element.circleElement.fillStyle,
                    hachureGap: element.circleElement.hachureGap,
                    hachureAngle: element.circleElement.hachureAngle,
                    seed: element.circleElement.seed,
                });
                context.restore();
                // No need to call fillStrokeShape here since rough.js handles the drawing
            }}
            hitFunc={(context, shape) => {
                context.beginPath();
                // Define the hit area at the center of the bounding box
                context.arc(
                    element.circleElement.radius,
                    element.circleElement.radius,
                    element.circleElement.radius,
                    0,
                    Math.PI * 2,
                    false
                );
                context.closePath();
                context.fillStrokeShape(shape);
            }}
        />
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-31-modules-bookpage-konva-shapes-circle-createcircle-tsx">File 31: Modules/BookPage/Konva/shapes/Circle/createCircle.tsx</h2>

```typescript
// src/components/CanvasElements/Circle/createCircle.ts

import { v4 as uuidv4 } from "uuid";
import {
    CircleElement,
    SpecificCircleElement,
} from "../../../../../endPointTypes/types";

type CreateCircleProps = {
    x: number;
    y: number;
    bookId: string;
} & Partial<Omit<SpecificCircleElement, "type" | "x" | "y">> &
    Partial<CircleElement>;

export default function CreateCircle({
    x,
    y,
    fill = "blue",
    radius = 10,
    id = uuidv4(),
    outgoingArrowIds = [],
    incomingArrowIds = [],
    strokeColor = "black",
    strokeWidth = 1,
    opacity = 1,
    points,
    roughness = 1,
    fillStyle = "hachure",
    hachureGap = 5,
    hachureAngle = 60,
    seed = Math.floor(Math.random() * 1000000),
    ...overrides
}: CreateCircleProps): SpecificCircleElement {
    return {
        type: "circle",
        fill,
        circleElement: {
            radius,
            canvaId: id,
            type: "circle",
            roughness,
            hachureGap,
            hachureAngle,
            seed,
            fillStyle,
        },
        width: radius * 2,
        height: radius * 2,
        id,
        x,
        y,
        outgoingArrowIds,
        incomingArrowIds,
        points: points || [{ x, y }],
        strokeColor,
        strokeWidth,
        opacity,
        rotation: 0,
        ...overrides,
    };
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-32-modules-bookpage-konva-shapes-customtransformer-tsx">File 32: Modules/BookPage/Konva/shapes/CustomTransformer.tsx</h2>

```typescript
import { useEffect, useRef } from "react";
import { Transformer } from "react-konva";
import Konva from "konva";
import { CanvaElementSkeleton } from "../../../../endPointTypes/types";

type CustomTransformerProps = {
    selectedIds: string[];
    updateElementInState: (
        id: string,
        newAttrs: Partial<CanvaElementSkeleton>
    ) => void;
};

export default function CustomTransformer({
    selectedIds,
    updateElementInState,
}: CustomTransformerProps) {
    const transformerRef = useRef<Konva.Transformer>(null);

    useEffect(() => {
        const transformer = transformerRef.current;
        if (!transformer) return;

        const stage = transformer.getStage();
        if (!stage) return;

        // Find the nodes corresponding to the selected IDs
        let selectedNodes = selectedIds
            .map((id) => stage.findOne<Konva.Node>(`#${id}`))
            .filter((node) => node !== null && node !== undefined);

        // Attach the transformer to the selected nodes
        transformer.nodes(selectedNodes);
        transformer.getLayer()?.batchDraw();

        // Optionally, customize the transformer for circles
        if (
            selectedNodes.length === 1 &&
            selectedNodes[0].getClassName() === "Shape"
        ) {
            const node = selectedNodes[0];
            const type = node.getAttr("elementType"); // Assuming you store the type in attrs

            if (type === "circle") {
                transformer.enabledAnchors([
                    "top-left",
                    "top-right",
                    "bottom-left",
                    "bottom-right",
                ]);
                transformer.setAttrs({
                    rotationEnabled: false,
                });
            } else {
                transformer.enabledAnchors([
                    "top-left",
                    "top-center",
                    "top-right",
                    "middle-right",
                    "bottom-right",
                    "bottom-center",
                    "bottom-left",
                    "middle-left",
                ]);
                transformer.setAttrs({
                    rotationEnabled: true,
                });
            }
        }
    }, [selectedIds]);

    // Handle transformations
    useEffect(() => {
        const transformer = transformerRef.current;
        if (!transformer) return;

        const handleTransformEnd = () => {
            const nodes = transformer.nodes();
            nodes.forEach((node) => {
                const id = node.id();
                const type = node.getAttr("elementType"); // Retrieve the custom type

                let newAttrs: Partial<CanvaElementSkeleton> = {};
                console.log("type", node);
                if (type === "rect") {
                    newAttrs = {
                        x: node.x(),
                        y: node.y(),
                        width: node.width() * node.scaleX(),
                        height: node.height() * node.scaleY(),
                    };
                    console.log("newAttrs", newAttrs);
                } else if (type === "text") {
                    // Get existing textElement properties
                    const existingTextElement = node.getAttr("textElement");

                    newAttrs = {
                        x: node.x(),
                        y: node.y(),
                        width: node.width() * node.scaleX(),
                        height: node.height() * node.scaleY(),
                        textElement: {
                            ...existingTextElement, // Retain existing properties
                            text: (node as Konva.Text).text(),
                            fontSize:
                                (node as Konva.Text).fontSize() * node.scaleY(), // Ensure fontSize is included
                        },
                    };
                } else if (type === "circle") {
                    const scaleX = node.scaleX();
                    const scaleY = node.scaleY();
                    const oldRadius = node.getAttr("radius");
                    const existingCircleElement = node.getAttr("circleElement");

                    const newRadius = (oldRadius * (scaleX + scaleY)) / 2;

                    newAttrs = {
                        circleElement: {
                            ...existingCircleElement, // Retain existing properties
                            radius: newRadius,
                        },
                        width: newRadius * 2,
                        height: newRadius * 2,
                        x: node.x(),
                        y: node.y(),
                    };

                    // Reset scale to avoid double-scaling
                    node.scaleX(1);
                    node.scaleY(1);
                }

                // Reset scale to avoid double-scaling
                node.scaleX(1);
                node.scaleY(1);

                // Update the element in the application state
                updateElementInState(id, newAttrs);
            });
        };

        // Attach the event handler
        transformer.on("transformend", handleTransformEnd);

        // Cleanup the event handler on unmount or when dependencies change
        return () => {
            transformer.off("transformend", handleTransformEnd);
        };
    }, [updateElementInState]);

    return <Transformer ref={transformerRef} />;
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-33-modules-bookpage-konva-shapes-rectangle-rectangle-tsx">File 33: Modules/BookPage/Konva/shapes/Rectangle/Rectangle.tsx</h2>

```typescript
import { KonvaEventObject } from "konva/lib/Node";
import { v4 as uuidv4 } from "uuid";

import {
    activeToolAtom,
    bookIdAtom,
    canvaElementsAtom,
    offsetPositionAtom,
    scaleAtom,
} from "../../konvaAtoms";
import { useAtom } from "jotai";
import CreateRectangle from "./createRectangle";
import { ForwardedRef, forwardRef, useImperativeHandle, useState } from "react";
import { getPos } from "../../functions/getPos";
import { Stage } from "konva/lib/Stage";
import { Shape, ShapeConfig } from "konva/lib/Shape";
import {
    CanvaElementSkeleton,
    SpecificRectElement,
} from "../../../../../endPointTypes/types";

type RectangleProps = {
    createElement: (element: CanvaElementSkeleton) => void;
    updateElement: (element: CanvaElementSkeleton) => void;
};
export type RectangleRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseMove: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
    handleDragMove: (
        element: SpecificRectElement,
        node: Shape<ShapeConfig> | Stage
    ) => Partial<SpecificRectElement>;
};

function Rectangle(
    { createElement, updateElement }: RectangleProps,
    ref: ForwardedRef<RectangleRef>
) {
    const [activeTool] = useAtom(activeToolAtom);
    const [canvaElements] = useAtom(canvaElementsAtom);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [scale] = useAtom(scaleAtom); // State to handle scale
    const [currentItem, setCurrentItem] = useState<SpecificRectElement | null>(
        null
    );
    const [bookId] = useAtom(bookIdAtom);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseMove,
        handleMouseUp,
        handleDragMove,
    }));

    const updateRectangleElement = (
        element: SpecificRectElement,
        pos: { x: number; y: number }
    ): SpecificRectElement => {
        const { x: startX, y: startY } = element;
        const newWidth = Math.abs(pos.x - startX);
        const newHeight = Math.abs(pos.y - startY);
        const newX = pos.x < startX ? pos.x : startX;
        const newY = pos.y < startY ? pos.y : startY;

        console.log(
            "newX, newY, newWidth, newHeight",
            newX,
            newY,
            newWidth,
            newHeight
        );
        return {
            ...element,
            x: newX,
            y: newY,
            width: newWidth,
            height: newHeight,
            points: [
                { x: newX, y: newY },
                { x: newX + newWidth, y: newY },
                { x: newX + newWidth, y: newY + newHeight },
                { x: newX, y: newY + newHeight },
            ],
        };
    };
    const handleMouseMove = (e: KonvaEventObject<MouseEvent>) => {
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;
        if (!currentItem) return;
        console.log(canvaElements);
        const updatedRectangele = updateRectangleElement(currentItem, pos);
        updateElement(updatedRectangele);
    };
    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        const pos = getPos(offsetPosition, scale, e);
        console.log("pos", pos);
        console.log("activeTool", activeTool);
        console.log("bookId", bookId);
        console.log("canvaElements", canvaElements);
        if (!bookId) return;
        if (!pos) return;
        if (activeTool !== "Rectangle") return;
        const id = uuidv4();
        const newRect = CreateRectangle({
            x: pos.x,
            y: pos.y,
            bookId: bookId,
            id,
            width: 0,
            height: 0,
        });
        console.log("newRect", newRect);
        setCurrentItem(newRect);
        createElement(newRect);
    };
    const handleMouseUp = () => {
        setCurrentItem(null);
    };
    const handleDragMove = (
        element: SpecificRectElement,
        node: Shape<ShapeConfig> | Stage
    ): Partial<SpecificRectElement> => {
        const newAttrs = {
            x: node.x(),
            y: node.y(),
            points: [
                { x: node.x(), y: node.y() },
                { x: node.x() + element.width, y: node.y() },
                {
                    x: node.x() + element.width,
                    y: node.y() + element.height,
                },
                { x: node.x(), y: node.y() + element.height },
            ],
        };
        return newAttrs;
    };

    return null;
}

export default forwardRef(Rectangle);

```

<div style='page-break-after: always;'></div>

<h2 id="file-34-modules-bookpage-konva-shapes-rectangle-renderrectangle-tsx">File 34: Modules/BookPage/Konva/shapes/Rectangle/RenderRectangle.tsx</h2>

```typescript
import { Shape } from "react-konva";
import { KonvaEventObject } from "konva/lib/Node";
import rough from "roughjs/bin/rough";
import { SpecificRectElement } from "../../../../../endPointTypes/types";

type RenderRectangleProps = {
    draggable: boolean;
    element: SpecificRectElement;
    handleDragMove: ((e: KonvaEventObject<MouseEvent>) => void) | undefined;
};

export default function RenderRectangle({
    draggable,
    element,
    handleDragMove,
}: RenderRectangleProps) {
    return (
        <Shape
            key={element.id}
            id={element.id}
            x={element.x}
            y={element.y}
            width={element.width}
            height={element.height}
            opacity={element.opacity}
            draggable={draggable}
            onDragMove={handleDragMove}
            attrs={{
                elementType: "rect",
                rectElement: element.rectElement,
            }}
            sceneFunc={(context, shape) => {
                // Explicitly cast context.canvas to HTMLCanvasElement
                const canvas = context.canvas as unknown as HTMLCanvasElement;

                // Create a Rough.js canvas wrapper
                const roughCanvas = rough.canvas(canvas);

                // Save the context state
                context.save();

                // Apply transformations
                context.rotate((shape.rotation() * Math.PI) / 180);

                // Draw the rough rectangle at (0, 0)
                roughCanvas.rectangle(0, 0, element.width, element.height, {
                    fill: element.fill,
                    stroke: element.strokeColor,
                    strokeWidth: element.strokeWidth,
                    roughness: element.rectElement.roughness,
                    fillStyle: element.rectElement.fillStyle,
                    hachureGap: element.rectElement.hachureGap,
                    hachureAngle: element.rectElement.hachureAngle,
                    seed: element.rectElement.seed,
                });

                // Restore the context state
                context.restore();
                context.rect(0, 0, element.width, element.height);

                // Tell Konva that the drawing is complete
                context.fillStrokeShape(shape);
            }}
        />
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-35-modules-bookpage-konva-shapes-rectangle-createrectangle-tsx">File 35: Modules/BookPage/Konva/shapes/Rectangle/createRectangle.tsx</h2>

```typescript
import { v4 as uuidv4 } from "uuid";
import {
    RectElement,
    SpecificRectElement
} from "../../../../../endPointTypes/types";

type CreateRectangleProps = {
    x: number;
    y: number;
    bookId: string;
} & Partial<Omit<SpecificRectElement, "type" | "x" | "y">> &
    Partial<RectElement>;

export default function CreateRectangle({
    x,
    y,
    bookId,
    fill = "green",
    width = 10,
    height = 10,
    id = uuidv4(),
    outgoingArrowIds = [],
    incomingArrowIds = [],
    strokeColor = "black",
    strokeWidth = 1,
    opacity = 1,
    points,
    roughness = 1,
    fillStyle = "hachure",
    hachureGap = 5,
    hachureAngle = 60,
    seed = Math.floor(Math.random() * 1000000),
    ...overrides
}: CreateRectangleProps): SpecificRectElement {
    return {
        type: "rect",
        bookId,
        fill,
        width,
        height,
        id,
        x,
        y,
        outgoingArrowIds,
        incomingArrowIds,
        opacity,
        rectElement: {
            canvaId: id,
            type: "rect",
            roughness,
            hachureGap,
            hachureAngle,

            fillStyle,
            seed,
        },
        points: points || [
            { x, y },
            { x: x + width, y },
            { x: x + width, y: y + height },
            { x, y: y + height },
        ],
        strokeColor,
        strokeWidth,
        rotation: 0,
        ...overrides, // This allows any additional properties to override the defaults
    };
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-36-modules-bookpage-konva-shapes-rendercanvaelement-tsx">File 36: Modules/BookPage/Konva/shapes/RenderCanvaElement.tsx</h2>

```typescript
import { KonvaEventObject } from "konva/lib/Node";
import RenderRectangle from "./Rectangle/RenderRectangle";
import RenderText from "./Text/RenderText";
import RenderCircle from "./Circle/RenderCircle";
import { CanvaElementSkeleton } from "../../../../endPointTypes/types";
import {
    isSpecificCircleElement,
    isSpecificRectElement,
    isSpecificTextElement,
} from "../../../../endPointTypes/typeGuards";

export const renderCanvaElement = (
    element: CanvaElementSkeleton,
    draggable: boolean,
    handleDragMove: ((e: KonvaEventObject<MouseEvent>) => void) | undefined
) => {
    if (isSpecificTextElement(element)) {
        return (
            <RenderText
                element={element}
                draggable={draggable}
                handleDragMove={handleDragMove}
                key={element.id}
            />
        );
    } else if (isSpecificRectElement(element)) {
        return (
            <RenderRectangle
                draggable={draggable}
                element={element}
                handleDragMove={handleDragMove}
                key={element.id}
            />
        );
    } else if (isSpecificCircleElement(element)) {
        return (
            <RenderCircle
                draggable={draggable}
                element={element}
                handleDragMove={handleDragMove}
                key={element.id}
            />
        );
    } else {
        return null;
    }
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-37-modules-bookpage-konva-shapes-text-createtext-tsx">File 37: Modules/BookPage/Konva/shapes/Text/CreateText.tsx</h2>

```typescript
// CreateText.ts
import { v4 as uuidv4 } from "uuid";
import {
    SpecificTextElement,
    TextElementType,
} from "../../../../../endPointTypes/types";
import { measureTextWidth } from "../../functions/measureTextWidth";

type CreateTextProps = {
    x: number;
    y: number;
    bookId: string;
} & Partial<
    Omit<SpecificTextElement, "type" | "x" | "y" | "TextElement"> &
        Partial<TextElementType>
>;

export default function CreateText({
    x,
    y,
    bookId,
    text = "New text",
    fontFamily = "Arial",
    fontSize = 16,
    fill = "#333333",
    id = uuidv4(),
    outgoingArrowIds = [],
    incomingArrowIds = [],
    strokeColor = "transparent",
    strokeWidth = 0,
    width,
    height,
    opacity = 1,
    points,
    fontWeight = "normal",
    fontStyle = "normal",
    textDecoration = "none",
    ...overrides
}: CreateTextProps): SpecificTextElement {
    // Calculate width and height based on text content if not provided
    const calculatedWidth = width ?? measureTextWidth(text, fontSize, fontFamily) + 20; // Add padding
    const calculatedHeight = height ?? fontSize * 1.5; // Reasonable height based on font size
    
    return {
        type: "text",
        id: id,
        bookId,
        textElement: {
            canvaId: id,
            type: "text",
            text,
            fontFamily,
            fontSize,
            fontWeight,
            fontStyle,
            textDecoration,
        },
        strokeColor,
        strokeWidth,
        width: calculatedWidth,
        height: calculatedHeight,
        opacity,
        fill,
        x,
        y,
        outgoingArrowIds: outgoingArrowIds ?? [], // Default to an empty array
        incomingArrowIds: incomingArrowIds ?? [], // Default to an empty array
        points: points || [
            { x, y },
            { x: x + calculatedWidth, y },
            { x: x + calculatedWidth, y: y + calculatedHeight },
            { x, y: y + calculatedHeight },
        ],
        rotation: 0,
        ...overrides,
    };
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-38-modules-bookpage-konva-shapes-text-rendertext-tsx">File 38: Modules/BookPage/Konva/shapes/Text/RenderText.tsx</h2>

```typescript
import { KonvaEventObject } from "konva/lib/Node";
import { Text } from "react-konva";
import {
    SpecificTextElement
} from "../../../../../endPointTypes/types";

export type RenderTextProps = {
    draggable: boolean;
    element: SpecificTextElement;
    handleDragMove: ((e: KonvaEventObject<MouseEvent>) => void) | undefined;
};
export default function RenderText({
    element,
    draggable,
    handleDragMove,
}: RenderTextProps) {
    return (
        <Text
            id={element.id}
            text={element.textElement.text}
            x={element.x}
            y={element.y}
            width={element.width}
            height={element.height}
            fill={element.fill}
            stroke={element.strokeColor}
            strokeWidth={element.strokeWidth}
            opacity={element.opacity}
            fontSize={element.textElement.fontSize}
            fontFamily={element.textElement.fontFamily}
            fontStyle={element.textElement.fontStyle}
            textDecoration={element.textElement.textDecoration}
            padding={5}
            align="left"
            verticalAlign="middle"
            wrap="word"
            ellipsis={true}
            draggable={draggable}
            onDragMove={handleDragMove}
            shadowColor="rgba(0,0,0,0.1)"
            shadowBlur={element.strokeWidth > 0 ? 0 : 2}
            shadowOffset={{ x: 1, y: 1 }}
            cornerRadius={2}
            attrs={{
                elementType: "text",
                textElement: element.textElement,
            }}
        />
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-39-modules-bookpage-konva-shapes-text-textelement-tsx">File 39: Modules/BookPage/Konva/shapes/Text/TextElement.tsx</h2>

```typescript
import { KonvaEventObject } from "konva/lib/Node";
import { v4 as uuidv4 } from "uuid";
import { useAtom } from "jotai";
import { Shape, ShapeConfig } from "konva/lib/Shape";
import { Stage } from "konva/lib/Stage";
import {
    ForwardedRef,
    forwardRef,
    MutableRefObject,
    useEffect,
    useImperativeHandle,
    useRef,
    useState,
} from "react";
import {
    CanvaElementSkeleton,
    SpecificTextElement,
} from "../../../../../endPointTypes/types";
import { getPos } from "../../functions/getPos";
import { measureTextWidth } from "../../functions/measureTextWidth";
import {
    activeToolAtom,
    bookIdAtom,
    canvaElementsAtom,
    offsetPositionAtom,
    scaleAtom,
    selectedItemsIdsAtom,
    settingsAtom,
} from "../../konvaAtoms";
import CreateText from "./CreateText";
import { isSpecificTextElement } from "../../../../../endPointTypes/typeGuards";

type TextElementProps = {
    createElement: (element: CanvaElementSkeleton) => void;
    updateElement: (element: CanvaElementSkeleton) => void;
    deleteElement: (id: string) => void;
    inputRef: MutableRefObject<HTMLInputElement | null>;
};

export type TextElementRef = {
    handleMouseDown: (e: KonvaEventObject<MouseEvent>) => void;
    handleMouseUp: () => void;
    handleDragMove: (
        element: SpecificTextElement,
        node: Shape<ShapeConfig> | Stage
    ) => Partial<SpecificTextElement>;
    handleDoubleClick: (e: KonvaEventObject<MouseEvent>) => void;
    handleKeyDown: (e: KeyboardEvent) => void;
    handleInputChange(e: React.ChangeEvent<HTMLInputElement>): void;
    updateElementDimensions(elementId: string, fontProps: {fontSize?: number, fontFamily?: string}): void;
};

function TextElement(
    { createElement, updateElement, deleteElement, inputRef }: TextElementProps,
    ref: ForwardedRef<TextElementRef>
) {
    const [activeTool] = useAtom(activeToolAtom);
    const [canvaElements] = useAtom(canvaElementsAtom);
    const [offsetPosition] = useAtom(offsetPositionAtom);
    const [scale] = useAtom(scaleAtom);
    const [isEditing, setIsEditing] = useState<boolean>(false);
    const [currentItem, setCurrentItem] = useState<SpecificTextElement | null>(null);
    const [bookId] = useAtom(bookIdAtom);
    const [selectedItemsIds, setSelectedItemsIds] = useAtom(selectedItemsIdsAtom);
    const previousSelectionRef = useRef<string[]>([]);
    const [settings] = useAtom(settingsAtom);
    useImperativeHandle(ref, () => ({
        handleMouseDown,
        handleMouseUp,
        handleDragMove,
        handleDoubleClick,
        handleKeyDown,
        handleInputChange,
        updateElementDimensions,
    }));
    
    // When text editing starts, hide the transformer
    useEffect(() => {
        if (isEditing && currentItem) {
            // Store the current selection before clearing it
            previousSelectionRef.current = [...selectedItemsIds];
            
            // Clear selections to hide transformer
            setSelectedItemsIds([]);
        }
    }, [isEditing]);
    
    // Create a full-overlay text editor that directly handles input
    useEffect(() => {
        if (!isEditing || !currentItem) {
            // Hide the editor when not editing
            const existingEditor = document.getElementById('text-editor');
            if (existingEditor) {
                existingEditor.style.display = 'none';
            }
            return;
        }

        // Create or get the editor element
        let editor = document.getElementById('text-editor') as HTMLDivElement;
        if (!editor) {
            editor = document.createElement('div');
            editor.id = 'text-editor';
            editor.contentEditable = 'true'; // Make directly editable
            document.body.appendChild(editor);
        }

        // Get stage container reference
        const stageContainer = document.querySelector('.konvajs-content');
        const containerRect = stageContainer?.getBoundingClientRect() || { left: 0, top: 0 };
        
        // Calculate position - adjust for scale and offset
        const x = (currentItem.x * scale + offsetPosition.x) + containerRect.left;
        const y = (currentItem.y * scale + offsetPosition.y) + containerRect.top;
        const width = currentItem.width *  scale;
        const height = currentItem.height * scale;
        
        // Style the editor to look like the text element
        editor.style.position = 'fixed';
        editor.style.left = `${x}px`;
        editor.style.top = `${y}px`;
        editor.style.width = `${width}px`;
        editor.style.minWidth = '150px';
        editor.style.minHeight = '30px';
        editor.style.padding = '5px';
        editor.style.background = 'rgba(255, 255, 255, 0.97)';
        editor.style.boxShadow = '0 2px 10px rgba(0, 0, 0, 0.2)';
        editor.style.borderRadius = '4px';
        editor.style.border = '1px solid #3f87ff';
        editor.style.zIndex = '1000';
        editor.style.fontFamily = currentItem.textElement.fontFamily || 'Arial';
        editor.style.fontSize = `${currentItem.textElement.fontSize * scale}px`;
        editor.style.color = currentItem.fill || '#333';
        editor.style.display = 'block';
        editor.style.outline = 'none';
        editor.style.overflow = 'auto';
        editor.style.resize = 'both'; // Allow resizing (optional)
        editor.style.whiteSpace = 'pre-wrap'; // Preserve whitespace and wrap
        editor.style.transition = 'all 0.2s ease';
        editor.style.animation = 'text-editor-pulse 1s ease-in-out 1'; // Add subtle animation
        
        // Append animation style if it doesn't exist
        if (!document.getElementById('text-editor-styles')) {
            const style = document.createElement('style');
            style.id = 'text-editor-styles';
            style.textContent = `
                @keyframes text-editor-pulse {
                    0% { box-shadow: 0 0 0 rgba(63, 135, 255, 0.5); }
                    50% { box-shadow: 0 0 10px rgba(63, 135, 255, 0.8); }
                    100% { box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Set the text content
        editor.textContent = currentItem.textElement.text;
        
        // Handle text changes
        const handleInput = () => {
            updateTextElement(editor.textContent || '');
        };
        
        // Handle special keys
        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'Escape') {
                finishEditing();
                e.preventDefault();
            } else if (e.key === 'Enter' && !e.shiftKey) {
                finishEditing();
                e.preventDefault();
            }
        };
        
        // Finish editing when clicking outside
        const handleClickOutside = (e: MouseEvent) => {
            if (editor && !editor.contains(e.target as Node) && e.target !== editor) {
                finishEditing();
            }
        };
        
        // Focus the editor
        editor.focus();
        
        // Position cursor at the end of text
        const range = document.createRange();
        const sel = window.getSelection();
        if (editor.childNodes.length > 0) {
            const lastNode = editor.childNodes[editor.childNodes.length - 1];
            range.setStart(lastNode, lastNode.textContent?.length || 0);
            range.collapse(true);
            sel?.removeAllRanges();
            sel?.addRange(range);
        }
        
        // Set up event listeners
        editor.addEventListener('input', handleInput);
        editor.addEventListener('keydown', handleKeyDown);
        document.addEventListener('mousedown', handleClickOutside);
        
        // Clean up event listeners when done
        return () => {
            editor.removeEventListener('input', handleInput);
            editor.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [isEditing, currentItem, scale, offsetPosition]);
    
    // The finishEditing function now only needs to handle the editor
    const finishEditing = () => {
        setIsEditing(false);
        
        const editor = document.getElementById('text-editor');
        if (editor) {
            editor.style.display = 'none';
        }
        
        // Restore selection
        if (currentItem) {
            setTimeout(() => {
                setSelectedItemsIds([currentItem.id]);
            }, 50);
        }
    };
    
    // Create new text element on mouse down (when Text tool is active)
    const handleMouseDown = (e: KonvaEventObject<MouseEvent>) => {
        if (!bookId) return;
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;
        if (activeTool !== "Text") return;
        
        // Create a new text element with better defaults
        const id = uuidv4();
        const newText = CreateText({
            x: pos.x,
            y: pos.y,
            bookId: bookId,
            id,
            text: "Enter text here",
            fontSize: 16,
            fill: "#333333",
        });
        
        setCurrentItem(newText);
        createElement(newText);
        
        // Start editing after a short delay to ensure element is created
        setTimeout(() => {
            setIsEditing(true);
        }, 50);
    };
    
    // Handle mouse up - only reset current item if not editing
    const handleMouseUp = () => {
        if (!isEditing) {
            setCurrentItem(null);
        }
    };
    
    // Handle dragging text elements
    const handleDragMove = (
        element: SpecificTextElement,
        node: Shape<ShapeConfig> | Stage
    ): Partial<SpecificTextElement> => {
        console.log("element", element);
        console.log("node", node);
        const newAttrs = {
          x: node.x(),
          y: node.y(),
          
          points: [
            { x: node.x(), y: node.y() },
            { x: node.x() + element.width, y: node.y() },
            {
              x: node.x() + element.width,
              y: node.y() + element.height,
            },
            { x: node.x(), y: node.y() + element.height },
          ],
        };
        console.log("element newAttrs", newAttrs);
        return newAttrs;
    };
    
    // Find elements at a specific position
    const getItemsAtPosition = (pos: { x: number; y: number }) => {
        return canvaElements.filter((item) => {
            return (
                pos.x >= item.x &&
                pos.x <= item.x + item.width &&
                pos.y >= item.y &&
                pos.y <= item.y + item.height
            );
        });
    };
    
    // Handle double-click to edit existing text
    const handleDoubleClick = (e: KonvaEventObject<MouseEvent>) => {
        // Only allow editing when the Select tool is active
        if (activeTool !== "Select") return;
        
        const pos = getPos(offsetPosition, scale, e);
        if (!pos) return;

        const clickedItem = getItemsAtPosition(pos).find((item) =>
            isSpecificTextElement(item)
        );

        if (clickedItem) {
            // Store current selection and hide transformer
            previousSelectionRef.current = [...selectedItemsIds];
            setSelectedItemsIds([]);
            
            // Set the current item and start editing
            setCurrentItem(clickedItem);
            
            // Short delay to ensure transformer is hidden
            setTimeout(() => {
                setIsEditing(true);
            }, 50);
        }
    };
    
    // Handle keyboard events (like Delete)
    const handleKeyDown = (e: KeyboardEvent) => {
        if (isEditing) return;
        if (!currentItem) return;
        
        if (e.key === "Delete" || e.key === "Backspace") {
            deleteElement(currentItem.id);
        }
    };

    
    // Update text element content and dimensions
    const updateTextElement = (text: string, newFontProps?: {fontSize?: number, fontFamily?: string}) => {
        if (!currentItem) return;
        
        // Calculate new dimensions based on text content and font properties
        const fontSize = currentItem.textElement.fontSize;
        const fontFamily = currentItem.textElement.fontFamily;
        
        // Ensure reasonable minimum width
        const textWidth = measureTextWidth(text, fontSize, fontFamily);
        const newWidth = Math.max(textWidth +20);
        const newHeight = Math.max(fontSize * 1.5);
        
        // Create updated element
        const updatedElement = {
            ...currentItem,
            textElement: {
                ...currentItem.textElement,
                text,
                ...(newFontProps || {})
            },
            width: newWidth,
            height: newHeight,
            points: [
                { x: currentItem.x, y: currentItem.y },
                { x: currentItem.x + newWidth, y: currentItem.y },
                { x: currentItem.x + newWidth, y: currentItem.y + newHeight },
                { x: currentItem.x, y: currentItem.y + newHeight }
            ]
        };
        
        // Update local state and parent component
        setCurrentItem(updatedElement);
        updateElement(updatedElement);
        
        // Update editor size if it exists
        const editor = document.getElementById('text-editor');
        if (editor) {
            editor.style.width = `${newWidth * scale}px`;
            if (newFontProps?.fontSize) {
                editor.style.fontSize = `${fontSize * scale}px`;
            }
        }
    };
    
    // Add this new function to update dimensions when font properties change
    const updateElementDimensions = (elementId: string, fontProps: {fontSize?: number, fontFamily?: string}) => {
        // Find the element by ID
        const element = canvaElements.find(el => el.id === elementId);
        if (!element || !isSpecificTextElement(element)) return;
        
        // Get current properties or use defaults
        const fontSize = fontProps?.fontSize || element.textElement.fontSize || 16;
        const fontFamily = fontProps?.fontFamily || element.textElement.fontFamily || 'Arial';
        const text = element.textElement.text || '';
        
        // Calculate new dimensions
        const textWidth = measureTextWidth(text, fontSize, fontFamily);
        const newWidth = Math.max(textWidth + 20, 60);
        const newHeight = Math.max(fontSize * 1.5, 30);
        
        // Create updated element
        const updatedElement = {
            ...element,
            textElement: {
                ...element.textElement,
                ...(fontProps || {})
            },
            width: newWidth,
            height: newHeight,
            points: [
                { x: element.x, y: element.y },
                { x: element.x + newWidth, y: element.y },
                { x: element.x + newWidth, y: element.y + newHeight },
                { x: element.x, y: element.y + newHeight }
            ]
        };
        
        // Update the element and refresh the current item if it's the one being edited
        updateElement(updatedElement);
        
        // If this is the current item being edited, update our local state too
        if (currentItem && currentItem.id === elementId) {
            setCurrentItem(updatedElement);
        }
        
        // Force an immediate re-selection to update the transformer
        if (selectedItemsIds.includes(elementId)) {
            const currentSelection = [...selectedItemsIds];
            setSelectedItemsIds([]);
            
            // Re-apply selection on next tick to force transformer update
            setTimeout(() => {
                setSelectedItemsIds(currentSelection);
            }, 10);
        }
    };
    
    // React change handler (kept for interface compatibility)
    const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (currentItem && isEditing) {
            updateTextElement(e.target.value);
        }
    };
    
    // Add this helper function to your component
    const calculateInputPosition = () => {
        if (!currentItem) return { x: 0, y: 0 };
        
        // Get stage and its container
        const stageContainer = document.querySelector('.konvajs-content');
        const stage = stageContainer?.querySelector('canvas');
        
        if (!stageContainer || !stage) return { x: 0, y: 0 };
        
        const containerRect = stageContainer.getBoundingClientRect();
        
        // Calculate the relative position in the stage
        // This factors in the scale and offset correctly
        const x = (currentItem.x * scale + offsetPosition.x) + containerRect.left;
        const y = (currentItem.y * scale + offsetPosition.y) + containerRect.top;
        
        return { x, y };
    };
    
    // Then in your useEffect
    // Component renders nothing directly - just handles logic
    return null;
}

export default forwardRef(TextElement);

```

<div style='page-break-after: always;'></div>

<h2 id="file-40-modules-bookpage-mainpage-tsx">File 40: Modules/BookPage/MainPage.tsx</h2>

```typescript
// src/pages/MainPage.tsx
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import { useEffect, useState, useRef, useCallback } from "react";
import { useSearchParams } from "react-router-dom";
import { Book } from "../../endPointTypes/types";
import { useAuth } from "../../hooks/userAuth";
import {
  startReadingSession,
  endReadingSession,
  updateBookProgress,
} from "../../api/bookTrackingApi";
import KonvaStage from "./Konva/KonvaStage";
import RightHand from "./RightHand";
import ProgressBar from "./ProgressBar";
import { displayPageAtom } from "./Konva/konvaAtoms";
import { useAtom, useSetAtom } from "jotai";
import { bookIdAtom, offsetPositionAtom } from "./Konva/konvaAtoms";
import { easeInOutCubic } from "./Notes/utils";
import { Card, CardContent } from "../../components/ui/card";
import { debounce } from "lodash";
import {
  arrowsAtom,
  canvaElementsAtom,
  highlightsAtom,
  scaleAtom,
} from "./Konva/konvaAtoms";
import { isEqual } from "lodash";
import BookSidebar from "./BookSidebar";

export type HighlightRange = {
  startElementId: string;
  startOffset: number;
  endElementId: string;
  endOffset: number;
  highlightedText: string;
  intermediateElementIds?: string[];
  highlightId: string;
};

// Fetch book function
const fetchBook = async (id: string, accessToken: string): Promise<Book> => {
  const { data } = await axios.get(`/api/book/${id}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });
  return data;
};

// Unified update function using PATCH
const patchBook = async (
  updateData: Partial<Book>,
  id: string,
  accessToken: string
): Promise<Book> => {
  const { data } = await axios.patch(`/api/book/${id}`, updateData, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });
  console.log("Updated Book Data:", data);
  return data;
};

function MainPage() {
  const { accessToken, user } = useAuth();
  const [searchParams] = useSearchParams();
  const bookId = searchParams.get("id");
  
  // Move these definitions to the top, before any useEffects
  const getCanvasStorageKey = useCallback(() => `book_${bookId}_canvas_elements`, [bookId]);
  const getCurveStorageKey = useCallback(() => `book_${bookId}_curve_elements`, [bookId]);
  const prevStateRef = useRef<Partial<Book>>({});
  
  const [sessionId, setSessionId] = useState<string | null>(null);
  const [startTime, setStartTime] = useState<Date | null>(null);
  const [displayPage, setDisplayPage] = useAtom(displayPageAtom);
  const [internalPage, setInternalPage] = useState(1);
  const [lastPosition, setLastPosition] = useState<number>(0);
  const [offsetPosition, setOffsetPosition] = useAtom(offsetPositionAtom);
  const [navigateBack, setNavigateBack] = useState(false);
  const offsetPositionRef = useRef(offsetPosition);
  const [updated, setUpdated] = useState(false);
  const queryClient = useQueryClient();
  const [arrows, setArrows] = useAtom(arrowsAtom);
  const [canvaElements, setCanvaElements] = useAtom(canvaElementsAtom);
  const [highlights, setHighlights] = useAtom(highlightsAtom);
  const [scale, setScale] = useAtom(scaleAtom);
  const [loaded, setLoaded] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(true);
  useEffect(() => {
    if (offsetPosition.x > 200 / scale || offsetPosition.x < -600 / scale) {
      setNavigateBack(true);
    } else {
      setNavigateBack(false);
    }
  }, [offsetPosition]);

  const setBookID = useSetAtom(bookIdAtom);
  // Use refs to track the latest values for the cleanup function
  const sessionIdRef = useRef<string | null>(null);
  const accessTokenRef = useRef<string | null>(null);

  // Update refs when values change
  useEffect(() => {
    sessionIdRef.current = sessionId;
    accessTokenRef.current = accessToken || null;
  }, [sessionId, accessToken]);

  // React Query: Fetch book data
  const {
    data: book,
    error,
    isLoading,
  } = useQuery({
    queryFn: () => {
      if (bookId) {
        setBookID(bookId!);
      }
      return fetchBook(bookId!, accessToken!);
    },
    queryKey: ["book", bookId],
    enabled: !!accessToken && !!user && !!bookId,
  });
  useEffect(() => {
    console.log("book", book);
    if (book) {
      setLoaded(true);
      setOffsetPosition(book.offsetPosition);
      setArrows(book.curveElements);
      setCanvaElements(book.canvaElements);
      setArrows(book.curveElements);
      setHighlights(book.highlights);
      setScale(book.scale);
    }
  }, [book]);
  const removeUnwantedProperties = (obj, propertiesToRemove) => {
    if (Array.isArray(obj)) {
      return obj.map((item) =>
        removeUnwantedProperties(item, propertiesToRemove)
      );
    } else if (typeof obj === "object" && obj !== null) {
      return Object.keys(obj).reduce((acc, key) => {
        if (!propertiesToRemove.includes(key)) {
          acc[key] = removeUnwantedProperties(obj[key], propertiesToRemove);
        }
        return acc;
      }, {});
    }
    return obj;
  };

  // React Query: Mutation for updating the book
  const mutation = useMutation<Book, Error, Partial<Book>, unknown>({
    mutationFn: (updateData) => patchBook(updateData, bookId!, accessToken!),
    onError: (error) => {
      console.error("Error updating book:", error.message);
      // Optionally, display an error message to the user
    },
    onSuccess: (data) => {
      console.log("Book updated successfully:", data);
      queryClient.setQueryData<Book>(["book", bookId], data);
    },
  });

  // Create debounced functions for saving to local storage
  const debouncedSaveCanvasElements = useCallback(
    debounce((elements, key) => {
      localStorage.setItem(key, JSON.stringify(elements));
      console.log("Saved canvas elements to local storage:", elements.length);
    }, 1000), // 1 second delay
    []
  );

  const debouncedSaveCurveElements = useCallback(
    debounce((elements, key) => {
      localStorage.setItem(key, JSON.stringify(elements));
      console.log("Saved curve elements to local storage:", elements.length);
    }, 1000), // 1 second delay
    []
  );

  // Create a debounced function for database updates
  const debouncedUpdateBookData = useCallback(
    debounce(async (changes: Partial<Book>) => {
      console.log("Debounced update with changes:", changes);
      if (!bookId || !accessToken) return;
      
      try {
        console.log("Saving changes to server:", changes);
        // Your API call to update the book
        await patchBook(changes, bookId!, accessToken!);

        // Update tracking data if page position changed
        if (changes.currentPage !== undefined) {
          await updateBookProgress(
            bookId!,
            changes.currentPage / (book?.totalPages || 100), // Calculate percentage
            changes.currentPage,
            accessTokenRef.current!
          );
        }
      } catch (error) {
        console.error("Failed to update book data:", error);
        // Optionally show an error notification
      }
    }, 2000), // 2 second delay for server updates
    [bookId, accessToken, book?.totalPages]
  );

  // Load canvas elements from local storage on initial load
  useEffect(() => {
    if (bookId && loaded) {
      // Try to get canvas elements from local storage
      const storedCanvasElements = localStorage.getItem(getCanvasStorageKey());
      if (storedCanvasElements) {
        try {
          const parsedElements = JSON.parse(storedCanvasElements);
          setCanvaElements(parsedElements);
          console.log("Loaded canvas elements from local storage:", parsedElements.length);
        } catch (error) {
          console.error("Error parsing canvas elements from local storage:", error);
        }
      }
      
      // Try to get curve elements from local storage
      const storedCurveElements = localStorage.getItem(getCurveStorageKey());
      if (storedCurveElements) {
        try {
          const parsedElements = JSON.parse(storedCurveElements);
          setArrows(parsedElements);
          console.log("Loaded curve elements from local storage:", parsedElements.length);
        } catch (error) {
          console.error("Error parsing curve elements from local storage:", error);
        }
      }
    }
  }, [bookId, loaded, getCanvasStorageKey, getCurveStorageKey]);
  
  // Save canvas elements to local storage when they change (debounced)
  useEffect(() => {
    if (bookId && loaded && canvaElements) {
      debouncedSaveCanvasElements(canvaElements, getCanvasStorageKey());
    }
    
    // Cleanup function to ensure pending saves are executed
    return () => {
      debouncedSaveCanvasElements.flush();
    };
  }, [canvaElements, bookId, loaded, getCanvasStorageKey, debouncedSaveCanvasElements]);
  
  // Save curve elements to local storage when they change (debounced)
  useEffect(() => {
    if (bookId && loaded && arrows) {
      debouncedSaveCurveElements(arrows, getCurveStorageKey());
    }
    
    // Cleanup function to ensure pending saves are executed
    return () => {
      debouncedSaveCurveElements.flush();
    };
  }, [arrows, bookId, loaded, getCurveStorageKey, debouncedSaveCurveElements]);
  
  // Update the highlights effect to use the debounced function
  useEffect(() => {
    if (!bookId || !accessToken || !book || !loaded) return;
    
    // Only check highlights changes
    if (!isEqual(highlights, prevStateRef.current.highlights)) {
      const changes: Partial<Book> = {
        highlights
      };
      
      console.log("Highlights changed, queueing update:", changes);
      debouncedUpdateBookData(changes);
      
      // Update the reference
      prevStateRef.current = {
        ...prevStateRef.current,
        highlights
      };
    }
  }, [highlights, bookId, accessToken, book, loaded, debouncedUpdateBookData]);

  // Update the scale effect to use the debounced function
  useEffect(() => {
    if (!bookId || !accessToken || !book || !loaded) return;
    
    // Only check scale changes
    if (scale !== prevStateRef.current.scale) {
      const changes: Partial<Book> = {
        scale
      };
      
      console.log("Scale changed, queueing update:", changes);
      debouncedUpdateBookData(changes);
      
      // Update the reference
      prevStateRef.current = {
        ...prevStateRef.current,
        scale
      };
    }
  }, [scale, bookId, accessToken, book, loaded, debouncedUpdateBookData]);

  // Update the offset position effect to use the debounced function
  useEffect(() => {
    if (!bookId || !accessToken || !book || !loaded) return;
    
    // Only check offsetPosition changes
    if (!isEqual(offsetPosition, prevStateRef.current.offsetPosition)) {
      const changes: Partial<Book> = {
        offsetPosition: {
          // Use the proper nested update format
          upsert: {
            create: {
              x: offsetPosition.x,
              y: offsetPosition.y
            },
            update: {
              x: offsetPosition.x,
              y: offsetPosition.y
            }
          }
        }
      };
      
      console.log("Offset position changed, queueing update:", changes);
      debouncedUpdateBookData(changes);
      
      // Update the reference
      prevStateRef.current = {
        ...prevStateRef.current,
        offsetPosition
      };
    }
  }, [offsetPosition, bookId, accessToken, book, loaded, debouncedUpdateBookData]);

  // Update the page change effect to use the debounced function
  useEffect(() => {
    if (!bookId || !accessToken || !book || !loaded) return;
    
    // Only check page changes
    if (internalPage !== prevStateRef.current.currentPage) {
      const changes: Partial<Book> = {
        currentPage: internalPage
      };
      
      console.log("Page changed, queueing update:", changes);
      debouncedUpdateBookData(changes);
      
      // Update the reference
      prevStateRef.current = {
        ...prevStateRef.current,
        currentPage: internalPage
      };
    }
  }, [internalPage, bookId, accessToken, book, loaded, debouncedUpdateBookData]);

  // Cleanup all debounced functions on component unmount
  useEffect(() => {
    return () => {
      debouncedSaveCanvasElements.cancel();
      debouncedSaveCurveElements.cancel();
      debouncedUpdateBookData.cancel();
    };
  }, [debouncedSaveCanvasElements, debouncedSaveCurveElements, debouncedUpdateBookData]);

  const startSessionMutation = useMutation({
    mutationFn: () => startReadingSession(bookId!, accessToken!),
    onSuccess: (data) => {
      console.log("Reading session started:", data);
      setSessionId(data.id);
      setStartTime(new Date());
    },
    onError: (error) => {
      console.error("Error starting reading session:", error);
    },
  });

  // Add this mutation for updating progress
  const updateProgressMutation = useMutation({
    mutationFn: () => {
      if (!book) return Promise.reject("Book data not available");
      console.log("Updating session progress", internalPage, book.totalPages);
      // Calculate progress percentage
      const progressPercent = Math.min(
        Math.max(internalPage / (book.totalPages || 100), 0),
        1
      );

      // Cap pages at the book's total pages
      const pagesRead = Math.min(internalPage, book.totalPages || 1);

      return updateBookProgress(
        bookId!,
        progressPercent,
        pagesRead,
        accessTokenRef.current!
      );
    },
    onSuccess: (data) => {
      console.log("Book progress updated:", data);
    },
    onError: (error) => {
      console.error("Error updating book progress:", error);
    },
  });

  // Modify the endSessionMutation to also update progress
  const endSessionMutation = useMutation({
    mutationFn: async () => {
      if (!sessionIdRef.current) return Promise.reject("No active session");

      // First end the reading session
      const sessionResult = await endReadingSession(
        sessionIdRef.current,
        internalPage,
        lastPosition,
        accessTokenRef.current!
      );

      // Then update the book progress
      if (book) {
        // Calculate progress percentage (0-1)
        const progressPercent = Math.min(
          Math.max(internalPage / (book.totalPages || 100), 0),
          1
        );

        // Cap pages at the book's total pages
        const pagesRead = Math.min(internalPage, book.totalPages || 1);

        await updateBookProgress(
          bookId!,
          progressPercent,
          pagesRead,
          accessTokenRef.current!
        );
      }

      return sessionResult;
    },
    onSuccess: (data) => {
      console.log("Reading session ended and progress updated:", data);
      setSessionId(null);
      setStartTime(null);
    },
    onError: (error) => {
      console.error("Error ending reading session:", error);
    },
  });

  // Update reading session mutation (for periodic updates)
  const updateSessionMutation = useMutation({
    mutationFn: () => {
      if (!sessionIdRef.current) return Promise.reject("No active session");
      return endReadingSession(
        sessionIdRef.current,
        internalPage,
        lastPosition,
        accessTokenRef.current!
      );
    },
    onSuccess: (data) => {
      console.log("Reading session updated:", data);
      // Don't reset the session ID or start time for updates
    },
    onError: (error) => {
      console.error("Error updating reading session:", error);
    },
  });

  // Start reading session when component mounts
  useEffect(() => {
    if (bookId && accessToken && user && !sessionId) {
      startSessionMutation.mutate();
    }
  }, [bookId, accessToken, user]);

  // Also update the periodic updates to include progress
  useEffect(() => {
    if (!sessionId) return;

    const updateInterval = setInterval(() => {
      if (sessionIdRef.current) {
        console.log("Periodic update of reading session");
        updateSessionMutation.mutate();
        updateProgressMutation.mutate(); // Also update progress
      }
    }, 5 * 1000); // 5 seconds

    return () => clearInterval(updateInterval);
  }, [sessionId, book]);

  // End reading session when component unmounts
  useEffect(() => {
    const handleBeforeUnload = () => {
      if (sessionIdRef.current) {
        // Use synchronous fetch for beforeunload
        const xhr = new XMLHttpRequest();
        xhr.open("POST", `/api/tracking/session/end`, false); // Synchronous request
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.setRequestHeader(
          "Authorization",
          `Bearer ${accessTokenRef.current}`
        );
        xhr.send(
          JSON.stringify({
            sessionId: sessionIdRef.current,
            pagesRead: internalPage,
            lastPosition: lastPosition,
          })
        );
      }
    };

    // Add beforeunload event listener
    window.addEventListener("beforeunload", handleBeforeUnload);

    // Regular cleanup function for component unmount
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);

      if (sessionIdRef.current) {
        // Try to end the session when component unmounts
        endSessionMutation.mutate();
      }
    };
  }, []);

  // Add visibility change listener to update session when tab becomes hidden
  useEffect(() => {
    const handleVisibilityChange = () => {
      if (document.visibilityState === "hidden" && sessionIdRef.current) {
        console.log("Page hidden, updating reading session");
        // Use the update mutation to save progress when tab becomes hidden
        updateSessionMutation.mutate();
      }
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);

    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);

  // Add a flag to track the source of page changes
  const [navigationSource, setNavigationSource] = useState<
    "scroll" | "progressBar"
  >("scroll");

  // Modify handlePageChange to only update internal state
  const handlePageChange = (page: number, position: number) => {
    console.log("Page changed", page, position);
    if (navigationSource !== "progressBar") {
      setInternalPage(page);
      setLastPosition(position);
      // Also update the display page for UI consistency
      setDisplayPage(page);
    }
  };
  useEffect(() => {
    offsetPositionRef.current = offsetPosition;
  }, [offsetPosition]);

  // Update handleNavigate to directly set display page
  const handleNavigate = (page: number) => {
    setDisplayPage(page);
    if (konvaStageRef.current) {
      konvaStageRef.current.navigateToPage(page);
    }
  };
  const smoothScroll = (targetX: number, targetY: number, duration: number) => {
    const start = performance.now();
    const initialOffset = { ...offsetPositionRef.current };
    const deltaX = targetX - initialOffset.x;
    const deltaY = targetY - initialOffset.y;

    const animateScroll = (currentTime: number) => {
      const elapsed = currentTime - start;
      const progress = Math.min(elapsed / duration, 1);
      const easeProgress = easeInOutCubic(progress);

      setOffsetPosition({
        x: initialOffset.x + deltaX * easeProgress,
        y: initialOffset.y + deltaY * easeProgress,
      });

      if (progress < 1) {
        requestAnimationFrame(animateScroll);
      }
    };

    requestAnimationFrame(animateScroll);
  };
  const navigateBackToText = () => {
    setScale(1)
    smoothScroll(-200 / scale, offsetPositionRef.current.y /scale, 500);
  };

  // Add a ref to the KonvaStage with proper typing
  const konvaStageRef = useRef<any>(null);

  const toggleSidebar = () => {
    setSidebarCollapsed(!sidebarCollapsed);
  };

  // Handle loading and error states
  if (isLoading) {
    return (
      <div className="flex min-h-screen w-full bg-amber-50 dark:bg-gray-900 items-center justify-center">
        <div className="flex flex-col items-center p-8 rounded-lg">
          <div className="relative w-24 h-24 mb-6">
            {/* Book loading animation */}
            <div className="absolute w-16 h-20 bg-amber-600 rounded-r-md animate-pulse"></div>
            <div className="absolute w-16 h-20 left-8 bg-amber-500 rounded-l-md animate-pulse"></div>
            <div className="absolute top-2 left-4 w-16 h-16 bg-amber-50 dark:bg-gray-800 rounded-md border-2 border-amber-600 animate-spin"></div>
            <div className="absolute bottom-0 w-full flex justify-center">
              <div className="h-1 w-16 bg-amber-600 animate-pulse"></div>
            </div>
          </div>

          <h2 className="text-2xl font-bold text-amber-800 dark:text-amber-500 mb-2">
            Loading your book
          </h2>

          <div className="flex space-x-2 mt-4">
            <div
              className="w-3 h-3 rounded-full bg-amber-600 animate-bounce"
              style={{ animationDelay: "0s" }}
            ></div>
            <div
              className="w-3 h-3 rounded-full bg-amber-600 animate-bounce"
              style={{ animationDelay: "0.2s" }}
            ></div>
            <div
              className="w-3 h-3 rounded-full bg-amber-600 animate-bounce"
              style={{ animationDelay: "0.4s" }}
            ></div>
          </div>

          <p className="text-gray-600 dark:text-gray-400 mt-4 text-center max-w-sm">
            Preparing your reading experience. This should only take a moment...
          </p>
        </div>
      </div>
    );
  }

  if (error) {
    return <div>Error loading book: {error.message}</div>;
  }
  if (!book) {
    return null;
  }
  // Extract book elements from the fetched book data
  const bookElements = book.bookElements;
  if (!bookElements) {
    return <div>No book elements found</div>;
  }
  return (
    <div className="flex min-h-screen flex-row w-full bg-zinc-800 text-gray-300 relative">
      <BookSidebar 
        isCollapsed={sidebarCollapsed} 
        toggleCollapse={toggleSidebar} 
      />
      <KonvaStage
        ref={konvaStageRef}
        chaptersData={book.chaptersData}
        bookElements={bookElements}
        onPageChange={handlePageChange}
        totalPages={book.totalPages || 0}
      />
      <RightHand
        sessionActive={!!sessionId}
        startTime={startTime}
        currentPage={internalPage}
        totalPages={book.totalPages || 0}
        onEndSession={endSessionMutation.mutate}
      />
      <ProgressBar
        currentPage={displayPage}
        totalPages={book.totalPages || 0}
        onNavigate={handleNavigate}
      />
      {navigateBack && (
        <div className="absolute bottom-32 left-1/2  flex items-center justify-center">
          <button
            className="bg-gray-100 text-black px-4 py-2 rounded-md"
            onClick={navigateBackToText}
          >
            Back to Text
          </button>
        </div>
      )}
    </div>
  );
}

export default MainPage;

```

<div style='page-break-after: always;'></div>

<h2 id="file-41-modules-bookpage-notes-notes-tsx">File 41: Modules/BookPage/Notes/Notes.tsx</h2>

```typescript
import { useAtom } from "jotai";
import { useEffect, useRef, useState } from "react";
import {
    arrowsAtom,
    canvaElementsAtom,
    offsetPositionAtom,
    highlightsAtom,
    scaleAtom,
} from "../Konva/konvaAtoms";
import { Badge } from "../../../components/ui/badge";
import { Button } from "../../../components/ui/button";
import { cn } from "../../../lib/utils";
import { Tabs, TabsList, TabsTrigger } from "../../../components/ui/tabs";
import { LayoutGrid, Clock, MapPin, MoreHorizontal } from "lucide-react";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuTrigger,
} from "../../../components/ui/dropdown-menu";

// Import types and utilities
import { Note, NotesProps, ViewType } from "./types";
import { getElementContent, easeInOutCubic, filterNotes, countNotesByType } from "./utils";

// Import components
import { CardView } from "./components/CardView";
import { TimelineView } from "./components/TimelineView";
import { SearchFilter } from "./components/SearchFilter";
import { EmptyState } from "./components/EmptyState";

export const Notes = ({ isDarkMode = false }: NotesProps) => {
    const [arrows] = useAtom(arrowsAtom);
    const [canvasElements] = useAtom(canvaElementsAtom);
    const [offsetPosition, setOffsetPosition] = useAtom(offsetPositionAtom);
    const [notes, setNotes] = useState<Note[]>([]);
    const [searchQuery, setSearchQuery] = useState("");
    const [activeFilter, setActiveFilter] = useState("all");
    const [expandedNote, setExpandedNote] = useState<string | null>(null);
    const [view, setView] = useState<ViewType>("card");
    const [highlightElements] = useAtom(highlightsAtom);
    const [scale] = useAtom(scaleAtom);
    useEffect(() => {
        console.log("notes", notes);
    }, [notes]);
    useEffect(() => {
        offsetPositionRef.current.x = offsetPosition.x
        offsetPositionRef.current.y = offsetPosition.y
    }, [offsetPosition]);
    
    // Extract text based on element type
    const getTextFromElement = (element: any, type: string): string => {
        if (!element) return "Unknown Element";
        
        if (type === "bookText" || type === "BookText") {
            // For highlights, use the highlighted text
            return element.highlightedText || "Highlighted Text";
        } else if (type === "text") {
            // For text elements, get the text content
            return element.textElement?.text || "Text Element";
        } else if (type === "rect" || type === "circle") {
            // For shapes, just show a placeholder
            return `${type.charAt(0).toUpperCase() + type.slice(1)} Shape`;
        } else {
            // Default case
            return "Unknown Element";
        }
    };
    
    // Process arrows to generate notes
    useEffect(() => {
        const validArrows = arrows.filter(
            (arrow) =>
                arrow.arrowElement.startId !== undefined &&
                arrow.arrowElement.endId !== undefined
        );

        const mappedNotes = validArrows.map((arrow) => {
            if (!arrow.arrowElement.startType || !arrow.arrowElement.endType) {
                throw new Error("Arrow does not have a start or end element");
            }
            let startElement: any = null;
            let endElement: any = null;
            if (arrow.arrowElement.startType === "bookText") {
                startElement = highlightElements.find(
                    (element) => element.id === arrow.arrowElement.startId
                );
            } else {
                startElement = canvasElements.find(
                    (element) => element.id === arrow.arrowElement.startId
                );
            }
            if (arrow.arrowElement.endType === "bookText") {
                console.log("from here arrow.arrowElement.endId", arrow.arrowElement.endId);
                console.log("from here highlightElements", highlightElements);
                endElement = highlightElements.find(
                    (element) => element.id === arrow.arrowElement.endId
                );

            } else {
                endElement = canvasElements.find(
                    (element) => element.id === arrow.arrowElement.endId
                );
            }
            
            // Get the appropriate text for start and end elements
            const startText = getTextFromElement(startElement, arrow.arrowElement.startType);
            const endText = getTextFromElement(endElement, arrow.arrowElement.endType);

            return {
                startElement,
                endElement,
                startText,
                endText,
                points: arrow.points,
                arrowId: arrow.id,
                startType: arrow.arrowElement.startType,
                endType: arrow.arrowElement.endType,
                createdAt: 'createdAt' in arrow ? arrow.createdAt : new Date(),
            };
        });

        setNotes(mappedNotes);
    }, [arrows, canvasElements]);
    
    const offsetPositionRef = useRef(offsetPosition);

    // Count notes by type for filtering
    const noteCounts = countNotesByType(notes);
    
    // Apply filtering based on search and filter
    const filteredNotes = filterNotes(notes, searchQuery, activeFilter);

    const smoothScroll = (
      targetX: number,
      targetY: number,
      duration: number
    ) => {
      const start = performance.now();
      const initialOffset = { ...offsetPositionRef.current };
      const deltaX = targetX - initialOffset.x;
      const deltaY = targetY - initialOffset.y;
        console.log("nou cia targetX", targetX);
        console.log("nou cia targetY", targetY);
        console.log("nou cia initialOffset.x", initialOffset.x);
        console.log("nou cia initialOffset.y", initialOffset.y);
      console.log("nou cia deltaX", deltaX);
      console.log("nou cia deltaY", deltaY);
      const animateScroll = (currentTime: number) => {
          console.log("offsetPositionRef.current", offsetPositionRef.current);
        const elapsed = currentTime - start;
        const progress = Math.min(elapsed / duration, 1);
        const easeProgress = easeInOutCubic(progress);
        
        setOffsetPosition({
          x: initialOffset.x + deltaX * easeProgress,
          y: initialOffset.y + deltaY * easeProgress,
        });

        if (progress < 1) {
          requestAnimationFrame(animateScroll);
        }
      };

      requestAnimationFrame(animateScroll);
    };
   
    // Handle note click to navigate on canvas
    const handleNoteClick = (note: Note) => {
        console.log("note singular", note);
        if (note.points && note.points.length >= 2) {
            const targetY = -note.points[0].y;
            offsetPositionRef.current.x = offsetPosition.x
            offsetPositionRef.current.y = offsetPosition.y

            smoothScroll((note.points[0].x + 30 )/ scale, (targetY + 200 )/scale, 500);
        }
    };

    // When view changes, close any expanded notes
    const handleViewChange = (newView: ViewType) => {
        setExpandedNote(null);
        setView(newView);
    };

    return (
        <div className={cn(
            "h-full flex flex-col",
            isDarkMode ? "bg-gray-900 text-gray-200" : "bg-white text-gray-800"
        )}>
            {/* Header with title, count, and view options */}
            <div className="px-4 pt-4 pb-2">
                <div className="flex items-center justify-between mb-3">
                    <div className="flex items-center gap-2">
                        <h2 className={cn(
                            "text-lg font-semibold",
                            isDarkMode ? "text-amber-300" : "text-amber-700"
                        )}>
                            Notes & Connections
                        </h2>
                        <Badge variant={isDarkMode ? "outline" : "secondary"} className="font-normal">
                            {notes.length} {notes.length === 1 ? 'Connection' : 'Connections'}
                        </Badge>
                    </div>
                    
                    <div className="flex items-center gap-1">
                        <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                                <Button variant="ghost" size="icon" className="h-8 w-8">
                                    <MoreHorizontal className="h-4 w-4" />
                                </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                                <DropdownMenuItem>
                                    Export connections
                                </DropdownMenuItem>
                                <DropdownMenuItem>
                                    Print view
                                </DropdownMenuItem>
                                <DropdownMenuItem>
                                    Group by type
                                </DropdownMenuItem>
                            </DropdownMenuContent>
                        </DropdownMenu>
                    </div>
                </div>
                
                {/* Search and filtering */}
                <SearchFilter 
                    isDarkMode={isDarkMode}
                    searchQuery={searchQuery}
                    setSearchQuery={setSearchQuery}
                    activeFilter={activeFilter}
                    setActiveFilter={setActiveFilter}
                    noteCounts={noteCounts}
                />
            </div>
            
            {/* View selector tabs */}
            <div className="px-4 pb-2">
                <Tabs defaultValue="card" value={view} className="w-full" onValueChange={(v) => handleViewChange(v as ViewType)}>
                    <TabsList className={cn(
                        "grid grid-cols-3 w-full h-8",
                        isDarkMode ? "bg-gray-800" : "bg-gray-100"
                    )}>
                        <TabsTrigger 
                            value="card" 
                            className={cn(
                                "text-xs flex items-center gap-1",
                                isDarkMode ? "data-[state=active]:bg-gray-700" : "data-[state=active]:bg-white"
                            )}
                        >
                            <LayoutGrid className="h-3.5 w-3.5" />
                            <span>Cards</span>
                        </TabsTrigger>
                        <TabsTrigger 
                            value="timeline" 
                            className={cn(
                                "text-xs flex items-center gap-1",
                                isDarkMode ? "data-[state=active]:bg-gray-700" : "data-[state=active]:bg-white"
                            )}
                        >
                            <Clock className="h-3.5 w-3.5" />
                            <span>Timeline</span>
                        </TabsTrigger>
                       
                    </TabsList>
                </Tabs>
            </div>
            
            {/* Main content area */}
            <div className="flex-1 overflow-hidden">
                {filteredNotes.length > 0 ? (
                    <>
                        {view === 'card' && (
                            <CardView 
                                notes={filteredNotes} 
                                isDarkMode={isDarkMode} 
                                expandedNote={expandedNote} 
                                setExpandedNote={setExpandedNote} 
                                handleNoteClick={handleNoteClick} 
                            />
                        )}
                        
                        {view === 'timeline' && (
                            <TimelineView 
                                notes={filteredNotes} 
                                isDarkMode={isDarkMode} 
                                handleNoteClick={handleNoteClick} 
                            />
                        )}
                        
                        
                    </>
                ) : (
                    // Show empty state when no notes or all filtered out
                    <EmptyState isDarkMode={isDarkMode} />
                )}
            </div>
        </div>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-42-modules-bookpage-notes-components-cardview-tsx">File 42: Modules/BookPage/Notes/components/CardView.tsx</h2>

```typescript
import { Note } from "../types";
import { ArrowLeftRight, Book, StickyNote, Image, ArrowRight, Clock, ChevronDown, List } from "lucide-react";
import { cn } from "../../../../lib/utils";
import { Button } from "../../../../components/ui/button";
import { ScrollArea } from "../../../../components/ui/scroll-area";
import { motion } from "framer-motion";
import { NoteActions } from "./NoteActions";
import { 
    getConnectionLabel, 
    getConnectionTypeColor, 
    truncateText 
} from "../utils";

type CardViewProps = {
    notes: Note[];
    isDarkMode: boolean;
    expandedNote: string | null;
    setExpandedNote: (id: string | null) => void;
    handleNoteClick: (note: Note) => void;
};

export const CardView = ({ 
    notes, 
    isDarkMode, 
    expandedNote, 
    setExpandedNote, 
    handleNoteClick 
}: CardViewProps) => {
    // Get appropriate icon for element type
    const getTypeIcon = (type: string) => {
        switch (type) {
            case 'BookText':
                return <Book className="h-4 w-4" />;
            case 'StickyNote':
                return <StickyNote className="h-4 w-4" />;
            case 'Image':
                return <Image className="h-4 w-4" />;
            default:
                return <Book className="h-4 w-4" />;
        }
    };

    // Get additional type-specific info based on element type
    const getTypeSpecificInfo = (type: string) => {
        switch (type) {
            case 'BookText':
                return <span className="text-xs opacity-80">Book Content</span>;
            case 'StickyNote':
                return <span className="text-xs opacity-80">Personal Note</span>;
            case 'Image':
                return <span className="text-xs opacity-80">Visual Element</span>;
            default:
                return null;
        }
    };

    // Get a different truncation length based on expanded state
    const getTruncatedText = (text: string, noteId: string) => {
        return expandedNote === noteId ? text : truncateText(text);
    };
    return (
        <ScrollArea className="h-full pb-4">
            <div className="p-3 space-y-3">
                {notes.map((note) => (
                    <motion.div
                        key={note.arrowId}
                        initial={{ opacity: 0, y: 10 }}
                        animate={{ opacity: 1, y: 0 }}
                        transition={{ duration: 0.2 }}
                    >
                        <div 
                            className={cn(
                                "rounded-lg overflow-hidden border shadow-sm transition-all duration-300",
                                expandedNote === note.arrowId ? "shadow-md" : "",
                                isDarkMode ? "border-gray-700" : "border-gray-200",
                            )}
                        >
                            {/* Card header with gradient background */}
                            <div 
                                className={cn(
                                    "p-3 flex items-center justify-between bg-gradient-to-r",
                                    getConnectionTypeColor(note.startType, note.endType, isDarkMode)
                                )}
                            >
                                <div className="flex items-center gap-1.5">
                                    <ArrowLeftRight className="h-3.5 w-3.5" />
                                    <span className="text-xs font-medium">
                                        {getConnectionLabel(note.startType, note.endType)}
                                    </span>
                                </div>
                                
                                <div className="flex items-center gap-1">
                                    {note.createdAt && (
                                        <span className="text-xs opacity-80 mr-1">
                                            {new Date(note.createdAt).toLocaleDateString()}
                                        </span>
                                    )}
                                    
                                    <div className="flex">
                                        <Button 
                                            variant="ghost" 
                                            size="icon" 
                                            className="h-6 w-6 rounded-full opacity-70 hover:opacity-100"
                                            onClick={(e) => {
                                                e.stopPropagation();
                                                setExpandedNote(
                                                    expandedNote === note.arrowId ? null : note.arrowId
                                                );
                                            }}
                                        >
                                            <ChevronDown 
                                                className={cn(
                                                    "h-3.5 w-3.5 transition-transform",
                                                    expandedNote === note.arrowId ? "transform rotate-180" : ""
                                                )} 
                                            />
                                        </Button>
                                    </div>
                                </div>
                            </div>
                            
                            {/* Card content */}
                            <div 
                                className={cn(
                                    "transition-all duration-300",
                                    expandedNote === note.arrowId ? "p-3.5" : "p-3",
                                    isDarkMode ? "bg-gray-800" : "bg-white"
                                )}
                                onClick={() => handleNoteClick(note)}
                            >
                                {/* Visual connection panel with mini-map */}
                                <div className={cn(
                                    "mb-3 p-2 rounded-md transition-all duration-300 overflow-hidden flex justify-center",
                                    expandedNote === note.arrowId ? "opacity-100 max-h-24" : "opacity-0 max-h-0 p-0 m-0",
                                    isDarkMode ? "bg-gray-700/50" : "bg-gray-50"
                                )}>
                                    {expandedNote === note.arrowId && (
                                        <div className="relative w-64 h-16">
                                            <div className="absolute inset-0 flex items-center justify-center">
                                                <div className={cn(
                                                    "w-24 h-0.5 transform -translate-y-1",
                                                    isDarkMode ? "bg-gray-600" : "bg-gray-300"
                                                )}></div>
                                                <div className="absolute left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
                                                    <ArrowRight className={cn(
                                                        "h-4 w-4",
                                                        isDarkMode ? "text-gray-500" : "text-gray-400"
                                                    )} />
                                                </div>
                                            </div>
                                            {/* Start element indicator */}
                                            <div className="absolute left-1/4 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
                                                <div className={cn(
                                                    "w-8 h-8 rounded-full flex items-center justify-center",
                                                    note.startType === "BookText" ? (isDarkMode ? "bg-emerald-900/50" : "bg-emerald-100") :
                                                    note.startType === "StickyNote" ? (isDarkMode ? "bg-amber-900/50" : "bg-amber-100") :
                                                    (isDarkMode ? "bg-sky-900/50" : "bg-sky-100")
                                                )}>
                                                    {getTypeIcon(note.startType)}
                                                </div>
                                            </div>
                                            {/* End element indicator */}
                                            <div className="absolute left-3/4 top-1/2 transform -translate-x-1/2 -translate-y-1/2">
                                                <div className={cn(
                                                    "w-8 h-8 rounded-full flex items-center justify-center",
                                                    note.endType === "BookText" ? (isDarkMode ? "bg-emerald-900/50" : "bg-emerald-100") :
                                                    note.endType === "StickyNote" ? (isDarkMode ? "bg-amber-900/50" : "bg-amber-100") :
                                                    (isDarkMode ? "bg-sky-900/50" : "bg-sky-100")
                                                )}>
                                                    {getTypeIcon(note.endType)}
                                                </div>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                
                                <div className="flex flex-col space-y-3">
                                    {/* Start element (from) */}
                                    <div className="flex items-start gap-2">
                                        <div className={cn(
                                            "p-1.5 rounded-md mt-0.5", 
                                            isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                        )}>
                                            {getTypeIcon(note.startType)}
                                        </div>
                                        <div className="flex-1 text-sm">
                                            <div className="flex items-center justify-between mb-1">
                                                <p className={cn(
                                                    "text-xs font-medium",
                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                )}>
                                                    From: {note.startType}
                                                </p>
                                                {getTypeSpecificInfo(note.startType)}
                                            </div>
                                            <p className="break-words">
                                                {getTruncatedText(note.startText, note.arrowId)}
                                            </p>
                                            
                                            {/* Type-specific content for BookText */}
                                            {expandedNote === note.arrowId && note.startType === "BookText" && (
                                                <div className={cn(
                                                    "mt-2 p-1.5 text-xs rounded",
                                                    isDarkMode ? "bg-emerald-900/20 text-emerald-300" : "bg-emerald-50 text-emerald-700"
                                                )}>
                                                    <div className="flex items-center gap-1 mb-1 font-medium">
                                                        <List className="h-3 w-3" />
                                                        <span>Context</span>
                                                    </div>
                                                    <p className="opacity-80">Part of book content</p>
                                                </div>
                                            )}
                                            
                                            {/* Type-specific content for StickyNote */}
                                            {expandedNote === note.arrowId && note.startType === "StickyNote" && (
                                                <div className={cn(
                                                    "mt-2 p-1.5 text-xs rounded",
                                                    isDarkMode ? "bg-amber-900/20 text-amber-300" : "bg-amber-50 text-amber-700"
                                                )}>
                                                    <div className="flex items-center gap-1 mb-1 font-medium">
                                                        <StickyNote className="h-3 w-3" />
                                                        <span>User Note</span>
                                                    </div>
                                                    <p className="opacity-80">Your personal annotation</p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    {/* End element (to) */}
                                    <div className="flex items-start gap-2">
                                        <div className={cn(
                                            "p-1.5 rounded-md mt-0.5", 
                                            isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                        )}>
                                            {getTypeIcon(note.endType)}
                                        </div>
                                        <div className="flex-1 text-sm">
                                            <div className="flex items-center justify-between mb-1">
                                                <p className={cn(
                                                    "text-xs font-medium",
                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                )}>
                                                    To: {note.endType}
                                                </p>
                                                {getTypeSpecificInfo(note.endType)}
                                            </div>
                                            <p className="break-words">
                                                {getTruncatedText(note.endText, note.arrowId)}
                                            </p>
                                            
                                            {/* Type-specific content for BookText */}
                                            {expandedNote === note.arrowId && note.endType === "BookText" && (
                                                <div className={cn(
                                                    "mt-2 p-1.5 text-xs rounded",
                                                    isDarkMode ? "bg-emerald-900/20 text-emerald-300" : "bg-emerald-50 text-emerald-700"
                                                )}>
                                                    <div className="flex items-center gap-1 mb-1 font-medium">
                                                        <List className="h-3 w-3" />
                                                        <span>Context</span>
                                                    </div>
                                                    <p className="opacity-80">Part of book content</p>
                                                </div>
                                            )}
                                            
                                            {/* Type-specific content for StickyNote */}
                                            {expandedNote === note.arrowId && note.endType === "StickyNote" && (
                                                <div className={cn(
                                                    "mt-2 p-1.5 text-xs rounded",
                                                    isDarkMode ? "bg-amber-900/20 text-amber-300" : "bg-amber-50 text-amber-700"
                                                )}>
                                                    <div className="flex items-center gap-1 mb-1 font-medium">
                                                        <StickyNote className="h-3 w-3" />
                                                        <span>User Note</span>
                                                    </div>
                                                    <p className="opacity-80">Your personal annotation</p>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Action buttons - shown only in expanded state */}
                                <div className={cn(
                                    "mt-3 pt-3 flex justify-end gap-1 transition-all duration-300 overflow-hidden",
                                    expandedNote === note.arrowId ? "opacity-100 border-t" : "opacity-0 max-h-0 pt-0 mt-0 border-none",
                                    isDarkMode ? "border-gray-700" : "border-gray-200"
                                )}>
                                    {expandedNote === note.arrowId && (
                                        <NoteActions 
                                            note={note} 
                                            isDarkMode={isDarkMode} 
                                            handleNoteClick={handleNoteClick} 
                                        />
                                    )}
                                </div>
                            </div>
                        </div>
                    </motion.div>
                ))}
            </div>
        </ScrollArea>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-43-modules-bookpage-notes-components-emptystate-tsx">File 43: Modules/BookPage/Notes/components/EmptyState.tsx</h2>

```typescript
import { ArrowLeftRight } from "lucide-react";
import { cn } from "../../../../lib/utils";

type EmptyStateProps = {
    isDarkMode: boolean;
};

export const EmptyState = ({ isDarkMode }: EmptyStateProps) => {
    return (
        <div className={cn(
            "flex flex-col items-center justify-center h-[calc(100vh-180px)] space-y-3",
            isDarkMode ? "text-gray-400" : "text-gray-500"
        )}>
            <ArrowLeftRight className="h-10 w-10 opacity-30" />
            <div className="text-center space-y-1">
                <p className="font-medium">No connections yet</p>
                <p className="text-sm opacity-70">Create connections between text and notes to see them here</p>
            </div>
        </div>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-44-modules-bookpage-notes-components-noteactions-tsx">File 44: Modules/BookPage/Notes/components/NoteActions.tsx</h2>

```typescript
import { Button } from "../../../../components/ui/button";
import { ExternalLink, Edit, Trash2 } from "lucide-react";
import { cn } from "../../../../lib/utils";
import { Note } from "../types";

type NoteActionsProps = {
    note: Note;
    isDarkMode: boolean;
    handleNoteClick: (note: Note) => void;
};

export const NoteActions = ({ note, isDarkMode, handleNoteClick }: NoteActionsProps) => {
    return (
        <>
            <Button 
                size="sm" 
                variant="outline"
                className="text-xs h-7 px-2"
                onClick={(e) => {
                    e.stopPropagation();
                    handleNoteClick(note);
                }}
            >
                <ExternalLink className="h-3 w-3 mr-1" />
                Go to
            </Button>
            
            <Button 
                size="sm" 
                variant="outline"
                className="text-xs h-7 px-2"
            >
                <Edit className="h-3 w-3 mr-1" />
                Edit
            </Button>
            
            <Button 
                size="sm" 
                variant="outline"
                className={cn(
                    "text-xs h-7 px-2",
                    isDarkMode ? "hover:bg-red-900/20 hover:text-red-400" : "hover:bg-red-50 hover:text-red-500"
                )}
            >
                <Trash2 className="h-3 w-3 mr-1" />
                Delete
            </Button>
        </>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-45-modules-bookpage-notes-components-searchfilter-tsx">File 45: Modules/BookPage/Notes/components/SearchFilter.tsx</h2>

```typescript
import { Search, X, Filter } from "lucide-react";
import { Badge } from "../../../../components/ui/badge";
import { Button } from "../../../../components/ui/button";
import { cn } from "../../../../lib/utils";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuTrigger,
} from "../../../../components/ui/dropdown-menu";
import { NoteCounts, ConnectionType } from "../types";

type SearchFilterProps = {
    isDarkMode: boolean;
    searchQuery: string;
    setSearchQuery: (query: string) => void;
    activeFilter: string;
    setActiveFilter: (filter: string) => void;
    noteCounts: NoteCounts;
};

export const SearchFilter = ({ 
    isDarkMode, 
    searchQuery, 
    setSearchQuery, 
    activeFilter, 
    setActiveFilter,
    noteCounts
}: SearchFilterProps) => {
    return (
        <div className="flex items-center space-x-2">
            <div className={cn(
                "flex items-center px-2 h-8 rounded-md flex-1 border",
                isDarkMode ? "bg-gray-800 border-gray-700" : "bg-gray-50 border-gray-200"
            )}>
                <Search className="h-4 w-4 opacity-50 mr-1" />
                <input 
                    type="text"
                    placeholder="Search connections..."
                    className={cn(
                        "bg-transparent border-none outline-none text-sm w-full",
                        isDarkMode ? "placeholder:text-gray-500" : "placeholder:text-gray-400"
                    )}
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                />
                {searchQuery && (
                    <button onClick={() => setSearchQuery("")}>
                        <X className="h-3 w-3 opacity-50" />
                    </button>
                )}
            </div>
            
            <DropdownMenu>
                <DropdownMenuTrigger asChild>
                    <Button 
                        variant={isDarkMode ? "outline" : "secondary"} 
                        size="sm" 
                        className={cn(
                            "h-8 text-xs gap-1",
                            activeFilter !== "all" && (isDarkMode ? "border-amber-700" : "bg-amber-100 text-amber-900")
                        )}
                    >
                        <Filter className="h-3 w-3" />
                        {activeFilter !== "all" && (
                            <span className="capitalize">
                                {activeFilter.replace("-", " ")}
                            </span>
                        )}
                    </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                    <DropdownMenuItem 
                        onClick={() => setActiveFilter("all")}
                        className="flex justify-between"
                    >
                        <span>All</span>
                        <Badge variant="outline" className="ml-2">{noteCounts.all || 0}</Badge>
                    </DropdownMenuItem>
                    {["text-annotation", "note-reference", "text-connection", "note-note", "image-connection"].map(type => (
                        noteCounts[type] > 0 && (
                            <DropdownMenuItem 
                                key={type}
                                onClick={() => setActiveFilter(type)}
                                className="flex justify-between"
                            >
                                <span className="capitalize">{type.replace("-", " ")}</span>
                                <Badge variant="outline" className="ml-2">{noteCounts[type] || 0}</Badge>
                            </DropdownMenuItem>
                        )
                    ))}
                </DropdownMenuContent>
            </DropdownMenu>
        </div>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-46-modules-bookpage-notes-components-timelineview-tsx">File 46: Modules/BookPage/Notes/components/TimelineView.tsx</h2>

```typescript
import { Note } from "../types";
import { ArrowLeftRight, Clock, ExternalLink } from "lucide-react";
import { cn } from "../../../../lib/utils";
import { Button } from "../../../../components/ui/button";
import { ScrollArea } from "../../../../components/ui/scroll-area";
import { motion } from "framer-motion";
import { 
    getConnectionLabel, 
    getConnectionTypeColor, 
    truncateText,
    groupNotesByDate 
} from "../utils";

type TimelineViewProps = {
    notes: Note[];
    isDarkMode: boolean;
    handleNoteClick: (note: Note) => void;
};

export const TimelineView = ({ notes, isDarkMode, handleNoteClick }: TimelineViewProps) => {
    const groupedNotesByDate = groupNotesByDate(notes);
    
    // Get appropriate icon for element type
    const getTypeIcon = (type: string) => {
        switch (type) {
            case 'BookText':
                return <div className={cn(
                    "w-3 h-3 rounded-sm", 
                    isDarkMode ? "bg-emerald-600" : "bg-emerald-400"
                )}></div>;
            case 'StickyNote':
                return <div className={cn(
                    "w-3 h-3 rounded-sm", 
                    isDarkMode ? "bg-amber-600" : "bg-amber-400"
                )}></div>;
            case 'Image':
                return <div className={cn(
                    "w-3 h-3 rounded-sm", 
                    isDarkMode ? "bg-sky-600" : "bg-sky-400"
                )}></div>;
            default:
                return <div className={cn(
                    "w-3 h-3 rounded-sm", 
                    isDarkMode ? "bg-gray-600" : "bg-gray-400"
                )}></div>;
        }
    };

    return (
        <ScrollArea className="h-full">
            <div className="p-3 relative">
                {/* Timeline central line */}
                <div className={cn(
                    "absolute left-[41px] top-8 bottom-4 w-0.5",
                    isDarkMode ? "bg-gray-700" : "bg-gray-200"
                )}></div>
                
                {Object.entries(groupedNotesByDate).map(([date, dateNotes], dateIndex) => (
                    <div key={date} className="mb-6">
                        <div className="flex items-center mb-2">
                            <div className={cn(
                                "w-6 h-6 rounded-full flex items-center justify-center mr-5 z-10",
                                isDarkMode ? "bg-amber-700 text-amber-200" : "bg-amber-100 text-amber-700"
                            )}>
                                <Clock className="h-3 w-3" />
                            </div>
                            <h3 className={cn(
                                "text-sm font-medium",
                                isDarkMode ? "text-amber-300" : "text-amber-700"
                            )}>
                                {date}
                            </h3>
                        </div>
                        
                        <div className="space-y-2 ml-[42px]">
                            {dateNotes.map((note, noteIndex) => (
                                <motion.div
                                    key={note.arrowId}
                                    initial={{ opacity: 0, x: 20 }}
                                    animate={{ opacity: 1, x: 0 }}
                                    transition={{ duration: 0.3, delay: noteIndex * 0.05 }}
                                    className={cn(
                                        "rounded-md p-2 flex gap-3 cursor-pointer transition-colors",
                                        isDarkMode 
                                            ? "bg-gray-800 hover:bg-gray-750 border border-gray-700" 
                                            : "bg-white hover:bg-gray-50 border border-gray-200",
                                    )}
                                    onClick={() => handleNoteClick(note)}
                                >
                                    <div className={cn(
                                        "w-6 h-6 rounded-md flex items-center justify-center flex-shrink-0 mt-1",
                                        isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                    )}>
                                        <ArrowLeftRight className="h-3 w-3" />
                                    </div>
                                    
                                    <div>
                                        <div className={cn(
                                            "text-xs inline-block px-1.5 py-0.5 rounded mb-1",
                                            getConnectionTypeColor(note.startType, note.endType, isDarkMode)
                                        )}>
                                            {getConnectionLabel(note.startType, note.endType)}
                                        </div>
                                        
                                        <div className="flex items-center gap-1.5 mb-1">
                                            <div className={cn(
                                                "p-1 rounded", 
                                                isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                            )}>
                                                {getTypeIcon(note.startType)}
                                            </div>
                                            <span className="text-xs">to</span>
                                            <div className={cn(
                                                "p-1 rounded", 
                                                isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                            )}>
                                                {getTypeIcon(note.endType)}
                                            </div>
                                        </div>
                                        
                                        <p className="text-xs mt-1 max-w-md">
                                            {truncateText(note.startText, 30)} 
                                            <span className="mx-1 opacity-50">→</span>
                                            {truncateText(note.endText, 30)}
                                        </p>
                                    </div>
                                    
                                    <Button 
                                        variant="ghost" 
                                        size="icon" 
                                        className={cn(
                                            "h-6 w-6 rounded-full ml-auto flex-shrink-0",
                                            isDarkMode ? "text-gray-400 hover:text-white" : "text-gray-500 hover:text-black"
                                        )}
                                        onClick={(e) => {
                                            e.stopPropagation();
                                            handleNoteClick(note);
                                        }}
                                    >
                                        <ExternalLink className="h-3 w-3" />
                                    </Button>
                                </motion.div>
                            ))}
                        </div>
                    </div>
                ))}
            </div>
        </ScrollArea>
    );
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-47-modules-bookpage-notes-types-ts">File 47: Modules/BookPage/Notes/types.ts</h2>

```typescript
import { CanvaElementSkeleton, Point, Highlight } from "../../../endPointTypes/types";
export type Note = {
    startElement: CanvaElementSkeleton | Highlight;
    endElement: CanvaElementSkeleton | Highlight;
    points: Point[];
    arrowId: string;
    startType: string;
    endType: string;
    createdAt?: Date;
};

export type NotesProps = {
    isDarkMode?: boolean;
};

export type ViewType = "card" | "timeline" | "map";

export type ConnectionType = 
    | "text-annotation" 
    | "note-reference" 
    | "text-connection" 
    | "note-note" 
    | "image-connection" 
    | "other" 
    | "all";

export type GroupedNotes = Record<string, Note[]>;
export type NoteCounts = Record<string, number>; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-48-modules-bookpage-notes-utils-ts">File 48: Modules/BookPage/Notes/utils.ts</h2>

```typescript
import { Note, ConnectionType } from "./types";
import { cn } from "../../../lib/utils";

// Get element content based on type
export function getElementContent(element: any, type: string): string {
    if (!element) return "Unknown";
    if (type === "BookText") {
        return element.text || "Book Text";
    } else if (type === "StickyNote") {
        return element.content || "Sticky Note";
    } else if (type === "Image") {
        return "Image";
    }
    return "Unknown";
}

// Get connection type for filtering
export const getConnectionType = (startType: string, endType: string): ConnectionType => {
    if (startType === "BookText" && endType === "StickyNote") {
        return "text-annotation";
    } else if (startType === "StickyNote" && endType === "BookText") {
        return "note-reference";
    } else if (startType === "BookText" && endType === "BookText") {
        return "text-connection";
    } else if (startType === "StickyNote" && endType === "StickyNote") {
        return "note-note";
    } else if (startType === "Image" && (endType === "BookText" || endType === "StickyNote")) {
        return "image-connection";
    } else if ((startType === "BookText" || startType === "StickyNote") && endType === "Image") {
        return "image-connection";
    }
    return "other";
};

// Get connection color based on type
export const getConnectionTypeColor = (startType: string, endType: string, isDarkMode: boolean) => {
    const connectionType = getConnectionType(startType, endType);
    
    switch (connectionType) {
        case "text-annotation":
            return isDarkMode 
                ? "from-indigo-900 to-indigo-800 text-indigo-100 border-indigo-700" 
                : "from-indigo-50 to-indigo-100 text-indigo-700 border-indigo-200";
        case "note-reference":
            return isDarkMode 
                ? "from-rose-900 to-rose-800 text-rose-100 border-rose-700" 
                : "from-rose-50 to-rose-100 text-rose-700 border-rose-200";
        case "text-connection":
            return isDarkMode 
                ? "from-emerald-900 to-emerald-800 text-emerald-100 border-emerald-700" 
                : "from-emerald-50 to-emerald-100 text-emerald-700 border-emerald-200";
        case "note-note":
            return isDarkMode 
                ? "from-amber-900 to-amber-800 text-amber-100 border-amber-700" 
                : "from-amber-50 to-amber-100 text-amber-700 border-amber-200";
        case "image-connection":
            return isDarkMode 
                ? "from-sky-900 to-sky-800 text-sky-100 border-sky-700" 
                : "from-sky-50 to-sky-100 text-sky-700 border-sky-200";
        default:
            return isDarkMode 
                ? "from-gray-800 to-gray-700 text-gray-200 border-gray-600" 
                : "from-gray-50 to-gray-100 text-gray-700 border-gray-200";
    }
};

// Get human-friendly connection label
export const getConnectionLabel = (startType: string, endType: string): string => {
    if (startType === "BookText" && endType === "StickyNote") {
        return "Text Annotation";
    } else if (startType === "StickyNote" && endType === "BookText") {
        return "Note Reference";
    } else if (startType === "BookText" && endType === "BookText") {
        return "Text Connection";
    } else if (startType === "StickyNote" && endType === "StickyNote") {
        return "Note-to-Note";
    } else if (startType === "Image" && endType === "BookText") {
        return "Image to Text";
    } else if (startType === "BookText" && endType === "Image") {
        return "Text to Image";
    } else if (startType === "Image" && endType === "StickyNote") {
        return "Image Annotation";
    }
    return `${startType} to ${endType}`;
};

// Truncate text to specified length
export const truncateText = (text: string, maxLength: number = 60): string => {
    if (text.length <= maxLength) return text;
    return text.substring(0, maxLength) + "...";
};

// Animation for smooth scroll
export const easeInOutCubic = (t: number): number => {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
};

// Group notes by date for timeline view
export const groupNotesByDate = (notes: Note[]): Record<string, Note[]> => {
    return notes.reduce((groups: Record<string, Note[]>, note) => {
        const date = note.createdAt ? new Date(note.createdAt).toLocaleDateString() : 'Unknown Date';
        if (!groups[date]) {
            groups[date] = [];
        }
        groups[date].push(note);
        return groups;
    }, {});
};

// Count notes by type
export const countNotesByType = (notes: Note[]): Record<string, number> => {
    return notes.reduce((counts: Record<string, number>, note) => {
        const type = getConnectionType(note.startType, note.endType);
        counts[type] = (counts[type] || 0) + 1;
        return counts;
    }, { "all": notes.length });
};

// Filter notes based on search query and active filter
export const filterNotes = (notes: Note[], searchQuery: string, activeFilter: string): Note[] => {
    return notes.filter(note => {
        const textMatch = searchQuery ? 
            (note.startText.toLowerCase().includes(searchQuery.toLowerCase()) || 
             note.endText.toLowerCase().includes(searchQuery.toLowerCase())) : 
            true;
            
        const typeMatch = activeFilter === "all" ? 
            true : 
            getConnectionType(note.startType, note.endType) === activeFilter;
            
        return textMatch && typeMatch;
    });
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-49-modules-bookpage-progressbar-tsx">File 49: Modules/BookPage/ProgressBar.tsx</h2>

```typescript
import { useEffect, useState, useCallback, useRef } from "react";
import { Slider } from "../../components/ui/slider";
import { Button } from "../../components/ui/button";
import { ChevronLeft, ChevronRight } from "lucide-react";
import { debounce } from "lodash";

type ProgressBarProps = {
  currentPage: number;
  totalPages: number;
  onNavigate: (page: number) => void;
};

export default function ProgressBar({
  currentPage,
  totalPages,
  onNavigate,
}: ProgressBarProps) {
  const [sliderValue, setSliderValue] = useState(0);
  const [displayPage, setDisplayPage] = useState(currentPage);
  const isDraggingRef = useRef(false);
  
  // Update slider when currentPage changes (only when not dragging)
  useEffect(() => {
    if (!isDraggingRef.current && totalPages > 0) {
      setSliderValue((currentPage / totalPages) * 100);
      setDisplayPage(currentPage);
    }
  }, [currentPage, totalPages]);
  
  // Super-debounced navigation function
  const debouncedNavigate = useCallback(
    debounce((page: number) => {
      onNavigate(page);
      isDraggingRef.current = false;
    }, 300),
    [onNavigate]
  );
  
  // Handle slider drag start
  const handleSliderDragStart = () => {
    isDraggingRef.current = true;
  };
  
  // Handle slider change with optimized performance
  const handleSliderChange = (value: number[]) => {
    const newValue = value[0];
    setSliderValue(newValue);
    
    // Just update the display page immediately for visual feedback
    const targetPage = Math.max(1, Math.round((newValue / 100) * totalPages));
    setDisplayPage(targetPage);
    
    // But only navigate when dragging stops
    debouncedNavigate(targetPage);
  };
  
  // Handle navigation buttons
  const handlePrevPage = () => {
    if (currentPage > 1) {
      onNavigate(currentPage - 1);
    }
  };
  
  const handleNextPage = () => {
    if (currentPage < totalPages) {
      onNavigate(currentPage + 1);
    }
  };
  
  return (
    <div className="fixed bottom-0 left-0 right-0 bg-background/80 backdrop-blur-sm border-t border-border p-3 flex items-center z-50 progress-bar-container">
      <Button 
        variant="ghost" 
        size="icon" 
        onClick={handlePrevPage}
        disabled={currentPage <= 1}
        className="text-foreground"
      >
        <ChevronLeft className="h-5 w-5" />
      </Button>
      
      <div className="flex-1 mx-4 flex items-center gap-4">
        <div 
          className="flex-1"
          onMouseDown={handleSliderDragStart}
          onTouchStart={handleSliderDragStart}
        >
          <Slider
            value={[sliderValue]}
            max={100}
            step={5}
            onValueChange={handleSliderChange}
          />
        </div>
        <span className="text-sm text-foreground whitespace-nowrap min-w-[80px] text-right">
          {displayPage} / {totalPages}
        </span>
      </div>
      
      <Button 
        variant="ghost" 
        size="icon" 
        onClick={handleNextPage}
        disabled={currentPage >= totalPages}
        className="text-foreground"
      >
        <ChevronRight className="h-5 w-5" />
      </Button>
    </div>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-50-modules-bookpage-righthand-tsx">File 50: Modules/BookPage/RightHand.tsx</h2>

```typescript
// RightHand.tsx

import { useState } from "react";
import Settings from "../Settings/Settings";
import {
    Tabs,
    TabsContent,
    TabsList,
    TabsTrigger,
} from "../../components/ui/tabs";
import { formatDistanceToNow } from "date-fns";
import { Button } from "../../components/ui/button";
import { Card, CardContent } from "../../components/ui/card";
import { Progress } from "../../components/ui/progress";
import { ChevronLeft, ChevronRight, BookOpen, Settings as SettingsIcon, FileText } from "lucide-react";
import { cn } from "../../lib/utils";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { Notes } from "./Notes/Notes";

type RightHandProps = {
    sessionActive?: boolean;
    startTime?: Date | null;
    currentPage?: number;
    totalPages?: number;
    onEndSession?: () => void;
};

export default function RightHand({
    sessionActive = false,
    startTime = null,
    currentPage = 0,
    totalPages = 0,
    onEndSession
}: RightHandProps) {
    const [selected, setSelected] = useState<"notes" | "settings">("notes");
    const [sidebarExpanded, setSidebarExpanded] = useState(true);
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    
    const toggleSidebar = () => {
        setSidebarExpanded(!sidebarExpanded);
    };

    const calculateProgress = () => {
        if (totalPages === 0) return 0;
        return Math.min(100, Math.round((currentPage / totalPages) * 100));
    };

    const formatReadingTime = () => {
        if (!startTime) return "0 minutes";
        return formatDistanceToNow(startTime, { addSuffix: false });
    };

    return (
        <div 
            className={cn(
                "flex flex-col h-screen  transition-all duration-300 ease-in-out border-l",
                isDarkMode 
                    ? "bg-zinc-900 border-gray-800" 
                    : "bg-white border-gray-200",
                sidebarExpanded ? "w-80" : "w-12"
            )}
        >
            <div className={cn(
                "flex flex-row h-14 w-full items-center justify-center border-b",
                isDarkMode ? "border-gray-800" : "border-gray-200"
            )}>
                <Button 
                    variant="ghost" 
                    size="icon"
                    className={cn(
                        "h-8 w-8 flex-shrink-0",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white" 
                            : "text-gray-600 hover:text-gray-900"
                    )}
                    onClick={toggleSidebar}
                    title={sidebarExpanded ? "Collapse sidebar" : "Expand sidebar"}
                >
                    {sidebarExpanded ? <ChevronRight size={18} /> : <ChevronLeft size={18} />}
                </Button>
                
                <div className={cn(
                    "flex-grow text-center transition-opacity duration-200 mr-8",
                    sidebarExpanded ? "opacity-100" : "opacity-0 invisible"
                )}>
                    <div className={cn(
                        "text-sm font-medium",
                        isDarkMode ? "text-gray-300" : "text-gray-800"
                    )}>
                        Tools
                    </div>
                </div>
            </div>
            
            <div className={cn(
                "overflow-hidden transition-all duration-300 ease-in-out flex-grow",
                sidebarExpanded ? "opacity-100" : "opacity-0 w-0"
            )}>
                {sidebarExpanded && (
                    <div className="flex flex-col h-full">
                        <Tabs
                            value={selected}
                            onValueChange={(value) =>
                                setSelected(value as "notes" | "settings")
                            }
                            className="flex flex-col h-full"
                        >
                            <TabsList className={cn(
                                "flex-shrink-0 p-1 mx-4 mt-4 rounded-md",
                                isDarkMode ? "bg-zinc-800" : "bg-gray-100"
                            )}>
                                <TabsTrigger 
                                    value="notes" 
                                    className={cn(
                                        "flex-1",
                                        isDarkMode 
                                            ? "data-[state=active]:bg-zinc-700 data-[state=active]:text-white text-gray-400" 
                                            : "data-[state=active]:bg-white data-[state=active]:text-gray-900 text-gray-600"
                                    )}
                                >
                                    <FileText size={16} className="mr-2" />
                                    Notes
                                </TabsTrigger>
                                <TabsTrigger 
                                    value="settings" 
                                    className={cn(
                                        "flex-1",
                                        isDarkMode 
                                            ? "data-[state=active]:bg-zinc-700 data-[state=active]:text-white text-gray-400" 
                                            : "data-[state=active]:bg-white data-[state=active]:text-gray-900 text-gray-600"
                                    )}
                                >
                                    <SettingsIcon size={16} className="mr-2" />
                                    Settings
                                </TabsTrigger>
                            </TabsList>
                            
                            <TabsContent value="notes" className="flex-grow overflow-auto p-4">
                                <Notes />
                            </TabsContent>
                            
                            <TabsContent value="settings" className="flex-grow overflow-auto p-4">
                                <Settings />
                            </TabsContent>
                        </Tabs>
                        
                        {/* Reading Session Info */}
                        {sessionActive && (
                            <div className={cn(
                                "p-4 border-t",
                                isDarkMode ? "border-gray-800" : "border-gray-200"
                            )}>
                                <Card className={cn(
                                    "border-0",
                                    isDarkMode 
                                        ? "bg-zinc-800 text-gray-300" 
                                        : "bg-gray-100 text-gray-800"
                                )}>
                                    <CardContent className="p-4 space-y-4">
                                        <div className="space-y-1">
                                            <p className={isDarkMode ? "text-xs text-gray-400" : "text-xs text-gray-600 font-medium"}>
                                                Reading Time
                                            </p>
                                            <p className={cn(
                                                "text-sm font-medium",
                                                isDarkMode ? "text-white" : "text-gray-800"
                                            )}>
                                                {formatReadingTime()}
                                            </p>
                                        </div>
                                        
                                        <div className="space-y-1">
                                            <div className="flex justify-between items-center">
                                                <p className={isDarkMode ? "text-xs text-gray-400" : "text-xs text-gray-600 font-medium"}>
                                                    Progress
                                                </p>
                                                <p className={isDarkMode ? "text-xs text-gray-400" : "text-xs text-gray-600 font-medium"}>
                                                    {currentPage} of {totalPages}
                                                </p>
                                            </div>
                                            <Progress 
                                                value={calculateProgress()} 
                                                className={cn(
                                                    "h-1.5",
                                                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                                                )}
                                                style={{
                                                    ["--progress-foreground" as any]: isDarkMode ? "#60a5fa" : "#3b82f6"
                                                }}
                                            />
                                        </div>
                                        
                                      
                                    </CardContent>
                                </Card>
                            </div>
                        )}
                    </div>
                )}
            </div>
            
            <div className={cn(
                "flex flex-col items-center justify-center transition-opacity duration-300 py-4 gap-4",
                !sidebarExpanded ? "opacity-100" : "opacity-0 invisible h-0"
            )}>
                <Button 
                    variant="ghost" 
                    size="icon"
                    className={cn(
                        "h-8 w-8",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white" 
                            : "text-gray-600 hover:text-gray-900",
                        selected === "notes" && !sidebarExpanded 
                            ? isDarkMode ? "bg-zinc-800" : "bg-gray-200" 
                            : ""
                    )}
                    onClick={() => {
                        setSidebarExpanded(true);
                        setSelected("notes");
                    }}
                    title="Notes"
                >
                    <FileText size={18} />
                </Button>
                
                <Button 
                    variant="ghost" 
                    size="icon"
                    className={cn(
                        "h-8 w-8",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white" 
                            : "text-gray-600 hover:text-gray-900",
                        selected === "settings" && !sidebarExpanded 
                            ? isDarkMode ? "bg-zinc-800" : "bg-gray-200" 
                            : ""
                    )}
                    onClick={() => {
                        setSidebarExpanded(true);
                        setSelected("settings");
                    }}
                    title="Settings"
                >
                    <SettingsIcon size={18} />
                </Button>
                
                {sessionActive && (
                    <Button 
                        variant="ghost" 
                        size="icon"
                        className={cn(
                            "h-8 w-8",
                            isDarkMode 
                                ? "text-gray-400 hover:text-white" 
                                : "text-gray-600 hover:text-gray-900"
                        )}
                        onClick={() => {
                            setSidebarExpanded(true);
                        }}
                        title="Reading Session"
                    >
                        <BookOpen size={18} />
                    </Button>
                )}
            </div>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-51-modules-bookpage-functions-preprocesstext-ts">File 51: Modules/BookPage/functions/preprocessText.ts</h2>

```typescript
import Tesseract from "tesseract.js";

// Function to preprocess text by lines across multiple pages
export const preprocessText = (
    pages: Tesseract.Page[],
) => {

    // Iterate over each page
    let allParagpraphs: Tesseract.Paragraph[] = [];
    pages.forEach((page) => {
        // Extract and filter lines from the page
        const paragraphs = page.paragraphs;
        paragraphs.forEach((paragraph) => {
            paragraph.lines =  removeLowConfidence(paragraph.lines)
            allParagpraphs.push(paragraph);
            
        });
    });

    console.log("allParagpraphs", allParagpraphs);
    return allParagpraphs;
};

// Function to filter out lines with low confidence
const removeLowConfidence = (lines: Tesseract.Line[]) => {
    return lines.filter((line) => line.confidence > 60);
};

// Function to remove extra whitespace from the text
export const removeExtraWhitespace = (text: string) => {
    // Replace multiple spaces, tabs, and newlines with a single space
    return text
        .replace(/[\s\n]+/g, " ") // Replace all whitespace including newlines with a single space
        .replace(/\s([?.!,;:])/g, "$1") // Remove space before punctuation
        .replace(/([?.!,;:])\s(?=[?.!,;:])/g, "$1") // Remove space between consecutive punctuation marks
        .trim();
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-52-modules-bookmarkspage-bookmarkspage-tsx">File 52: Modules/BookmarksPage/BookmarksPage.tsx</h2>

```typescript
import { useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { useNavigate } from "react-router-dom";
import { Book, Bookmark } from "../../endPointTypes/types";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useAuth } from "../../hooks/userAuth";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import Sidebar from "../LibraryPage/Sidebar";
import { Bookmark as BookmarkIcon, Search, Book as BookIcon, Calendar, Clock } from "lucide-react";
import { Input } from "../../components/ui/input";
import { format } from "date-fns";
import { Button } from "../../components/ui/button";

type BookmarkWithBook = Bookmark & {
  book: Book;
};

export default function BookmarksPage() {
    const { user } = useAuth();
    const navigate = useNavigate();
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [booksLoading, setBooksLoading] = useState<string[]>([]);
    const [searchQuery, setSearchQuery] = useState("");
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    // Fetch bookmarks
    const { data: bookmarks, isLoading } = useQuery({
        queryKey: ["bookmarks", user?.id],
        queryFn: async () => {
            const data = await apiFetch(
                "GET /bookmark/getUserBookmarks",
                {
                    query: {
                        userId: user?.id,
                    },
                },
                {
                    headers: {
                        Authorization: `Bearer ${localStorage.getItem("token")}`,
                    },
                }
            );
            return data.data as BookmarkWithBook[];
        },
        enabled: !!user?.id,
    });

    const toggleCollapse = () => {
        setIsCollapsed(!isCollapsed);
    };

    const navigateToBookmark = (bookmark: BookmarkWithBook) => {
        navigate(`/book?id=${bookmark.book.id}&page=${bookmark.page}&position=${bookmark.position}`);
    };

    const deleteBookmark = async (bookmarkId: string) => {
        // Implementation for removing a bookmark
        console.log("Delete bookmark:", bookmarkId);
    };

    // Filter bookmarks based on search query
    const filteredBookmarks = bookmarks?.filter(bookmark => {
        const query = searchQuery.toLowerCase();
        return (
            bookmark.book.title.toLowerCase().includes(query) ||
            bookmark.book.author.toLowerCase().includes(query) ||
            bookmark.name.toLowerCase().includes(query)
        );
    });

    return (
        <div className="flex h-screen overflow-hidden">
            <Sidebar 
                isCollapsed={isCollapsed} 
                toggleCollapse={toggleCollapse} 
                setBooksLoading={setBooksLoading} 
            />
            
            <main className={cn(
                "flex-1 overflow-y-auto p-6",
                isDarkMode ? "bg-zinc-900" : "bg-gray-50"
            )}>
                <div className="max-w-7xl mx-auto">
                    <div className="flex items-center justify-between mb-8">
                        <div className="flex items-center">
                            <BookmarkIcon className={cn(
                                "mr-3 h-8 w-8",
                                isDarkMode ? "text-purple-400" : "text-purple-600"
                            )} />
                            <h1 className={cn(
                                "text-3xl font-bold",
                                isDarkMode ? "text-white" : "text-gray-900"
                            )}>
                                Bookmarks
                            </h1>
                        </div>
                        
                        {bookmarks && bookmarks.length > 0 && (
                            <div className="relative w-64">
                                <Search className={cn(
                                    "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4",
                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                )} />
                                <Input
                                    type="text"
                                    placeholder="Search bookmarks..."
                                    value={searchQuery}
                                    onChange={(e) => setSearchQuery(e.target.value)}
                                    className={cn(
                                        "pl-10",
                                        isDarkMode 
                                            ? "bg-zinc-800 border-zinc-700" 
                                            : "bg-white border-gray-200"
                                    )}
                                />
                            </div>
                        )}
                    </div>
                    
                    {isLoading ? (
                        <div className="grid gap-4">
                            {[1, 2, 3, 4].map((i) => (
                                <BookmarkSkeleton key={i} isDarkMode={isDarkMode} />
                            ))}
                        </div>
                    ) : filteredBookmarks && filteredBookmarks.length > 0 ? (
                        <div className="grid gap-4">
                            {filteredBookmarks.map((bookmark) => (
                                <BookmarkCard
                                    key={bookmark.id}
                                    bookmark={bookmark}
                                    deleteBookmark={deleteBookmark}
                                    navigateToBookmark={navigateToBookmark}
                                    isDarkMode={isDarkMode}
                                />
                            ))}
                        </div>
                    ) : bookmarks && bookmarks.length > 0 && searchQuery ? (
                        <div className="text-center py-8">
                            <p className={isDarkMode ? "text-gray-400" : "text-gray-600"}>
                                No bookmarks match your search criteria.
                            </p>
                        </div>
                    ) : (
                        <div className={cn(
                            "text-center py-16 px-4 rounded-lg",
                            isDarkMode ? "bg-zinc-800/50" : "bg-gray-100/50"
                        )}>
                            <BookmarkIcon className={cn(
                                "mx-auto h-12 w-12 mb-4",
                                isDarkMode ? "text-gray-600" : "text-gray-400"
                            )} />
                            <h3 className={cn(
                                "text-xl font-medium mb-2",
                                isDarkMode ? "text-gray-300" : "text-gray-700"
                            )}>
                                No bookmarks yet
                            </h3>
                            <p className={cn(
                                "mb-6 max-w-md mx-auto",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                            )}>
                                Add bookmarks while reading to save your place and quickly return to important sections.
                            </p>
                            <button
                                onClick={() => navigate('/')}
                                className={cn(
                                    "px-4 py-2 rounded-md font-medium",
                                    isDarkMode 
                                        ? "bg-blue-600 hover:bg-blue-700 text-white" 
                                        : "bg-blue-500 hover:bg-blue-600 text-white"
                                )}
                            >
                                Go to Library
                            </button>
                        </div>
                    )}
                </div>
            </main>
        </div>
    );
}

// Bookmark Card Component
function BookmarkCard({ 
    bookmark, 
    deleteBookmark, 
    navigateToBookmark,
    isDarkMode
}: { 
    bookmark: BookmarkWithBook; 
    deleteBookmark: (id: string) => Promise<void>;
    navigateToBookmark: (bookmark: BookmarkWithBook) => void;
    isDarkMode: boolean;
}) {
    return (
        <div 
            className={cn(
                "p-4 rounded-lg border transition-all hover:shadow-md",
                isDarkMode 
                    ? "bg-zinc-800 border-zinc-700 hover:bg-zinc-700" 
                    : "bg-white border-gray-200 hover:bg-gray-50"
            )}
        >
            <div className="flex items-start gap-4">
                {bookmark.book.coverImage ? (
                    <img 
                        src={bookmark.book.coverImage} 
                        alt={bookmark.book.title}
                        className="w-16 h-24 object-cover rounded"
                    />
                ) : (
                    <div className={cn(
                        "w-16 h-24 flex items-center justify-center rounded",
                        isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                    )}>
                        <BookIcon className={isDarkMode ? "text-zinc-500" : "text-gray-400"} />
                    </div>
                )}
                
                <div className="flex-1">
                    <h3 className={cn(
                        "font-medium mb-1",
                        isDarkMode ? "text-white" : "text-gray-900"
                    )}>
                        {bookmark.name || `Page ${bookmark.page}`}
                    </h3>
                    
                    <p className={cn(
                        "text-sm mb-2",
                        isDarkMode ? "text-gray-300" : "text-gray-700"
                    )}>
                        {bookmark.book.title} by {bookmark.book.author}
                    </p>
                    
                    <div className="flex items-center gap-4 text-xs mb-3">
                        <div className={cn(
                            "flex items-center",
                            isDarkMode ? "text-gray-400" : "text-gray-600"
                        )}>
                            <Calendar className="h-3 w-3 mr-1" />
                            {bookmark.createdAt ? format(new Date(bookmark.createdAt), 'MMM d, yyyy') : 'Unknown date'}
                        </div>
                        
                        <div className={cn(
                            "flex items-center",
                            isDarkMode ? "text-gray-400" : "text-gray-600"
                        )}>
                            <Clock className="h-3 w-3 mr-1" />
                            Page {bookmark.page}
                        </div>
                    </div>
                    
                    <div className="flex justify-end gap-2">
                        <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => deleteBookmark(bookmark.id)}
                            className={isDarkMode ? "border-zinc-700 hover:bg-zinc-700" : ""}
                        >
                            Delete
                        </Button>
                        <Button 
                            size="sm"
                            onClick={() => navigateToBookmark(bookmark)}
                        >
                            Go to bookmark
                        </Button>
                    </div>
                </div>
            </div>
        </div>
    );
}

// Bookmark Skeleton Component
function BookmarkSkeleton({ isDarkMode }: { isDarkMode: boolean }) {
    return (
        <div className={cn(
            "p-4 rounded-lg border animate-pulse",
            isDarkMode ? "bg-zinc-800 border-zinc-700" : "bg-white border-gray-200"
        )}>
            <div className="flex items-start gap-4">
                <div className={cn(
                    "w-16 h-24 rounded",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                )} />
                
                <div className="flex-1">
                    <div className={cn(
                        "h-5 rounded mb-2 w-3/4",
                        isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                    )} />
                    
                    <div className={cn(
                        "h-4 rounded mb-3 w-1/2",
                        isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                    )} />
                    
                    <div className="flex items-center gap-4 mb-3">
                        <div className={cn(
                            "h-3 rounded w-20",
                            isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                        )} />
                        
                        <div className={cn(
                            "h-3 rounded w-16",
                            isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                        )} />
                    </div>
                    
                    <div className="flex justify-end gap-2">
                        <div className={cn(
                            "h-8 rounded w-16",
                            isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                        )} />
                        <div className={cn(
                            "h-8 rounded w-28",
                            isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                        )} />
                    </div>
                </div>
            </div>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-53-modules-collectionspage-components-collectioncard-tsx">File 53: Modules/CollectionsPage/components/CollectionCard.tsx</h2>

```typescript
import { FolderHeart, MoreHorizontal, Edit, Trash2, LayoutGrid } from "lucide-react";
import { useNavigate } from "react-router-dom";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { cn } from "../../../lib/utils";
import { Collection } from "../../../api/collectionsApi";
import { formatDistanceToNow } from "date-fns";
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuSeparator, 
  DropdownMenuTrigger 
} from "../../../components/ui/dropdown-menu";
import { Button } from "../../../components/ui/button";

interface CollectionCardProps {
  collection: Collection;
  onEdit: (collection: Collection) => void;
  onDelete: (id: string) => void;
  viewMode?: "grid" | "list";
}

export default function CollectionCard({ 
  collection, 
  onEdit, 
  onDelete, 
  viewMode = "grid" 
}: CollectionCardProps) {
  const navigate = useNavigate();
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";

  const handleViewCollection = () => {
    navigate(`/collections/${collection.id}`);
  };

  const formatDate = (dateString: string) => {
    try {
      return formatDistanceToNow(new Date(dateString), { addSuffix: true });
    } catch (error) {
      return "Unknown date";
    }
  };

  if (viewMode === "grid") {
    return (
      <div 
        className={cn(
          "rounded-lg border overflow-hidden transition-all hover:shadow-md",
          isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white",
          "cursor-pointer group"
        )}
      >
        <div 
          className="relative pb-[60%] bg-gradient-to-br from-amber-100 to-amber-200"
          onClick={handleViewCollection}
        >
          {collection.imageUrl ? (
            <img 
              src={collection.imageUrl} 
              alt={collection.name}
              className="absolute w-full h-full object-cover"
            />
          ) : (
            <div className="absolute inset-0 flex items-center justify-center">
              <FolderHeart className={cn(
                "h-16 w-16",
                isDarkMode ? "text-amber-500/30" : "text-amber-500/60"
              )} />
            </div>
          )}
          
          <div className="absolute top-2 right-2">
            <DropdownMenu>
              <DropdownMenuTrigger asChild onClick={e => e.stopPropagation()}>
                <Button 
                  variant="ghost" 
                  size="icon"
                  className={cn(
                    "h-8 w-8 rounded-full bg-white/80 hover:bg-white opacity-0 group-hover:opacity-100 transition-opacity",
                    isDarkMode && "text-gray-800"
                  )}
                >
                  <MoreHorizontal className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
                <DropdownMenuItem 
                  onClick={(e) => {
                    e.stopPropagation();
                    onEdit(collection);
                  }}
                  className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
                >
                  <Edit className="mr-2 h-4 w-4" />
                  Edit
                </DropdownMenuItem>
                <DropdownMenuSeparator className={isDarkMode ? "bg-gray-700" : ""} />
                <DropdownMenuItem 
                  onClick={(e) => {
                    e.stopPropagation();
                    onDelete(collection.id);
                  }}
                  className={cn(
                    "text-red-600 focus:text-red-600",
                    isDarkMode ? "focus:bg-gray-700" : ""
                  )}
                >
                  <Trash2 className="mr-2 h-4 w-4" />
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>
        
        <div 
          className="p-3"
          onClick={handleViewCollection}
        >
          <h3 className={cn(
            "font-medium mb-1 truncate",
            isDarkMode ? "text-gray-100" : ""
          )}>
            {collection.name}
          </h3>
          
          {collection.description && (
            <p className={cn(
              "text-sm line-clamp-2 mb-2",
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )}>
              {collection.description}
            </p>
          )}
          
          <div className="flex items-center justify-between mt-2 text-xs">
            <span className={cn(
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )}>
              {collection.bookCount || 0} {(collection.bookCount === 1) ? "book" : "books"}
            </span>
            <span className={cn(
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )}>
              {formatDate(collection.createdAt)}
            </span>
          </div>
        </div>
      </div>
    );
  } else {
    // List view
    return (
      <div 
        className={cn(
          "flex items-center p-3 rounded-lg border transition-all hover:shadow-sm cursor-pointer",
          isDarkMode 
            ? "bg-gray-800 border-gray-700 hover:border-amber-600/50" 
            : "hover:border-amber-500/50"
        )}
        onClick={handleViewCollection}
      >
        <div className={cn(
          "h-12 w-12 rounded-md flex items-center justify-center mr-3",
          isDarkMode ? "bg-gray-700" : "bg-amber-100"
        )}>
          {collection.imageUrl ? (
            <img 
              src={collection.imageUrl} 
              alt={collection.name}
              className="w-full h-full object-cover rounded-md"
            />
          ) : (
            <FolderHeart className={cn(
              "h-6 w-6",
              isDarkMode ? "text-amber-500/30" : "text-amber-500/50"
            )} />
          )}
        </div>
        
        <div className="flex-grow min-w-0">
          <h3 className={cn(
            "font-medium truncate",
            isDarkMode ? "text-gray-100" : ""
          )}>
            {collection.name}
          </h3>
          
          {collection.description && (
            <p className={cn(
              "text-sm truncate",
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )}>
              {collection.description}
            </p>
          )}
        </div>
        
        <div className={cn(
          "text-sm mr-4",
          isDarkMode ? "text-gray-400" : "text-gray-500"
        )}>
          {collection.bookCount || 0} {(collection.bookCount === 1) ? "book" : "books"}
        </div>
        
        <div className={cn(
          "text-sm mr-4",
          isDarkMode ? "text-gray-400" : "text-gray-500"
        )}>
          {formatDate(collection.createdAt)}
        </div>
        
        <DropdownMenu>
          <DropdownMenuTrigger asChild onClick={e => e.stopPropagation()}>
            <Button 
              variant="ghost" 
              size="icon"
              className={cn(
                "h-8 w-8 rounded-full",
                isDarkMode ? "text-gray-400 hover:text-white hover:bg-gray-700" : ""
              )}
            >
              <MoreHorizontal className="h-4 w-4" />
            </Button>
          </DropdownMenuTrigger>
          <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
            <DropdownMenuItem 
              onClick={(e) => {
                e.stopPropagation();
                onEdit(collection);
              }}
              className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
            >
              <Edit className="mr-2 h-4 w-4" />
              Edit
            </DropdownMenuItem>
            <DropdownMenuSeparator className={isDarkMode ? "bg-gray-700" : ""} />
            <DropdownMenuItem 
              onClick={(e) => {
                e.stopPropagation();
                onDelete(collection.id);
              }}
              className={cn(
                "text-red-600 focus:text-red-600",
                isDarkMode ? "focus:bg-gray-700" : ""
              )}
            >
              <Trash2 className="mr-2 h-4 w-4" />
              Delete
            </DropdownMenuItem>
          </DropdownMenuContent>
        </DropdownMenu>
      </div>
    );
  }
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-54-modules-collectionspage-components-collectionform-tsx">File 54: Modules/CollectionsPage/components/CollectionForm.tsx</h2>

```typescript
import { useState, useEffect } from "react";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { cn } from "../../../lib/utils";
import { Collection, CollectionFormData } from "../../../api/collectionsApi";
import { Input } from "../../../components/ui/input";
import { Textarea } from "../../../components/ui/textarea";
import { Button } from "../../../components/ui/button";
import { Label } from "../../../components/ui/label";

interface CollectionFormProps {
  collection?: Collection;
  onSubmit: (data: CollectionFormData) => void;
  onCancel: () => void;
  isSubmitting: boolean;
}

export default function CollectionForm({ 
  collection, 
  onSubmit, 
  onCancel,
  isSubmitting 
}: CollectionFormProps) {
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const [name, setName] = useState("");
  const [description, setDescription] = useState("");
  const [imageUrl, setImageUrl] = useState("");
  const [errors, setErrors] = useState<{[key: string]: string}>({});

  useEffect(() => {
    if (collection) {
      setName(collection.name);
      setDescription(collection.description || "");
      setImageUrl(collection.imageUrl || "");
    }
  }, [collection]);

  const validate = () => {
    const newErrors: {[key: string]: string} = {};
    
    if (!name.trim()) {
      newErrors.name = "Collection name is required";
    }
    
    // URL validation (optional field)
    if (imageUrl && !isValidUrl(imageUrl)) {
      newErrors.imageUrl = "Please enter a valid URL";
    }
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };
  
  const isValidUrl = (url: string) => {
    try {
      new URL(url);
      return true;
    } catch (error) {
      return false;
    }
  };

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    
    if (validate()) {
      onSubmit({
        name: name.trim(),
        description: description.trim() || undefined,
        imageUrl: imageUrl.trim() || undefined
      });
    }
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <div className="space-y-2">
        <Label htmlFor="name" className={isDarkMode ? "text-gray-200" : ""}>
          Collection Name *
        </Label>
        <Input 
          id="name"
          value={name}
          onChange={(e) => setName(e.target.value)}
          placeholder="My Favorite Books"
          className={cn(
            errors.name && "border-red-500",
            isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
          )}
          maxLength={100}
        />
        {errors.name && (
          <p className="text-red-500 text-sm mt-1">{errors.name}</p>
        )}
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="description" className={isDarkMode ? "text-gray-200" : ""}>
          Description
        </Label>
        <Textarea 
          id="description"
          value={description}
          onChange={(e) => setDescription(e.target.value)}
          placeholder="A brief description of this collection"
          className={cn(
            isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
          )}
          rows={3}
          maxLength={500}
        />
      </div>
      
      <div className="space-y-2">
        <Label htmlFor="imageUrl" className={isDarkMode ? "text-gray-200" : ""}>
          Cover Image URL
        </Label>
        <Input 
          id="imageUrl"
          value={imageUrl}
          onChange={(e) => setImageUrl(e.target.value)}
          placeholder="https://example.com/image.jpg"
          className={cn(
            errors.imageUrl && "border-red-500",
            isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
          )}
        />
        {errors.imageUrl && (
          <p className="text-red-500 text-sm mt-1">{errors.imageUrl}</p>
        )}
        {imageUrl && !errors.imageUrl && (
          <div className="mt-2 rounded-md overflow-hidden border h-24 w-24">
            <img 
              src={imageUrl} 
              alt="Cover preview" 
              className="h-full w-full object-cover"
              onError={() => setErrors({...errors, imageUrl: "Invalid image URL"})}
            />
          </div>
        )}
      </div>
      
      <div className="flex justify-end space-x-2 pt-2">
        <Button
          type="button"
          variant="outline"
          onClick={onCancel}
          className={isDarkMode ? "border-gray-700 text-gray-300 hover:bg-gray-800" : ""}
        >
          Cancel
        </Button>
        <Button 
          type="submit"
          disabled={isSubmitting}
          className="bg-amber-600 hover:bg-amber-700 text-white"
        >
          {isSubmitting ? "Saving..." : (collection ? "Update Collection" : "Create Collection")}
        </Button>
      </div>
    </form>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-55-modules-collectionspage-components-collectionslist-tsx">File 55: Modules/CollectionsPage/components/CollectionsList.tsx</h2>

```typescript
import { useState } from "react";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { cn } from "../../../lib/utils";
import { Collection } from "../../../api/collectionsApi";
import { FolderHeart, Grid, List, SortAsc, SortDesc } from "lucide-react";
import { Input } from "../../../components/ui/input";
import { Button } from "../../../components/ui/button";
import { Separator } from "../../../components/ui/separator";
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from "../../../components/ui/dropdown-menu";
import CollectionCard from "./CollectionCard";

type SortOption = "name" | "dateCreated" | "bookCount";
type SortDirection = "asc" | "desc";

interface CollectionsListProps {
  collections: Collection[];
  isLoading: boolean;
  onCreateCollection: () => void;
  onEditCollection: (collection: Collection) => void;
  onDeleteCollection: (id: string) => void;
}

export default function CollectionsList({
  collections,
  isLoading,
  onCreateCollection,
  onEditCollection,
  onDeleteCollection
}: CollectionsListProps) {
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const [searchQuery, setSearchQuery] = useState("");
  const [sortBy, setSortBy] = useState<SortOption>("dateCreated");
  const [sortDirection, setSortDirection] = useState<SortDirection>("desc");
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");

  const filteredCollections = collections
    .filter(collection => 
      collection.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
      (collection.description && collection.description.toLowerCase().includes(searchQuery.toLowerCase()))
    )
    .sort((a, b) => {
      let comparison = 0;
      
      if (sortBy === "name") {
        comparison = a.name.localeCompare(b.name);
      } else if (sortBy === "dateCreated") {
        comparison = new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
      } else if (sortBy === "bookCount") {
        comparison = (a.bookCount || 0) - (b.bookCount || 0);
      }
      
      return sortDirection === "asc" ? comparison : -comparison;
    });

  // Render loading state
  if (isLoading) {
    return (
      <div className="space-y-4">
        <div className="flex justify-between">
          <div className="w-64 h-10 bg-gray-200 animate-pulse rounded-md"></div>
          <div className="flex space-x-2">
            <div className="w-24 h-10 bg-gray-200 animate-pulse rounded-md"></div>
            <div className="w-10 h-10 bg-gray-200 animate-pulse rounded-md"></div>
          </div>
        </div>
        
        <div className={cn(
          "grid gap-4 animate-pulse",
          viewMode === "grid" ? "grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4" : ""
        )}>
          {[1, 2, 3, 4, 5, 6].map((i) => (
            <div 
              key={i} 
              className={cn(
                "rounded-lg border",
                isDarkMode ? "bg-gray-800 border-gray-700" : "bg-gray-100"
              )}
            >
              <div className="pb-[60%] relative bg-gray-200"></div>
              <div className="p-3 space-y-2">
                <div className="h-5 bg-gray-200 rounded w-3/4"></div>
                <div className="h-8 bg-gray-200 rounded w-full"></div>
                <div className="flex justify-between">
                  <div className="h-4 bg-gray-200 rounded w-16"></div>
                  <div className="h-4 bg-gray-200 rounded w-24"></div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="flex flex-col sm:flex-row justify-between gap-2">
        <div className="relative">
          <Input
            placeholder="Search collections..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className={cn(
              "pl-10 w-full sm:w-64",
              isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
            )}
          />
          <FolderHeart className={cn(
            "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4",
            isDarkMode ? "text-gray-400" : "text-gray-500"
          )} />
        </div>
        
        <div className="flex items-center space-x-2">
          <Button
            variant="outline"
            onClick={onCreateCollection}
            className={cn(
              "bg-amber-600 hover:bg-amber-700 text-white border-0"
            )}
          >
            Create Collection
          </Button>
          
          {/* Sort options */}
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="outline"
                className={cn(
                  isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
                )}
              >
                {sortDirection === "asc" ? (
                  <SortAsc className="h-4 w-4 mr-1" />
                ) : (
                  <SortDesc className="h-4 w-4 mr-1" />
                )}
                Sort
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
              <DropdownMenuItem 
                onClick={() => setSortBy("name")}
                className={cn(
                  sortBy === "name" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                  isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                )}
              >
                Name
              </DropdownMenuItem>
              <DropdownMenuItem 
                onClick={() => setSortBy("dateCreated")}
                className={cn(
                  sortBy === "dateCreated" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                  isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                )}
              >
                Date Created
              </DropdownMenuItem>
              <DropdownMenuItem 
                onClick={() => setSortBy("bookCount")}
                className={cn(
                  sortBy === "bookCount" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                  isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                )}
              >
                Book Count
              </DropdownMenuItem>
              <Separator className={isDarkMode ? "bg-gray-700" : ""} />
              <DropdownMenuItem 
                onClick={() => setSortDirection(sortDirection === "asc" ? "desc" : "asc")}
                className={isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""}
              >
                {sortDirection === "asc" ? (
                  <SortDesc className="mr-2 h-4 w-4" />
                ) : (
                  <SortAsc className="mr-2 h-4 w-4" />
                )}
                {sortDirection === "asc" ? "Descending" : "Ascending"}
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          
          {/* View toggle */}
          <div className={cn(
            "rounded-md border flex p-1",
            isDarkMode ? "bg-gray-800 border-gray-700" : "bg-gray-100"
          )}>
            <Button
              size="sm"
              variant="ghost"
              className={cn(
                "px-2 py-1 h-auto",
                viewMode === "grid" 
                  ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                  : (isDarkMode ? "text-gray-400" : "text-gray-500")
              )}
              onClick={() => setViewMode("grid")}
            >
              <Grid className="h-4 w-4" />
            </Button>
            <Button
              size="sm"
              variant="ghost"
              className={cn(
                "px-2 py-1 h-auto",
                viewMode === "list" 
                  ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                  : (isDarkMode ? "text-gray-400" : "text-gray-500")
              )}
              onClick={() => setViewMode("list")}
            >
              <List className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </div>

      {/* Empty state */}
      {filteredCollections.length === 0 && (
        <div className={cn(
          "flex flex-col items-center justify-center py-16 text-center",
          isDarkMode ? "bg-gray-800/50" : "bg-gray-100/50",
          "rounded-lg border",
          isDarkMode ? "border-gray-700" : "border-gray-200"
        )}>
          <FolderHeart className={cn(
            "h-16 w-16 mb-4",
            isDarkMode ? "text-gray-700" : "text-gray-300"
          )} />
          <h3 className={cn(
            "text-xl font-medium mb-2",
            isDarkMode ? "text-white" : "text-gray-800"
          )}>
            {searchQuery ? "No collections found" : "No collections yet"}
          </h3>
          <p className={cn(
            "mb-6 max-w-md mx-auto",
            isDarkMode ? "text-gray-400" : "text-gray-600"
          )}>
            {searchQuery 
              ? "Try changing your search query to find your collections." 
              : "Create your first collection to organize your books in a way that makes sense to you."}
          </p>
          {!searchQuery && (
            <Button
              onClick={onCreateCollection}
              className="bg-amber-600 hover:bg-amber-700 text-white"
            >
              Create Collection
            </Button>
          )}
        </div>
      )}

      {/* Collections grid/list */}
      {filteredCollections.length > 0 && (
        viewMode === "grid" ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-4">
            {filteredCollections.map(collection => (
              <CollectionCard
                key={collection.id}
                collection={collection}
                onEdit={onEditCollection}
                onDelete={onDeleteCollection}
                viewMode="grid"
              />
            ))}
          </div>
        ) : (
          <div className="space-y-3">
            {filteredCollections.map(collection => (
              <CollectionCard
                key={collection.id}
                collection={collection}
                onEdit={onEditCollection}
                onDelete={onDeleteCollection}
                viewMode="list"
              />
            ))}
          </div>
        )
      )}
    </div>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-56-modules-collectionspage-index-ts">File 56: Modules/CollectionsPage/index.ts</h2>

```typescript
import CollectionsPage from './pages/CollectionsPage';
import CollectionDetailPage from './pages/CollectionDetailPage';

export { CollectionsPage, CollectionDetailPage }; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-57-modules-collectionspage-pages-collectiondetailpage-tsx">File 57: Modules/CollectionsPage/pages/CollectionDetailPage.tsx</h2>

```typescript
import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useParams, useNavigate } from "react-router-dom";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { useAuth } from "../../../hooks/userAuth";
import { cn } from "../../../lib/utils";
import { 
  fetchCollectionById, 
  removeBookFromCollection,
  updateCollection,
  deleteCollection,
  addBookToCollection
} from "../../../api/collectionsApi";
import { Book } from "../../../endPointTypes/types";
import { apiFetch } from "../../../endPointTypes/apiClient";
import { 
  FolderHeart, 
  ChevronLeft, 
  Edit, 
  Trash2, 
  MoreHorizontal, 
  Grid, 
  List,
  BookOpen,
  X,
  Clock,
  Search,
  Plus
} from "lucide-react";
import { 
  Dialog, 
  DialogContent, 
  DialogDescription, 
  DialogFooter, 
  DialogHeader, 
  DialogTitle 
} from "../../../components/ui/dialog";
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuSeparator, 
  DropdownMenuTrigger 
} from "../../../components/ui/dropdown-menu";
import { Button } from "../../../components/ui/button";
import { Input } from "../../../components/ui/input";
import { Separator } from "../../../components/ui/separator";
import { Alert, AlertDescription } from "../../../components/ui/alert";
import { Card, CardContent } from "../../../components/ui/card";
import CollectionForm from "../components/CollectionForm";
import { formatDistance, formatDistanceToNow } from "date-fns";
import Sidebar from "../../LibraryPage/Sidebar";

export default function CollectionDetailPage() {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const { user, accessToken } = useAuth();
  const queryClient = useQueryClient();
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const [viewMode, setViewMode] = useState<"grid" | "list">("grid");
  const [searchQuery, setSearchQuery] = useState("");
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [showRemoveBookDialog, setShowRemoveBookDialog] = useState(false);
  const [showAddBookDialog, setShowAddBookDialog] = useState(false);
  const [selectedBookId, setSelectedBookId] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [availableBooks, setAvailableBooks] = useState<Book[]>([]);
  const [bookSearchQuery, setBookSearchQuery] = useState("");

  // Fetch collection data
  const { data: collectionData, isLoading } = useQuery({
    queryKey: ["collection", id],
    queryFn: () => fetchCollectionById(id!, accessToken!),
    enabled: !!id && !!accessToken,
  });

  const collection = collectionData?.success ? collectionData.data : null;

  // Fetch available books for adding to collection
  const fetchAvailableBooks = async () => {
    try {
      const response = await apiFetch(
        "GET /book/getUserBooks",
        { query: { userId: user?.id } },
        { headers: { Authorization: `Bearer ${accessToken}` } }
      );
      
      // Filter out books already in the collection
      if (response.data && collection?.books) {
        const collectionBookIds = collection.books.map(book => book.id);
        return response.data.filter((book: Book) => !collectionBookIds.includes(book.id));
      }
      
      return response.data || [];
    } catch (error) {
      console.error("Error fetching available books:", error);
      return [];
    }
  };

  useEffect(() => {
    if (showAddBookDialog) {
      fetchAvailableBooks().then(setAvailableBooks);
    }
  }, [showAddBookDialog, collection]);

  // Update collection mutation
  const updateMutation = useMutation({
    mutationFn: (data: any) => updateCollection(id!, data, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collection", id] });
      setShowEditDialog(false);
    },
    onError: (error) => {
      setError("Failed to update collection");
      console.error("Update error:", error);
    }
  });

  // Delete collection mutation
  const deleteMutation = useMutation({
    mutationFn: () => deleteCollection(id!, accessToken!),
    onSuccess: () => {
      navigate("/collections");
    },
    onError: (error) => {
      setError("Failed to delete collection");
      console.error("Delete error:", error);
    }
  });

  // Remove book from collection mutation
  const removeBookMutation = useMutation({
    mutationFn: (bookId: string) => removeBookFromCollection(id!, bookId, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collection", id] });
      setShowRemoveBookDialog(false);
      setSelectedBookId(null);
    },
    onError: (error) => {
      setError("Failed to remove book from collection");
      console.error("Remove book error:", error);
    }
  });

  // Add book to collection mutation
  const addBookMutation = useMutation({
    mutationFn: (bookId: string) => addBookToCollection(id!, bookId, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collection", id] });
      setShowAddBookDialog(false);
    },
    onError: (error) => {
      setError("Failed to add book to collection");
      console.error("Add book error:", error);
    }
  });

  // Filter books by search query
  const filteredBooks = collection?.books?.filter(book => 
    book.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
    book.author.toLowerCase().includes(searchQuery.toLowerCase()) ||
    book.genres?.some(genre => genre.toLowerCase().includes(searchQuery.toLowerCase()))
  ) || [];

  // Filter available books by search query
  const filteredAvailableBooks = availableBooks.filter(book =>
    book.title.toLowerCase().includes(bookSearchQuery.toLowerCase()) ||
    book.author.toLowerCase().includes(bookSearchQuery.toLowerCase())
  );

  if (isLoading) {
    return (
      <div className="container mx-auto px-4 py-8 animate-pulse">
        <Sidebar />
        <div className="flex items-center mb-6">
          <div className="h-10 w-10 bg-gray-200 rounded-full mr-4"></div>
          <div className="h-8 bg-gray-200 rounded w-64"></div>
        </div>
        <div className="h-6 bg-gray-200 rounded w-full max-w-2xl mb-8"></div>
        <div className="flex justify-between mb-6">
          <div className="h-10 w-64 bg-gray-200 rounded"></div>
          <div className="flex space-x-2">
            <div className="h-10 w-20 bg-gray-200 rounded"></div>
            <div className="h-10 w-10 bg-gray-200 rounded"></div>
          </div>
        </div>
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
          {Array(8).fill(0).map((_, index) => (
            <div key={index} className="rounded-lg border overflow-hidden">
              <div className="h-48 bg-gray-200"></div>
              <div className="p-4 space-y-2">
                <div className="h-6 bg-gray-200 rounded w-3/4"></div>
                <div className="h-4 bg-gray-200 rounded w-1/2"></div>
              </div>
            </div>
          ))}
        </div>
      </div>
    );
  }

  if (!collection) {
    return (
      <div className="container mx-auto px-4 py-8">
        <div className={cn(
          "p-6 rounded-lg border",
          isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
        )}>
          <h2 className={cn(
            "text-xl font-bold mb-4",
            isDarkMode ? "text-white" : "text-gray-800"
          )}>
            Collection not found
          </h2>
          <p className={cn(
            "mb-6",
            isDarkMode ? "text-gray-300" : "text-gray-600"
          )}>
            The collection you're looking for doesn't exist or you don't have permission to view it.
          </p>
          <Button
            onClick={() => navigate('/collections')}
            className="bg-amber-600 hover:bg-amber-700 text-white"
          >
            <ChevronLeft className="mr-2 h-4 w-4" />
            Back to Collections
          </Button>
        </div>
      </div>
    );
  }

  const handleOpenRemoveDialog = (bookId: string) => {
    setSelectedBookId(bookId);
    setShowRemoveBookDialog(true);
  };

  const handleRemoveBook = () => {
    if (selectedBookId) {
      removeBookMutation.mutate(selectedBookId);
    }
  };

  const handleAddBook = (bookId: string) => {
    addBookMutation.mutate(bookId);
  };

  const formatDate = (dateString: string) => {
    try {
      return formatDistanceToNow(new Date(dateString), { addSuffix: true });
    } catch (error) {
      return "Unknown date";
    }
  };

  return (
    <div className={cn(
      "min-h-screen pb-10",
      isDarkMode ? "bg-gray-900 text-gray-100" : "bg-gray-50 text-gray-900"
    )}>
      <div className="container mx-auto px-4 py-8">
        {/* Header with back button */}
        <div className="flex items-center mb-6">
          <Button
            variant="ghost"
            size="sm"
            className={cn(
              "mr-4",
              isDarkMode ? "text-gray-300 hover:text-white hover:bg-gray-800" : ""
            )}
            onClick={() => navigate('/collections')}
          >
            <ChevronLeft className="h-5 w-5" />
          </Button>
          
          <div className="flex-1">
            <h1 className="text-2xl sm:text-3xl font-bold">{collection.name}</h1>
            {collection.description && (
              <p className={cn(
                "mt-1 text-sm sm:text-base",
                isDarkMode ? "text-gray-400" : "text-gray-600"
              )}>
                {collection.description}
              </p>
            )}
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button
                variant="ghost"
                size="icon"
                className={isDarkMode ? "text-gray-300 hover:text-white hover:bg-gray-800" : ""}
              >
                <MoreHorizontal className="h-5 w-5" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
              <DropdownMenuItem 
                onClick={() => setShowEditDialog(true)}
                className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
              >
                <Edit className="mr-2 h-4 w-4" />
                Edit Collection
              </DropdownMenuItem>
              <DropdownMenuSeparator className={isDarkMode ? "bg-gray-700" : ""} />
              <DropdownMenuItem 
                onClick={() => setShowDeleteDialog(true)}
                className={cn(
                  "text-red-600 focus:text-red-600",
                  isDarkMode ? "focus:bg-gray-700" : ""
                )}
              >
                <Trash2 className="mr-2 h-4 w-4" />
                Delete Collection
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
        
        {/* Books count and creation date */}
        <div className={cn(
          "mb-6 text-sm flex items-center",
          isDarkMode ? "text-gray-400" : "text-gray-600"
        )}>
          <BookOpen className="h-4 w-4 mr-1" />
          <span className="mr-4">{filteredBooks.length} {filteredBooks.length === 1 ? 'book' : 'books'}</span>
          <Clock className="h-4 w-4 mr-1" />
          <span>Created {formatDate(collection.createdAt)}</span>
        </div>

        {/* Action bar with search, view toggle and add book button */}
        <div className="flex flex-col sm:flex-row justify-between gap-3 mb-6">
          <div className="relative">
            <Input
              placeholder="Search books in this collection..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className={cn(
                "pl-10 w-full sm:w-64",
                isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
              )}
            />
            <Search className={cn(
              "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4",
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )} />
          </div>
          
          <div className="flex items-center gap-2">
            {/* View toggle */}
            <div className={cn(
              "rounded-md border flex p-1",
              isDarkMode ? "bg-gray-800 border-gray-700" : "bg-gray-100 border-gray-200"
            )}>
              <Button
                size="sm"
                variant="ghost"
                className={cn(
                  "px-2 py-1 h-auto",
                  viewMode === "grid" 
                    ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                    : (isDarkMode ? "text-gray-400" : "text-gray-500")
                )}
                onClick={() => setViewMode("grid")}
              >
                <Grid className="h-4 w-4" />
              </Button>
              <Button
                size="sm"
                variant="ghost"
                className={cn(
                  "px-2 py-1 h-auto",
                  viewMode === "list" 
                    ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                    : (isDarkMode ? "text-gray-400" : "text-gray-500")
                )}
                onClick={() => setViewMode("list")}
              >
                <List className="h-4 w-4" />
              </Button>
            </div>
            
            {/* Add book button */}
            <Button 
              className="bg-amber-600 hover:bg-amber-700 text-white"
              onClick={() => setShowAddBookDialog(true)}
            >
              <Plus className="h-4 w-4 mr-2" />
              Add Books
            </Button>
          </div>
        </div>
        
        {/* Empty state */}
        {filteredBooks.length === 0 && (
          <div className={cn(
            "text-center py-12 px-4 rounded-lg border",
            isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
          )}>
            <BookOpen className={cn(
              "h-12 w-12 mx-auto mb-4",
              isDarkMode ? "text-gray-600" : "text-gray-300"
            )} />
            
            {searchQuery ? (
              <>
                <h3 className="text-lg font-medium mb-2">No books found</h3>
                <p className={cn(
                  "max-w-md mx-auto mb-6",
                  isDarkMode ? "text-gray-400" : "text-gray-500"
                )}>
                  No books match your search query. Try a different search term.
                </p>
                <Button 
                  variant="outline" 
                  onClick={() => setSearchQuery("")}
                  className={isDarkMode ? "border-gray-700 text-gray-300" : ""}
                >
                  Clear Search
                </Button>
              </>
            ) : (
              <>
                <h3 className="text-lg font-medium mb-2">This collection is empty</h3>
                <p className={cn(
                  "max-w-md mx-auto mb-6",
                  isDarkMode ? "text-gray-400" : "text-gray-500"
                )}>
                  Add books to this collection to organize your library.
                </p>
                <Button 
                  className="bg-amber-600 hover:bg-amber-700 text-white"
                  onClick={() => setShowAddBookDialog(true)}
                >
                  <Plus className="h-4 w-4 mr-2" />
                  Add Books
                </Button>
              </>
            )}
          </div>
        )}
        
        {/* Books grid/list view */}
        {filteredBooks.length > 0 && (
          <>
            {viewMode === "grid" ? (
              <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                {filteredBooks.map(book => (
                  <Card key={book.id} className={cn(
                    "overflow-hidden transition-all hover:shadow-md",
                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white"
                  )}>
                    <div className="relative aspect-[2/3] w-full overflow-hidden bg-gradient-to-b from-amber-100 to-amber-200">
                      {book.imageUrl ? (
                        <img 
                          src={book.imageUrl} 
                          alt={book.title}
                          className="h-full w-full object-cover transition-all hover:scale-105"
                        />
                      ) : (
                        <div className="flex h-full items-center justify-center">
                          <BookOpen className="h-12 w-12 text-amber-600/60" />
                        </div>
                      )}
                    </div>
                    <CardContent className={cn(
                      "p-4 relative",
                      isDarkMode ? "text-gray-100" : ""
                    )}>
                      <h3 className="font-semibold line-clamp-1">{book.title}</h3>
                      <p className={cn(
                        "text-sm line-clamp-1",
                        isDarkMode ? "text-gray-400" : "text-gray-600"
                      )}>
                        {book.author}
                      </p>
                      <div className={cn(
                        "text-xs mt-1",
                        isDarkMode ? "text-gray-400" : "text-gray-500"
                      )}>
                        Added {formatDate(book.addedAt)}
                      </div>
                      
                      <Button
                        variant="ghost"
                        size="icon"
                        className={cn(
                          "absolute top-2 right-2 h-8 w-8 rounded-full",
                          isDarkMode ? "text-gray-400 hover:text-white hover:bg-gray-700" : "hover:bg-gray-100"
                        )}
                        onClick={() => handleOpenRemoveDialog(book.id)}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </CardContent>
                  </Card>
                ))}
              </div>
            ) : (
              <div className="space-y-2">
                {filteredBooks.map(book => (
                  <div key={book.id} className={cn(
                    "flex items-center p-3 rounded-lg border",
                    isDarkMode ? "bg-gray-800 border-gray-700 hover:bg-gray-750" : "bg-white hover:bg-gray-50"
                  )}>
                    <div className="h-16 w-12 mr-4 overflow-hidden rounded">
                      {book.imageUrl ? (
                        <img 
                          src={book.imageUrl} 
                          alt={book.title}
                          className="h-full w-full object-cover"
                        />
                      ) : (
                        <div className="flex h-full w-full items-center justify-center bg-gradient-to-b from-amber-100 to-amber-200">
                          <BookOpen className="h-6 w-6 text-amber-600/60" />
                        </div>
                      )}
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <h3 className={cn(
                        "font-semibold truncate",
                        isDarkMode ? "text-gray-100" : "text-gray-800"
                      )}>
                        {book.title}
                      </h3>
                      <p className={cn(
                        "text-sm truncate",
                        isDarkMode ? "text-gray-400" : "text-gray-600"
                      )}>
                        {book.author}
                      </p>
                    </div>
                    
                    <div className={cn(
                      "text-xs mr-4 whitespace-nowrap",
                      isDarkMode ? "text-gray-400" : "text-gray-500"
                    )}>
                      Added {formatDate(book.addedAt)}
                    </div>
                    
                    <Button
                      variant="ghost"
                      size="sm"
                      className={cn(
                        "text-red-500 hover:text-red-600",
                        isDarkMode ? "hover:bg-gray-700" : "hover:bg-red-50"
                      )}
                      onClick={() => handleOpenRemoveDialog(book.id)}
                    >
                      <X className="h-4 w-4 mr-1" />
                      Remove
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </>
        )}
      </div>

      {/* Edit Collection Dialog */}
      <Dialog open={showEditDialog} onOpenChange={setShowEditDialog}>
        <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
          <DialogHeader>
            <DialogTitle className={isDarkMode ? "text-white" : ""}>Edit Collection</DialogTitle>
            <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
              Update your collection details below.
            </DialogDescription>
          </DialogHeader>
          <CollectionForm
            collection={collection}
            onSubmit={updateMutation.mutate}
            onCancel={() => setShowEditDialog(false)}
            isSubmitting={updateMutation.isPending}
          />
        </DialogContent>
      </Dialog>

      {/* Delete Collection Dialog */}
      <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
          <DialogHeader>
            <DialogTitle className={isDarkMode ? "text-white" : ""}>Delete Collection</DialogTitle>
            <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
              Are you sure you want to delete this collection? This action cannot be undone.
            </DialogDescription>
          </DialogHeader>
          <div className="mt-2">
            <Alert className={cn(
              "bg-red-100 text-red-800 border-red-200",
              isDarkMode && "bg-red-900/20 border-red-800/30 text-red-400"
            )}>
              <AlertDescription>
                This will remove the collection but will not delete any books from your library.
              </AlertDescription>
            </Alert>
          </div>
          <DialogFooter className="flex items-center space-x-2 mt-4">
            <Button
              variant="outline"
              onClick={() => setShowDeleteDialog(false)}
              className={isDarkMode ? "border-gray-700 text-gray-300 hover:bg-gray-800" : ""}
            >
              Cancel
            </Button>
            <Button
              variant="destructive"
              onClick={() => deleteMutation.mutate()}
              disabled={deleteMutation.isPending}
            >
              {deleteMutation.isPending ? "Deleting..." : "Delete Collection"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Remove Book Dialog */}
      <Dialog open={showRemoveBookDialog} onOpenChange={setShowRemoveBookDialog}>
        <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
          <DialogHeader>
            <DialogTitle className={isDarkMode ? "text-white" : ""}>Remove Book</DialogTitle>
            <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
              Are you sure you want to remove this book from the collection?
            </DialogDescription>
          </DialogHeader>
          <DialogFooter className="flex items-center space-x-2 mt-4">
            <Button
              variant="outline"
              onClick={() => setShowRemoveBookDialog(false)}
              className={isDarkMode ? "border-gray-700 text-gray-300 hover:bg-gray-800" : ""}
            >
              Cancel
            </Button>
            <Button
              onClick={handleRemoveBook}
              disabled={removeBookMutation.isPending}
              className="bg-red-600 hover:bg-red-700 text-white"
            >
              {removeBookMutation.isPending ? "Removing..." : "Remove Book"}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Add Book Dialog */}
      <Dialog open={showAddBookDialog} onOpenChange={setShowAddBookDialog}>
        <DialogContent className={cn(
          "max-w-3xl max-h-[90vh] overflow-hidden flex flex-col",
          isDarkMode ? "bg-gray-900 border-gray-700" : ""
        )}>
          <DialogHeader>
            <DialogTitle className={isDarkMode ? "text-white" : ""}>Add Books to Collection</DialogTitle>
            <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
              Select books from your library to add to this collection.
            </DialogDescription>
          </DialogHeader>
          
          <div className="relative mt-2 mb-4">
            <Input
              placeholder="Search your books..."
              value={bookSearchQuery}
              onChange={(e) => setBookSearchQuery(e.target.value)}
              className={cn(
                "pl-10",
                isDarkMode && "bg-gray-800 border-gray-700 text-gray-200"
              )}
            />
            <Search className={cn(
              "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4",
              isDarkMode ? "text-gray-400" : "text-gray-500"
            )} />
          </div>
          
          <div className="flex-1 overflow-y-auto">
            {filteredAvailableBooks.length === 0 ? (
              <div className={cn(
                "text-center py-8",
                isDarkMode ? "text-gray-400" : "text-gray-500"
              )}>
                {bookSearchQuery ? "No books found matching your search." : "No books available to add."}
              </div>
            ) : (
              <div className="space-y-2">
                {filteredAvailableBooks.map(book => (
                  <div key={book.id} className={cn(
                    "flex items-center p-3 rounded-lg border",
                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white"
                  )}>
                    <div className="h-16 w-12 mr-4 overflow-hidden rounded">
                      {book.imageUrl ? (
                        <img 
                          src={book.imageUrl} 
                          alt={book.title}
                          className="h-full w-full object-cover"
                        />
                      ) : (
                        <div className="flex h-full w-full items-center justify-center bg-gradient-to-b from-amber-100 to-amber-200">
                          <BookOpen className="h-6 w-6 text-amber-600/60" />
                        </div>
                      )}
                    </div>
                    
                    <div className="flex-1 min-w-0">
                      <h3 className={cn(
                        "font-semibold truncate",
                        isDarkMode ? "text-gray-100" : "text-gray-800"
                      )}>
                        {book.title}
                      </h3>
                      <p className={cn(
                        "text-sm truncate",
                        isDarkMode ? "text-gray-400" : "text-gray-600"
                      )}>
                        {book.author}
                      </p>
                    </div>
                    
                    <Button
                      onClick={() => handleAddBook(book.id)}
                      disabled={addBookMutation.isPending}
                      className="bg-amber-600 hover:bg-amber-700 text-white"
                    >
                      <Plus className="h-4 w-4 mr-1" />
                      Add
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </div>
          
          <DialogFooter className="mt-4">
            <Button
              variant="outline"
              onClick={() => setShowAddBookDialog(false)}
              className={isDarkMode ? "border-gray-700 text-gray-300 hover:bg-gray-800" : ""}
            >
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Error message */}
      {error && (
        <div className="fixed bottom-4 right-4 bg-red-500 text-white p-3 rounded-md shadow-lg">
          {error}
          <Button 
            variant="ghost" 
            size="sm" 
            className="ml-2 text-white hover:bg-red-600 p-1 h-auto"
            onClick={() => setError(null)}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      )}
    </div>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-58-modules-collectionspage-pages-collectionspage-tsx">File 58: Modules/CollectionsPage/pages/CollectionsPage.tsx</h2>

```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useAuth } from "../../../hooks/userAuth";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { cn } from "../../../lib/utils";
import Sidebar from "../../LibraryPage/Sidebar";
import { 
  fetchUserCollections, 
  createCollection, 
  deleteCollection,
  updateCollection,
  Collection, 
  CollectionFormData 
} from "../../../api/collectionsApi";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription } from "../../../components/ui/dialog";
import { Alert, AlertDescription } from "../../../components/ui/alert";
import CollectionsList from "../components/CollectionsList";
import CollectionForm from "../components/CollectionForm";

export default function CollectionsPage() {
  const { user, accessToken } = useAuth();
  const queryClient = useQueryClient();
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [showEditDialog, setShowEditDialog] = useState(false);
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const [currentCollection, setCurrentCollection] = useState<Collection | null>(null);
  const [error, setError] = useState<string | null>(null);

  // Fetch collections
  const { data: collectionsData, isLoading } = useQuery({
    queryKey: ["collections"],
    queryFn: () => fetchUserCollections(user?.id || "", accessToken || ""),
    enabled: !!user?.id && !!accessToken,
  });

  const collections = collectionsData?.success ? collectionsData.data : [];

  // Create collection mutation
  const createMutation = useMutation({
    mutationFn: (data: CollectionFormData) => createCollection(data, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collections"] });
      setShowCreateDialog(false);
    },
    onError: (error) => {
      setError("Failed to create collection");
      console.error("Create error:", error);
    }
  });

  // Update collection mutation
  const updateMutation = useMutation({
    mutationFn: ({ id, data }: { id: string; data: CollectionFormData }) => 
      updateCollection(id, data, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collections"] });
      setShowEditDialog(false);
      setCurrentCollection(null);
    },
    onError: (error) => {
      setError("Failed to update collection");
      console.error("Update error:", error);
    }
  });

  // Delete collection mutation
  const deleteMutation = useMutation({
    mutationFn: (id: string) => deleteCollection(id, accessToken!),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["collections"] });
      setShowDeleteDialog(false);
      setCurrentCollection(null);
    },
    onError: (error) => {
      setError("Failed to delete collection");
      console.error("Delete error:", error);
    }
  });

  const handleCreateCollection = () => {
    setShowCreateDialog(true);
  };

  const handleEditCollection = (collection: Collection) => {
    setCurrentCollection(collection);
    setShowEditDialog(true);
  };

  const handleDeleteCollection = (id: string) => {
    const collection = collections.find(c => c.id === id);
    if (collection) {
      setCurrentCollection(collection);
      setShowDeleteDialog(true);
    }
  };

  const handleUpdateCollection = (data: CollectionFormData) => {
    if (currentCollection) {
      updateMutation.mutate({ id: currentCollection.id, data });
    }
  };

  return (
    <div className="flex h-screen overflow-hidden">
      <Sidebar />
      
      <main className={cn(
        "flex-1 overflow-auto p-6",
        isDarkMode ? "bg-gray-900 text-gray-100" : "bg-gray-50"
      )}>
        <div className="container mx-auto">
          <h1 className={cn(
            "text-3xl font-bold mb-6",
            isDarkMode ? "text-white" : "text-gray-800"
          )}>
            Collections
          </h1>

          <CollectionsList 
            collections={collections}
            isLoading={isLoading}
            onCreateCollection={handleCreateCollection}
            onEditCollection={handleEditCollection}
            onDeleteCollection={handleDeleteCollection}
          />
        </div>

        {/* Create Collection Dialog */}
        <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
          <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
            <DialogHeader>
              <DialogTitle className={isDarkMode ? "text-white" : ""}>Create Collection</DialogTitle>
              <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
                Create a new collection to organize your books.
              </DialogDescription>
            </DialogHeader>
            <CollectionForm
              onSubmit={createMutation.mutate}
              onCancel={() => setShowCreateDialog(false)}
              isSubmitting={createMutation.isPending}
            />
          </DialogContent>
        </Dialog>

        {/* Edit Collection Dialog */}
        {currentCollection && (
          <Dialog open={showEditDialog} onOpenChange={setShowEditDialog}>
            <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
              <DialogHeader>
                <DialogTitle className={isDarkMode ? "text-white" : ""}>Edit Collection</DialogTitle>
                <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
                  Update your collection details below.
                </DialogDescription>
              </DialogHeader>
              <CollectionForm
                collection={currentCollection}
                onSubmit={handleUpdateCollection}
                onCancel={() => setShowEditDialog(false)}
                isSubmitting={updateMutation.isPending}
              />
            </DialogContent>
          </Dialog>
        )}

        {/* Delete Collection Dialog */}
        {currentCollection && (
          <Dialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
            <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
              <DialogHeader>
                <DialogTitle className={isDarkMode ? "text-white" : ""}>Delete Collection</DialogTitle>
                <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
                  Are you sure you want to delete "{currentCollection.name}"? This action cannot be undone.
                </DialogDescription>
              </DialogHeader>
              <div className="mt-2">
                <Alert className={cn(
                  "bg-red-100 text-red-800 border-red-200",
                  isDarkMode && "bg-red-900/20 border-red-800/30 text-red-400"
                )}>
                  <AlertDescription>
                    This will remove the collection but will not delete any books from your library.
                  </AlertDescription>
                </Alert>
              </div>
              <div className="flex justify-end space-x-2 mt-4">
                <button
                  className={cn(
                    "px-4 py-2 rounded-md",
                    isDarkMode 
                      ? "bg-gray-800 text-gray-200 hover:bg-gray-700" 
                      : "bg-gray-200 text-gray-800 hover:bg-gray-300"
                  )}
                  onClick={() => setShowDeleteDialog(false)}
                >
                  Cancel
                </button>
                <button
                  className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 disabled:opacity-50 disabled:cursor-not-allowed"
                  onClick={() => deleteMutation.mutate(currentCollection.id)}
                  disabled={deleteMutation.isPending}
                >
                  {deleteMutation.isPending ? "Deleting..." : "Delete"}
                </button>
              </div>
            </DialogContent>
          </Dialog>
        )}

        {/* Error message */}
        {error && (
          <div className="fixed bottom-4 right-4 bg-red-500 text-white p-3 rounded-md shadow-lg">
            {error}
            <button 
              className="ml-2 text-white hover:bg-red-600 p-1 rounded-full"
              onClick={() => setError(null)}
            >
              ✕
            </button>
          </div>
        )}
      </main>
    </div>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-59-modules-favoritespage-favoritespage-tsx">File 59: Modules/FavoritesPage/FavoritesPage.tsx</h2>

```typescript
import { useState, useEffect } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useNavigate } from "react-router-dom";
import { Book } from "../../endPointTypes/types";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useAuth } from "../../hooks/userAuth";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import Sidebar from "../LibraryPage/Sidebar";
import { 
    Heart, BookOpen, Search, Plus, Clock, 
    SortAsc, SortDesc, Grid, List, Filter,
    Bookmark, ChevronDown, X, Star
} from "lucide-react";
import { Card, CardContent } from "../../components/ui/card";
import { Button } from "../../components/ui/button";
import { Input } from "../../components/ui/input";
import { Badge } from "../../components/ui/badge";
import { 
    DropdownMenu, 
    DropdownMenuContent, 
    DropdownMenuItem, 
    DropdownMenuTrigger
} from "../../components/ui/dropdown-menu";
import { Progress } from "../../components/ui/progress";
import { Separator } from "../../components/ui/separator";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "../../components/ui/tooltip";

// Types
type SortOption = "title" | "author" | "dateAdded" | "lastRead";
type SortDirection = "asc" | "desc";
type ViewMode = "grid" | "list";
type BookProgress = {
    bookId: string;
    percentComplete: number;
    currentPage: number;
    lastReadAt: string;
};

export default function FavoritesPage() {
    const { user, accessToken } = useAuth();
    const navigate = useNavigate();
    const queryClient = useQueryClient();
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [booksLoading, setBooksLoading] = useState<string[]>([]);
    const [searchQuery, setSearchQuery] = useState("");
    const [sortBy, setSortBy] = useState<SortOption>("dateAdded");
    const [sortDirection, setSortDirection] = useState<SortDirection>("desc");
    const [viewMode, setViewMode] = useState<ViewMode>("grid");
    const [activeGenre, setActiveGenre] = useState<string | null>(null);
    const [showProgressBar, setShowProgressBar] = useState(true);

    const toggleCollapse = () => {
        setIsCollapsed(!isCollapsed);
    };

    // Fetch favorite books
    const { data: favoriteBooks, isLoading } = useQuery({
        queryKey: ["favoriteBooks", user?.id],
        queryFn: async () => {
            const data = await apiFetch(
                "GET /book/getFavorites",
                {
                    query: {
                        userId: user?.id,
                    },
                },
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
            return data.data.data as Book[];
        },
        enabled: !!user?.id && !!accessToken,
    });

    // Fetch book progress
    const { data: bookProgress } = useQuery({
        queryKey: ["bookProgress", user?.id],
        queryFn: async () => {
            const data = await apiFetch(
                "GET /tracking/progress/all",
                {},
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
            return data.data as BookProgress[];
        },
        enabled: !!user?.id && !!accessToken,
    });

    // Toggle favorite status mutation
    const toggleFavoriteMutation = useMutation({
        mutationFn: async (bookId: string) => {
            const book = favoriteBooks?.find(b => b.id === bookId);
            if (!book) return null;
            
            return apiFetch(
                "PATCH /book/:id",
                {
                    params: { id: bookId },
                    body: { liked: !book.liked }
                },
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
        },
        onSuccess: () => {
            // Invalidate and refetch
            queryClient.invalidateQueries({ queryKey: ["favoriteBooks"] });
        }
    });

    // Extract all unique genres from books
    const allGenres = favoriteBooks
        ? [...new Set(favoriteBooks.flatMap(book => {
            if (!book.genres) return [];
            return book.genres.map(genre => 
                typeof genre === 'string' 
                    ? genre 
                    : (genre as any).name || 'Unknown'
            );
          }).filter(Boolean))]
        : [];

    // Helper function to get book progress
    const getBookProgress = (bookId: string) => {
        if (!bookProgress) return null;
        return bookProgress.find(p => p.bookId === bookId);
    };

    // Format date helper
    const formatDate = (dateString: string) => {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', { 
            year: 'numeric', 
            month: 'short', 
            day: 'numeric' 
        });
    };

    // Filter and sort books
    const processedBooks = favoriteBooks
        ? favoriteBooks
            // Apply search filter
            .filter(book => {
                if (!searchQuery) return true;
                const query = searchQuery.toLowerCase();
                return (
                    book.title.toLowerCase().includes(query) ||
                    book.author.toLowerCase().includes(query) ||
                    (book.genres && book.genres.some(genre => {
                        const genreName = typeof genre === 'string' 
                            ? genre 
                            : (genre as any).name || '';
                        return genreName.toLowerCase().includes(query);
                    }))
                );
            })
            // Apply genre filter
            .filter(book => {
                if (!activeGenre) return true;
                return book.genres && book.genres.some(genre => {
                    const genreName = typeof genre === 'string' 
                        ? genre 
                        : (genre as any).name || '';
                    return genreName === activeGenre;
                });
            })
            // Sort books
            .sort((a, b) => {
                let comparison = 0;
                switch (sortBy) {
                    case "title":
                        comparison = a.title.localeCompare(b.title);
                        break;
                    case "author":
                        comparison = a.author.localeCompare(b.author);
                        break;
                    case "dateAdded":
                        comparison = new Date(a.dateAdded).getTime() - new Date(b.dateAdded).getTime();
                        break;
                    case "lastRead":
                        const progressA = getBookProgress(a.id);
                        const progressB = getBookProgress(b.id);
                        const timeA = progressA?.lastReadAt ? new Date(progressA.lastReadAt).getTime() : 0;
                        const timeB = progressB?.lastReadAt ? new Date(progressB.lastReadAt).getTime() : 0;
                        comparison = timeA - timeB;
                        break;
                }
                return sortDirection === "asc" ? comparison : -comparison;
            })
        : [];

    // Handle book click to navigate to reading page
    const handleBookClick = (bookId: string) => {
        navigate(`/book?id=${bookId}`);
    };

    // Handle toggling a book's favorite status
    const handleToggleFavorite = (e: React.MouseEvent, bookId: string) => {
        e.stopPropagation();
        toggleFavoriteMutation.mutate(bookId);
    };

    return (
        <div className={cn(
            "flex h-screen",
            isDarkMode ? "bg-gray-900" : "bg-amber-50"
        )}>
            <Sidebar 
                isCollapsed={isCollapsed} 
                toggleCollapse={toggleCollapse} 
                setBooksLoading={setBooksLoading} 
            />
            
            <main className={cn(
                "flex-1 overflow-y-auto p-6",
                isDarkMode ? "text-gray-200" : "text-gray-800"
            )}>
                <div className="max-w-7xl mx-auto">
                    <div className="flex items-center justify-between mb-8">
                        <div className="flex items-center">
                            <Heart className={cn(
                                "mr-3 h-7 w-7",
                                isDarkMode ? "text-red-500" : "text-red-600"
                            )} />
                            <h1 className="text-2xl font-serif font-medium">My Favorites</h1>
                        </div>
                        
                       
                    </div>

                    <div className="flex flex-col md:flex-row gap-4 mb-8">
                        {/* Search Bar */}
                        <div className="relative flex-1 max-w-lg">
                            <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-gray-500" />
                            <Input
                                className={cn(
                                    "pl-10 py-6",
                                    isDarkMode 
                                        ? "bg-gray-800 border-gray-700 text-white placeholder:text-gray-500" 
                                        : "bg-white border-gray-200 text-gray-900 placeholder:text-gray-400"
                                )}
                                placeholder="Search favorites by title, author, or genre..."
                                value={searchQuery}
                                onChange={(e) => setSearchQuery(e.target.value)}
                            />
                            {searchQuery && (
                                <button 
                                    className="absolute right-3 top-1/2 transform -translate-y-1/2"
                                    onClick={() => setSearchQuery("")}
                                >
                                    <X className="h-4 w-4 text-gray-500" />
                                </button>
                            )}
                        </div>
                        
                        <div className="flex gap-2 flex-wrap md:flex-nowrap">
                        
                            
                            {/* Sort dropdown */}
                            <DropdownMenu>
                                <DropdownMenuTrigger asChild>
                                    <Button 
                                        variant="outline" 
                                        size="sm"
                                        className={cn(
                                            "whitespace-nowrap",
                                            isDarkMode ? "bg-gray-800 border-gray-700 text-gray-300" : ""
                                        )}
                                    >
                                        {sortDirection === "asc" ? (
                                            <SortAsc className="mr-2 h-4 w-4" />
                                        ) : (
                                            <SortDesc className="mr-2 h-4 w-4" />
                                        )}
                                        Sort by
                                        <ChevronDown className="ml-2 h-4 w-4" />
                                    </Button>
                                </DropdownMenuTrigger>
                                <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
                                    <DropdownMenuItem 
                                        onClick={() => setSortBy("title")}
                                        className={cn(
                                            sortBy === "title" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                                            isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                                        )}
                                    >
                                        Title
                                    </DropdownMenuItem>
                                    <DropdownMenuItem 
                                        onClick={() => setSortBy("author")}
                                        className={cn(
                                            sortBy === "author" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                                            isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                                        )}
                                    >
                                        Author
                                    </DropdownMenuItem>
                                    <DropdownMenuItem 
                                        onClick={() => setSortBy("dateAdded")}
                                        className={cn(
                                            sortBy === "dateAdded" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                                            isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                                        )}
                                    >
                                        Date Added
                                    </DropdownMenuItem>
                                    <DropdownMenuItem 
                                        onClick={() => setSortBy("lastRead")}
                                        className={cn(
                                            sortBy === "lastRead" ? (isDarkMode ? "bg-gray-700" : "bg-gray-100") : "",
                                            isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""
                                        )}
                                    >
                                        Last Read
                                    </DropdownMenuItem>
                                    <Separator className={isDarkMode ? "bg-gray-700" : ""} />
                                    <DropdownMenuItem 
                                        onClick={() => setSortDirection(sortDirection === "asc" ? "desc" : "asc")}
                                        className={isDarkMode ? "text-gray-300 focus:bg-gray-700" : ""}
                                    >
                                        {sortDirection === "asc" ? (
                                            <SortDesc className="mr-2 h-4 w-4" />
                                        ) : (
                                            <SortAsc className="mr-2 h-4 w-4" />
                                        )}
                                        {sortDirection === "asc" ? "Descending" : "Ascending"}
                                    </DropdownMenuItem>
                                </DropdownMenuContent>
                            </DropdownMenu>
                            
                            {/* View toggle */}
                            <div className="flex bg-gray-100 rounded-md h-8 overflow-hidden">
                                <Button
                                    size="sm"
                                    variant="ghost"
                                    className={cn(
                                        "p-1",
                                        viewMode === "grid" 
                                            ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                                            : (isDarkMode ? "text-gray-400" : "text-gray-500")
                                    )}
                                    onClick={() => setViewMode("grid")}
                                >
                                    <Grid className="h-4 w-4" />
                                </Button>
                                <Button
                                    size="sm"
                                    variant="ghost"
                                    className={cn(
                                        "p-1",
                                        viewMode === "list" 
                                            ? (isDarkMode ? "bg-gray-700 text-white" : "bg-white shadow-sm")
                                            : (isDarkMode ? "text-gray-400" : "text-gray-500")
                                    )}
                                    onClick={() => setViewMode("list")}
                                >
                                    <List className="h-4 w-4" />
                                </Button>
                            </div>
                        </div>
                    </div>
                    
                    {isLoading ? (
                        viewMode === "grid" ? (
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                                {[...Array(10)].map((_, i) => (
                                    <Card key={i} className={cn(
                                        "overflow-hidden h-80 relative group animate-pulse",
                                        isDarkMode ? "bg-gray-800" : "bg-gray-100"
                                    )}>
                                        <div className="h-64 bg-gray-700"></div>
                                        <CardContent className="p-3">
                                            <div className="h-4 bg-gray-700 rounded w-3/4 mb-2"></div>
                                            <div className="h-3 bg-gray-700 rounded w-1/2"></div>
                                        </CardContent>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {[...Array(8)].map((_, i) => (
                                    <div key={i} className={cn(
                                        "flex animate-pulse p-4 rounded-lg",
                                        isDarkMode ? "bg-gray-800" : "bg-gray-100"
                                    )}>
                                        <div className="w-16 h-24 bg-gray-700 rounded"></div>
                                        <div className="ml-4 flex-1">
                                            <div className="h-4 bg-gray-700 rounded w-1/4 mb-2"></div>
                                            <div className="h-3 bg-gray-700 rounded w-1/6 mb-4"></div>
                                            <div className="h-2 bg-gray-700 rounded w-full"></div>
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    ) : processedBooks && processedBooks.length > 0 ? (
                        viewMode === "grid" ? (
                            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-6">
                                {processedBooks.map((book) => (
                                    <Card 
                                        key={book.id} 
                                        className={cn(
                                            "relative group cursor-pointer",
                                            isDarkMode ? "bg-gray-800 hover:bg-gray-750" : "bg-white hover:bg-gray-50",
                                            booksLoading.includes(book.id) ? "opacity-50" : "opacity-100"
                                        )}
                                        onClick={() => handleBookClick(book.id)}
                                    >
                                        <TooltipProvider>
                                            <Tooltip>
                                                <TooltipTrigger asChild>
                                                    <button 
                                                        className="absolute top-2 right-2 z-10 p-1 rounded-full bg-white/80 hover:bg-white text-red-500"
                                                        onClick={(e) => handleToggleFavorite(e, book.id)}
                                                    >
                                                        <Heart className="h-5 w-5 fill-red-500" />
                                                    </button>
                                                </TooltipTrigger>
                                                <TooltipContent>
                                                    <p>Remove from favorites</p>
                                                </TooltipContent>
                                            </Tooltip>
                                        </TooltipProvider>
                                        
                                        <div 
                                            className="h-80 bg-cover bg-center"
                                            style={{
                                                backgroundImage: book.imageUrl 
                                                    ? `url(${book.imageUrl})` 
                                                    : "url('/placeholder-book.jpg')"
                                            }}
                                        >
                                            <div className={cn(
                                                "w-full h-full flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity",
                                                isDarkMode ? "bg-black/60" : "bg-white/60"
                                            )}>
                                                <Button 
                                                    className={cn(
                                                        "transition-all",
                                                        isDarkMode ? "bg-amber-600 hover:bg-amber-700" : "bg-amber-600 hover:bg-amber-700"
                                                    )}
                                                >
                                                    <BookOpen className="mr-2 h-4 w-4" />
                                                    Read Book
                                                </Button>
                                            </div>
                                        </div>
                                        
                                        <CardContent className="p-3">
                                            <h3 className={cn(
                                                "font-medium text-sm line-clamp-1",
                                                isDarkMode ? "text-gray-200" : "text-gray-900"
                                            )}>
                                                {book.title}
                                            </h3>
                                            <p className={cn(
                                                "text-xs line-clamp-1",
                                                isDarkMode ? "text-gray-400" : "text-gray-500"
                                            )}>
                                                {book.author}
                                            </p>
                                            
                                            {showProgressBar && (
                                                <div className="mt-2">
                                                    {getBookProgress(book.id) ? (
                                                        <div className="space-y-1">
                                                            <Progress
                                                                value={getBookProgress(book.id)?.percentComplete ? getBookProgress(book.id)!.percentComplete * 100 : 0}
                                                                className={cn(
                                                                    "h-1.5",
                                                                    isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                                                )}
                                                                indicatorClassName="bg-amber-500"
                                                            />
                                                            <div className="flex justify-between">
                                                                <span className={cn(
                                                                    "text-xs",
                                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                                )}>
                                                                    {Math.round((getBookProgress(book.id)?.percentComplete || 0) * 100)}%
                                                                </span>
                                                                <span className={cn(
                                                                    "text-xs",
                                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                                )}>
                                                                    Page {getBookProgress(book.id)?.currentPage || 0}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <p className={cn(
                                                            "text-xs italic mt-2",
                                                            isDarkMode ? "text-gray-500" : "text-gray-400"
                                                        )}>
                                                            Not started yet
                                                        </p>
                                                    )}
                                                </div>
                                            )}
                                            
                                          
                                        </CardContent>
                                    </Card>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-3">
                                {processedBooks.map((book) => (
                                    <div 
                                        key={book.id}
                                        className={cn(
                                            "flex rounded-lg cursor-pointer",
                                            isDarkMode ? "bg-gray-800 hover:bg-gray-750" : "bg-white hover:bg-gray-50",
                                            booksLoading.includes(book.id) ? "opacity-50" : "opacity-100"
                                        )}
                                        onClick={() => handleBookClick(book.id)}
                                    >
                                        <div 
                                            className="w-20 bg-cover bg-center flex-shrink-0"
                                            style={{
                                                backgroundImage: book.imageUrl 
                                                    ? `url(${book.imageUrl})` 
                                                    : "url('/placeholder-book.jpg')"
                                            }}
                                        ></div>
                                        
                                        <div className="p-4 flex-1 flex flex-col">
                                            <div className="flex justify-between items-start">
                                                <div>
                                                    <h3 className={cn(
                                                        "font-medium",
                                                        isDarkMode ? "text-gray-200" : "text-gray-900"
                                                    )}>
                                                        {book.title}
                                                    </h3>
                                                    <p className={cn(
                                                        "text-sm",
                                                        isDarkMode ? "text-gray-400" : "text-gray-500"
                                                    )}>
                                                        {book.author}
                                                    </p>
                                                </div>
                                                
                                                <TooltipProvider>
                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <button 
                                                                className="text-red-500 p-1"
                                                                onClick={(e) => handleToggleFavorite(e, book.id)}
                                                            >
                                                                <Heart className="h-5 w-5 fill-red-500" />
                                                            </button>
                                                        </TooltipTrigger>
                                                        <TooltipContent>
                                                            <p>Remove from favorites</p>
                                                        </TooltipContent>
                                                    </Tooltip>
                                                </TooltipProvider>
                                            </div>
                            
                                            
                                            {showProgressBar && (
                                                <div className="mt-auto pt-3">
                                                    {getBookProgress(book.id) ? (
                                                        <div className="space-y-1">
                                                            <div className="flex justify-between">
                                                                <span className={cn(
                                                                    "text-xs",
                                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                                )}>
                                                                    Progress: {Math.round((getBookProgress(book.id)?.percentComplete || 0) * 100)}%
                                                                </span>
                                                                <span className={cn(
                                                                    "text-xs",
                                                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                                                )}>
                                                                    Last read: {getBookProgress(book.id)?.lastReadAt ? formatDate(getBookProgress(book.id)?.lastReadAt!) : 'Never'}
                                                                </span>
                                                            </div>
                                                            <Progress
                                                                value={getBookProgress(book.id)?.percentComplete ? getBookProgress(book.id)!.percentComplete * 100 : 0}
                                                                className={cn(
                                                                    "h-1.5",
                                                                    isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                                                )}
                                                                indicatorClassName="bg-amber-500"
                                                            />
                                                        </div>
                                                    ) : (
                                                        <p className={cn(
                                                            "text-xs italic",
                                                            isDarkMode ? "text-gray-500" : "text-gray-400"
                                                        )}>
                                                            Not started yet
                                                        </p>
                                                    )}
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        )
                    ) : (
                        <div className={cn(
                            "flex flex-col items-center justify-center py-16 px-4 text-center",
                            isDarkMode ? "bg-gray-800/50" : "bg-gray-100/50",
                            "rounded-lg border",
                            isDarkMode ? "border-gray-700" : "border-gray-200"
                        )}>
                            <Heart className={cn(
                                "h-16 w-16 mb-4",
                                isDarkMode ? "text-gray-700" : "text-gray-300"
                            )} />
                            <h3 className={cn(
                                "text-xl font-serif font-medium mb-2",
                                isDarkMode ? "text-white" : "text-gray-800"
                            )}>
                                {activeGenre || searchQuery ? "No matching favorites found" : "No favorite books yet"}
                            </h3>
                            <p className={cn(
                                "mb-6 max-w-md mx-auto",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                            )}>
                                {activeGenre || searchQuery ? 
                                    "Try changing your filters or search query to see more books." : 
                                    "You haven't added any books to your favorites. Click the heart icon on any book to add it to your favorites."}
                            </p>
                            <Button
                                onClick={() => {
                                    if (activeGenre || searchQuery) {
                                        setActiveGenre(null);
                                        setSearchQuery("");
                                    } else {
                                        navigate('/');
                                    }
                                }}
                                className="bg-amber-600 hover:bg-amber-700 text-white"
                            >
                                {activeGenre || searchQuery ? (
                                    <>
                                        <X className="mr-2 h-4 w-4" />
                                        Clear Filters
                                    </>
                                ) : (
                                    <>
                                        <Plus className="mr-2 h-4 w-4" />
                                        Browse Library
                                    </>
                                )}
                            </Button>
                        </div>
                    )}
                </div>
            </main>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-60-modules-historypage-readinghistorypage-tsx">File 60: Modules/HistoryPage/ReadingHistoryPage.tsx</h2>

```typescript
import { useEffect, useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { 
    BookOpen, 
    Calendar, 
    Clock, 
    BookText, 
    ChevronRight, 
    Trophy, 
    Star, 
    BarChart3 
} from "lucide-react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "../../components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "../../components/ui/tabs";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useToast } from "../../hooks/use-toast";
import { useAuth } from "../../hooks/userAuth";
import { useSidebar } from "../../hooks/useSidebar";
import Sidebar from "../LibraryPage/Sidebar";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import { Badge } from "../../components/ui/badge";
import { Separator } from "../../components/ui/separator";

// Types for reading history data
type ReadingSession = {
    id: string;
    startTime: string;
    endTime: string;
    duration: number;
    pagesRead: number;
    book: {
        id: string;
        title: string;
        author: string;
        imageUrl: string;
    };
};

type ReadingStreak = {
    currentStreak: number;
    longestStreak: number;
    totalReadDays: number;
};

type ReadingStats = {
    totalBooksRead: number;
    totalPagesRead: number;
    totalReadingTime: number;
};

type BookProgress = {
    id: string;
    percentComplete: number;
    currentPage: number;
    isCompleted: boolean;
    completedAt: string | null;
    book: {
        id: string;
        title: string;
        author: string;
        imageUrl: string;
    };
};

type Activity = {
    type: string;
    description: string;
    timestamp: string;
    bookId: string;
};

// Fetch data functions
const fetchReadingSessions = async (userId: string, token: string) => {
    const data = await apiFetch(
        "GET /tracking/sessions/recent",
        {},
        {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        }
    );
    return data.data;
};

const fetchReadingStreak = async (userId: string, token: string) => {
    const data = await apiFetch(
        "GET /tracking/streak",
        {},
        {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        }
    );
    return data.data;
};

const fetchReadingStats = async (userId: string, token: string) => {
    const data = await apiFetch(
        "GET /tracking/stats",
        {},
        {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        }
    );
    return data.data;
};

const fetchBookProgress = async (userId: string, token: string) => {
    const data = await apiFetch(
        "GET /tracking/progress/all",
        {},
        {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        }
    );
    return data.data;
};

export default function ReadingHistoryPage() {
  const { accessToken, user } = useAuth();
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const navigate = useNavigate();
  const { toast } = useToast();
  const { isCollapsed, toggleCollapse } = useSidebar([]);
  // Helper function to format duration with more precision
  const formatDuration = (seconds: number) => {
    if (seconds < 60) {
      return `${seconds} seconds`;
    }

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = seconds % 60;

    if (hours > 0) {
      if (minutes === 0) {
        return `${hours}h`;
      }
      return `${hours}h ${minutes}m`;
    }

    if (remainingSeconds === 0) {
      return `${minutes} minute${minutes !== 1 ? "s" : ""}`;
    }

    return `${minutes} minute${
      minutes !== 1 ? "s" : ""
    } and ${remainingSeconds} second${remainingSeconds !== 1 ? "s" : ""}`;
  };

  const formatTimeAgo = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffSeconds < 60) return "just now";
    if (diffSeconds < 3600) return `${Math.floor(diffSeconds / 60)}m ago`;
    if (diffSeconds < 86400) return `${Math.floor(diffSeconds / 3600)}h ago`;
    if (diffSeconds < 604800) return `${Math.floor(diffSeconds / 86400)}d ago`;

    return formatDate(dateString);
  };
  // Fetch reading history data
  const { data: sessions } = useQuery<ReadingSession[]>({
    queryKey: ["readingSessions"],
    queryFn: () => fetchReadingSessions(user?.id || "", accessToken || ""),
    enabled: !!accessToken && !!user,
  });

  const { data: streak } = useQuery<ReadingStreak>({
    queryKey: ["readingStreak"],
    queryFn: () => fetchReadingStreak(user?.id || "", accessToken || ""),
    enabled: !!accessToken && !!user,
  });

  const { data: stats } = useQuery<ReadingStats>({
    queryKey: ["readingStats"],
    queryFn: () => fetchReadingStats(user?.id || "", accessToken || ""),
    enabled: !!accessToken && !!user,
  });

  const { data: bookProgress } = useQuery<BookProgress[]>({
    queryKey: ["bookProgress"],
    queryFn: () => fetchBookProgress(user?.id || "", accessToken || ""),
    enabled: !!accessToken && !!user,
  });

  // Prepare data for activity feed
  const activityFeed: Activity[] = [];

  // Add reading sessions to activity feed
  if (sessions) {
    sessions.forEach((session) => {
      if (session.endTime) {
        activityFeed.push({
          type: "reading",
          description: `Read "${session.book.title}" for ${formatDuration(
            session.duration || 0
          )}`,
          timestamp: session.endTime,
          bookId: session.book.id,
        });
      }
    });
  }

  // Add completed books to activity feed
  if (bookProgress) {
    bookProgress
      .filter((progress) => progress.isCompleted && progress.completedAt)
      .forEach((progress) => {
        activityFeed.push({
          type: "completed",
          description: `Finished reading "${progress.book.title}"`,
          timestamp: progress.completedAt || "",
          bookId: progress.book.id,
        });
      });
  }

  // Sort activity feed by timestamp (newest first)
  activityFeed.sort(
    (a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
  );

  // Helper function to format date
  const formatDate = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", {
      year: "numeric",
      month: "short",
      day: "numeric",
    });
  };

  // Helper function to format time
  const formatTime = (dateString: string) => {
    const date = new Date(dateString);
    return date.toLocaleTimeString("en-US", {
      hour: "2-digit",
      minute: "2-digit",
    });
  };

  return (
    <div
      className={cn(
        "flex h-screen",
        isDarkMode ? "bg-gray-900" : "bg-amber-50"
      )}
    >
      <Sidebar
        toggleCollapse={toggleCollapse}
        isCollapsed={isCollapsed}
        setBooksLoading={() => {}}
      />

      <main
        className={cn(
          "flex-1 p-6 overflow-auto transition-all duration-300 ease-in-out",
          isDarkMode ? "text-gray-200" : "text-gray-800"
        )}
      >
        <div className="flex flex-col space-y-4 mb-6">
          <h1
            className={cn(
              "text-3xl font-serif font-bold",
              isDarkMode ? "text-white" : "text-amber-800"
            )}
          >
            Reading History
          </h1>

          <Tabs defaultValue="activity" className="w-full">
            <TabsList
              className={cn(
                "w-full md:w-auto justify-start",
                isDarkMode ? "bg-gray-800" : "bg-amber-100/50"
              )}
            >
              <TabsTrigger value="activity">Activity</TabsTrigger>
              <TabsTrigger value="books">Books</TabsTrigger>
            </TabsList>

            {/* Activity Feed Tab */}
            <TabsContent value="activity" className="space-y-6 mt-6">
              <div className="grid gap-4 grid-cols-1 md:grid-cols-3">
                {/* Reading Streak */}
                <Card
                  className={cn(
                    "col-span-1",
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardHeader className="pb-2">
                    <CardTitle className="text-lg flex items-center">
                      <Trophy
                        className={cn(
                          "mr-2 h-5 w-5",
                          isDarkMode ? "text-amber-500" : "text-amber-600"
                        )}
                      />
                      Reading Streak
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="space-y-2">
                      <div className="flex justify-between items-center">
                        <span
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Current Streak
                        </span>
                        <span className="text-xl font-bold">
                          {streak?.currentStreak || 0} days
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Longest Streak
                        </span>
                        <span className="text-lg">
                          {streak?.longestStreak || 0} days
                        </span>
                      </div>
                      <div className="flex justify-between items-center">
                        <span
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Total Reading Days
                        </span>
                        <span className="text-lg">
                          {streak?.totalReadDays || 0} days
                        </span>
                      </div>
                    </div>
                  </CardContent>
                </Card>

                {/* Reading Stats Summary */}
                <Card
                  className={cn(
                    "col-span-2",
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardHeader className="pb-2">
                    <CardTitle className="text-lg flex items-center">
                      <BarChart3
                        className={cn(
                          "mr-2 h-5 w-5",
                          isDarkMode ? "text-amber-500" : "text-amber-600"
                        )}
                      />
                      Reading Summary
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="grid grid-cols-3 gap-4">
                      <div className="text-center space-y-1">
                        <div
                          className={cn(
                            "text-3xl font-bold",
                            isDarkMode ? "text-amber-500" : "text-amber-600"
                          )}
                        >
                          {stats?.totalBooksRead || 0}
                        </div>
                        <div
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Books Read
                        </div>
                      </div>

                      <div className="text-center space-y-1">
                        <div
                          className={cn(
                            "text-3xl font-bold",
                            isDarkMode ? "text-amber-500" : "text-amber-600"
                          )}
                        >
                          {stats?.totalPagesRead || 0}
                        </div>
                        <div
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Pages Read
                        </div>
                      </div>

                      <div className="text-center space-y-1">
                        <div
                          className={cn(
                            "text-3xl font-bold",
                            isDarkMode ? "text-amber-500" : "text-amber-600"
                          )}
                        >
                          {stats?.totalReadingTime
                            ? Math.floor(stats.totalReadingTime / 3600)
                            : 0}
                        </div>
                        <div
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          Hours Read
                        </div>
                      </div>
                    </div>
                  </CardContent>
                </Card>
              </div>

              {/* Activity Feed */}
              <Card
                className={cn(
                  isDarkMode
                    ? "bg-gray-800 border-gray-700"
                    : "bg-white border-gray-200"
                )}
              >
                <CardHeader className="pb-2">
                  <CardTitle className="text-lg flex items-center">
                    <Clock
                      className={cn(
                        "mr-2 h-5 w-5",
                        isDarkMode ? "text-amber-500" : "text-amber-600"
                      )}
                    />
                    Recent Activity
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  {activityFeed.length > 0 ? (
                    <div className="space-y-4">
                      {activityFeed.map((activity, index) => (
                        <div key={index} className="relative pl-6">
                          {/* Activity line connector */}
                          {index < activityFeed.length - 1 && (
                            <div
                              className={cn(
                                "absolute top-6 bottom-0 left-3 w-0.5",
                                isDarkMode ? "bg-gray-700" : "bg-amber-100"
                              )}
                            ></div>
                          )}

                          {/* Activity dot */}
                          <div
                            className={cn(
                              "absolute top-1 left-0 w-6 h-6 rounded-full flex items-center justify-center",
                              activity.type === "completed"
                                ? isDarkMode
                                  ? "bg-green-900/30 text-green-500"
                                  : "bg-green-100 text-green-600"
                                : isDarkMode
                                ? "bg-amber-900/30 text-amber-500"
                                : "bg-amber-100 text-amber-600"
                            )}
                          >
                            {activity.type === "completed" ? (
                              <Star className="h-3 w-3" />
                            ) : (
                              <BookOpen className="h-3 w-3" />
                            )}
                          </div>

                          <div className="flex flex-col space-y-1 pb-4">
                            <div className="flex justify-between items-start">
                              <div>
                                <span
                                  className={
                                    isDarkMode
                                      ? "text-gray-200"
                                      : "text-gray-800"
                                  }
                                >
                                  {activity.description}
                                </span>
                                <Badge
                                  className={cn(
                                    "ml-2 text-xs",
                                    activity.type === "completed"
                                      ? isDarkMode
                                        ? "bg-green-900/30 text-green-500"
                                        : "bg-green-100 text-green-600"
                                      : isDarkMode
                                      ? "bg-amber-900/30 text-amber-500"
                                      : "bg-amber-100 text-amber-600"
                                  )}
                                >
                                  {activity.type === "completed"
                                    ? "Completed"
                                    : "Read"}
                                </Badge>
                              </div>
                              <span
                                className={cn(
                                  "text-xs",
                                  isDarkMode ? "text-gray-500" : "text-gray-500"
                                )}
                              >
                                {formatTimeAgo(activity.timestamp)}
                              </span>
                            </div>
                            <div
                              className={cn(
                                "text-xs",
                                isDarkMode ? "text-gray-400" : "text-gray-500"
                              )}
                            >
                              {formatDate(activity.timestamp)},{" "}
                              {formatTime(activity.timestamp)}
                            </div>
                          </div>
                        </div>
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-6">
                      <BookOpen className="h-12 w-12 mx-auto mb-3 opacity-20" />
                      <p
                        className={
                          isDarkMode ? "text-gray-400" : "text-gray-500"
                        }
                      >
                        No reading activity recorded yet.
                      </p>
                      <Button
                        variant="link"
                        className={cn(
                          "mt-2",
                          isDarkMode ? "text-amber-500" : "text-amber-600"
                        )}
                        onClick={() => navigate("/")}
                      >
                        Start reading a book
                      </Button>
                    </div>
                  )}
                </CardContent>
              </Card>
            </TabsContent>

            {/* Statistics Tab */}
            <TabsContent value="stats" className="space-y-6 mt-6">
              <Card
                className={cn(
                  isDarkMode
                    ? "bg-gray-800 border-gray-700"
                    : "bg-white border-gray-200"
                )}
              >
                <CardHeader>
                  <CardTitle>Reading Statistics</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="text-center py-8">
                    <p
                      className={isDarkMode ? "text-gray-400" : "text-gray-500"}
                    >
                      Detailed reading statistics charts will be implemented
                      here.
                    </p>
                  </div>
                </CardContent>
              </Card>
            </TabsContent>

            {/* Books Tab */}
            <TabsContent value="books" className="space-y-6 mt-6">
              <div className="grid gap-6 grid-cols-1 md:grid-cols-2">
                {/* Completed Books */}
                <Card
                  className={cn(
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardHeader className="pb-2">
                    <CardTitle className="text-lg flex items-center">
                      <BookText
                        className={cn(
                          "mr-2 h-5 w-5",
                          isDarkMode ? "text-amber-500" : "text-amber-600"
                        )}
                      />
                      Completed Books
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    {bookProgress?.filter((p) => p.isCompleted).length ? (
                      <div className="space-y-4">
                        {bookProgress
                          .filter((p) => p.isCompleted)
                          .map((progress) => (
                            <div
                              key={progress.id}
                              className={cn(
                                "flex items-center space-x-4 p-3 rounded-md cursor-pointer",
                                isDarkMode
                                  ? "hover:bg-gray-700"
                                  : "hover:bg-amber-50"
                              )}
                              onClick={() =>
                                navigate(`/book?id=${progress.book.id}`)
                              }
                            >
                              <img
                                src={progress.book.imageUrl}
                                alt={progress.book.title}
                                className="h-16 w-12 object-cover rounded"
                              />
                              <div className="flex-1">
                                <h4
                                  className={cn(
                                    "font-medium",
                                    isDarkMode ? "text-white" : "text-gray-900"
                                  )}
                                >
                                  {progress.book.title}
                                </h4>
                                <p
                                  className={cn(
                                    "text-sm",
                                    isDarkMode
                                      ? "text-gray-400"
                                      : "text-gray-500"
                                  )}
                                >
                                  {progress.book.author}
                                </p>
                                {progress.completedAt && (
                                  <p
                                    className={cn(
                                      "text-xs",
                                      isDarkMode
                                        ? "text-gray-500"
                                        : "text-gray-500"
                                    )}
                                  >
                                    Completed on{" "}
                                    {formatDate(progress.completedAt)}
                                  </p>
                                )}
                              </div>
                              <ChevronRight
                                className={cn(
                                  "h-5 w-5",
                                  isDarkMode ? "text-gray-600" : "text-gray-400"
                                )}
                              />
                            </div>
                          ))}
                      </div>
                    ) : (
                      <div className="text-center py-6">
                        <BookText className="h-12 w-12 mx-auto mb-3 opacity-20" />
                        <p
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          You haven't completed any books yet.
                        </p>
                      </div>
                    )}
                  </CardContent>
                </Card>

                {/* In Progress Books */}
                <Card
                  className={cn(
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardHeader className="pb-2">
                    <CardTitle className="text-lg flex items-center">
                      <BookOpen
                        className={cn(
                          "mr-2 h-5 w-5",
                          isDarkMode ? "text-amber-500" : "text-amber-600"
                        )}
                      />
                      In Progress
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    {bookProgress?.filter((p) => !p.isCompleted).length ? (
                      <div className="space-y-4">
                        {bookProgress
                          .filter((p) => !p.isCompleted)
                          .map((progress) => (
                            <div
                              key={progress.id}
                              className={cn(
                                "flex items-center space-x-4 p-3 rounded-md cursor-pointer",
                                isDarkMode
                                  ? "hover:bg-gray-700"
                                  : "hover:bg-amber-50"
                              )}
                              onClick={() =>
                                navigate(`/book?id=${progress.book.id}`)
                              }
                            >
                              <img
                                src={progress.book.imageUrl}
                                alt={progress.book.title}
                                className="h-16 w-12 object-cover rounded"
                              />
                              <div className="flex-1">
                                <h4
                                  className={cn(
                                    "font-medium",
                                    isDarkMode ? "text-white" : "text-gray-900"
                                  )}
                                >
                                  {progress.book.title}
                                </h4>
                                <p
                                  className={cn(
                                    "text-sm",
                                    isDarkMode
                                      ? "text-gray-400"
                                      : "text-gray-500"
                                  )}
                                >
                                  {progress.book.author}
                                </p>
                                <div className="flex items-center mt-1">
                                  <div
                                    className={cn(
                                      "h-1.5 rounded-full bg-gray-200 w-full mr-2",
                                      isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                    )}
                                  >
                                    <div
                                      className="h-full rounded-full bg-amber-500"
                                      style={{
                                        width: `${
                                          progress.percentComplete * 100
                                        }%`,
                                      }}
                                    />
                                  </div>
                                  <span
                                    className={cn(
                                      "text-xs min-w-[40px]",
                                      isDarkMode
                                        ? "text-gray-400"
                                        : "text-gray-500"
                                    )}
                                  >
                                    {Math.round(progress.percentComplete * 100)}
                                    %
                                  </span>
                                </div>
                              </div>
                              <ChevronRight
                                className={cn(
                                  "h-5 w-5",
                                  isDarkMode ? "text-gray-600" : "text-gray-400"
                                )}
                              />
                            </div>
                          ))}
                      </div>
                    ) : (
                      <div className="text-center py-6">
                        <BookOpen className="h-12 w-12 mx-auto mb-3 opacity-20" />
                        <p
                          className={
                            isDarkMode ? "text-gray-400" : "text-gray-500"
                          }
                        >
                          You don't have any books in progress.
                        </p>
                        <Button
                          variant="link"
                          className={cn(
                            "mt-2",
                            isDarkMode ? "text-amber-500" : "text-amber-600"
                          )}
                          onClick={() => navigate("/library")}
                        >
                          Browse your library
                        </Button>
                      </div>
                    )}
                  </CardContent>
                </Card>
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </main>
    </div>
  );
}
```

<div style='page-break-after: always;'></div>

<h2 id="file-61-modules-homepage-homepage-tsx">File 61: Modules/HomePage/HomePage.tsx</h2>

```typescript
import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useQuery } from "@tanstack/react-query";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { useAuth } from "../../hooks/userAuth";
import { cn } from "../../lib/utils";
import Sidebar from "../LibraryPage/Sidebar";
import { useSidebar } from "../../hooks/useSidebar";
import { apiFetch } from "../../endPointTypes/apiClient";
import { Book } from "../../endPointTypes/types";
import { 
  BookOpen, 
  Heart, 
  History, 
  FolderHeart, 
  BarChart3, 
  Clock, 
  BookText,
  ChevronRight,
  Plus
} from "lucide-react";
import { Button } from "../../components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../../components/ui/card";
import { Progress } from "../../components/ui/progress";
import { fetchUserCollections } from "../../api/collectionsApi";
import { getDashboardData } from "../../api/trackingApi";
import Skeleton from "../../components/ui/skeleton";
export default function HomePage() {
  const navigate = useNavigate();
  const { user, accessToken } = useAuth();
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const [booksLoading, setBooksLoading] = useState<string[]>([]);
  const { isCollapsed, toggleCollapse } = useSidebar([]);

  // Fetch currently reading books
  const { data: currentlyReading, isLoading: loadingCurrentReading } = useQuery(
    {
      queryKey: ["currentlyReading", user?.id],
      queryFn: async () => {
        const response = await apiFetch(
          "GET /book/getCurrentlyReading",
          {
            query: {
              userId: user?.id,
            },
          },
          {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          }
        );
        console.log("currentlyReadingBooks", response.data);
        return response.data.data as Book[];
      },
      enabled: !!user?.id && !!accessToken,
    }
  );
  // Fetch reading progress for all books
  const { data: bookProgress, isLoading: progressLoading } = useQuery({
    queryKey: ["bookProgress", user?.id],
    queryFn: async () => {
      const data = await apiFetch(
        "GET /tracking/progress/all",
        {},
        {
          headers: {
            Authorization: `Bearer ${accessToken}`,
          },
        }
      );
      console.log("bookProgress", data);
      return data.data as BookProgress[];
    },
    enabled: !!user?.id && !!accessToken,
  });

  // Fetch favorite books
  const { data: favoriteBooks, isLoading: loadingFavorites } = useQuery({
    queryKey: ["favoriteBooks", user?.id],
    queryFn: async () => {
      const response = await apiFetch(
        "GET /book/getFavorites",
        { query: { userId: user?.id } },
        { headers: { Authorization: `Bearer ${accessToken}` } }
      );
      return response.data?.data || [];
    },
    enabled: !!user?.id && !!accessToken,
  });

  // Fetch collections
  const { data: collectionsData, isLoading: loadingCollections } = useQuery({
    queryKey: ["collections"],
    queryFn: () => fetchUserCollections(user?.id || "", accessToken || ""),
    enabled: !!user?.id && !!accessToken,
  });

  const collections = collectionsData?.success
    ? collectionsData.data.slice(0, 3)
    : [];

  // Fetch dashboard data
  const { data: dashboardData, isLoading: loadingDashboard } = useQuery({
    queryKey: ["dashboard", user?.id],
    queryFn: async () => {
      if (!user?.id || !accessToken) {
        return {
          stats: {
            totalBooksRead: 0,
            totalPagesRead: 0,
            totalReadingTime: 0,
            averageReadingSpeed: null,
            favoriteGenre: null,
          },
          streak: {
            currentStreak: 0,
            longestStreak: 0,
            totalReadDays: 0,
            lastReadDate: null,
          },
          recentActivity: [],
          readingProgressData: [],
          genreDistribution: [],
        };
      }
      return getDashboardData(user.id, accessToken);
    },
    enabled: !!user?.id && !!accessToken,
  });

  // Function to get progress for a specific book
  const getBookProgress = (bookId: string) => {
    if (!bookProgress) return null;
    return bookProgress.find((progress) => progress.bookId === bookId);
  };

  // Format reading time from seconds to hours and minutes
  const formatReadingTime = (seconds: number = 0) => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);

    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes} mins`;
  };

  // Format date for display
  const formatDate = (dateString: string) => {
    if (!dateString) return "Never";
    const date = new Date(dateString);
    return date.toLocaleDateString("en-US", { month: "short", day: "numeric" });
  };

  return (
    <div className="flex h-screen overflow-hidden">
      <Sidebar
        isCollapsed={isCollapsed}
        toggleCollapse={toggleCollapse}
        setBooksLoading={setBooksLoading}
      />

      <main
        className={cn(
          "flex-1 p-6 overflow-auto",
          isDarkMode ? "bg-gray-950 text-gray-200" : "bg-amber-50 text-gray-900"
        )}
      >
        <div className="max-w-7xl mx-auto">
          {/* Welcome Section */}
          <div className="mb-8">
            <h1 className="text-3xl font-bold">
              Welcome back, {user?.username || "Reader"}
            </h1>
            <p
              className={cn(
                "mt-1",
                isDarkMode ? "text-gray-400" : "text-gray-600"
              )}
            >
              Here's an overview of your reading activity
            </p>
          </div>

          {/* Stats Cards */}
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
            <StatCard
              title="Reading Streak"
              value={`${dashboardData?.streak?.currentStreak || 0} days`}
              icon={<Clock className="h-5 w-5" />}
              description={
                dashboardData?.streak?.lastReadDate
                  ? `Last read: ${formatDate(
                      dashboardData.streak.lastReadDate
                    )}`
                  : "Start reading to build your streak"
              }
              isLoading={loadingDashboard}
              isDarkMode={isDarkMode}
            />

            <StatCard
              title="Books Read"
              value={dashboardData?.stats?.totalBooksRead?.toString() || "0"}
              icon={<BookText className="h-5 w-5" />}
              description="Completed books"
              isLoading={loadingDashboard}
              isDarkMode={isDarkMode}
            />

            <StatCard
              title="Pages Read"
              value={dashboardData?.stats?.totalPagesRead?.toString() || "0"}
              icon={<BookOpen className="h-5 w-5" />}
              description="Total pages completed"
              isLoading={loadingDashboard}
              isDarkMode={isDarkMode}
            />

            <StatCard
              title="Reading Time"
              value={formatReadingTime(dashboardData?.stats?.totalReadingTime)}
              icon={<BarChart3 className="h-5 w-5" />}
              description="Total time spent reading"
              isLoading={loadingDashboard}
              isDarkMode={isDarkMode}
            />
          </div>

          {/* Currently Reading Section */}
          <div className="mb-8">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold flex items-center">
                <BookOpen
                  className={cn(
                    "mr-2 h-5 w-5",
                    isDarkMode ? "text-amber-500" : "text-amber-600"
                  )}
                />
                Currently Reading
              </h2>
              <Button
                variant="ghost"
                size="sm"
                className={
                  isDarkMode
                    ? "text-amber-500 hover:text-amber-400"
                    : "text-amber-600 hover:text-amber-700"
                }
                onClick={() => navigate("/reading")}
              >
                View all <ChevronRight className="ml-1 h-4 w-4" />
              </Button>
            </div>

            {loadingCurrentReading ? (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {[1, 2, 3].map((i) => (
                  <Skeleton key={i} className="h-48 w-full rounded-lg" />
                ))}
              </div>
            ) : currentlyReading?.length > 0 ? (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {currentlyReading.slice(0, 3).map((item: any) => (
                  <Card
                    key={item.id}
                    className={cn(
                      "overflow-hidden cursor-pointer transition-all hover:shadow-md",
                      isDarkMode
                        ? "bg-gray-800 border-gray-700"
                        : "bg-white border-gray-200"
                    )}
                    onClick={() => navigate(`/book?id=${item.book.id}`)}
                  >
                    <CardContent className="flex p-4">
                      <div className="mr-4">
                        <div className="h-24 w-16 rounded overflow-hidden">
                          {item.imageUrl ? (
                            <img
                              src={item.imageUrl}
                              alt={item.title}
                              className="h-full w-full object-cover"
                            />
                          ) : (
                            <div
                              className={cn(
                                "h-full w-full flex items-center justify-center",
                                isDarkMode ? "bg-gray-700" : "bg-gray-100"
                              )}
                            >
                              <BookOpen className="h-8 w-8 text-gray-400" />
                            </div>
                          )}
                        </div>
                      </div>
                      <div className="flex-1">
                        <h3 className="font-medium line-clamp-1">
                          {item.title}
                        </h3>
                        <p
                          className={cn(
                            "text-sm line-clamp-1",
                            isDarkMode ? "text-gray-400" : "text-gray-600"
                          )}
                        >
                          {item.author}
                        </p>
                        <div className="mt-2">
                          <div className="flex justify-between text-xs mb-1">
                            <span>Progress</span>
                            <span>
                              {Math.round(
                                getBookProgress(item.id)?.percentComplete * 100
                              )}
                              %
                            </span>
                          </div>
                          <Progress
                            value={
                              getBookProgress(item.id)?.percentComplete * 100
                            }
                            className={cn(
                              "h-1.5",
                              isDarkMode ? "bg-gray-700" : "bg-gray-200"
                            )}
                            indicatorClassName="bg-amber-500"
                          />
                          <p
                            className={cn(
                              "text-xs mt-2",
                              isDarkMode ? "text-gray-400" : "text-gray-500"
                            )}
                          >
                            Last read: {formatDate(getBookProgress(item.id)?.lastReadAt)}
                          </p>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                ))}
              </div>
            ) : (
              <Card
                className={cn(
                  "border",
                  isDarkMode
                    ? "bg-gray-800 border-gray-700"
                    : "bg-white border-gray-200"
                )}
              >
                <CardContent className="flex flex-col items-center justify-center py-8">
                  <BookOpen
                    className={cn(
                      "h-12 w-12 mb-4",
                      isDarkMode ? "text-gray-700" : "text-gray-300"
                    )}
                  />
                  <p
                    className={cn(
                      "text-center mb-4",
                      isDarkMode ? "text-gray-400" : "text-gray-600"
                    )}
                  >
                    You're not currently reading any books
                  </p>
                  <Button
                    onClick={() => navigate("/library")}
                    className="bg-amber-600 hover:bg-amber-700 text-white"
                  >
                    Browse your library
                  </Button>
                </CardContent>
              </Card>
            )}
          </div>

          {/* Two Column Layout for Favorites and Collections */}
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
            {/* Favorites Section */}
            <div>
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold flex items-center">
                  <Heart
                    className={cn(
                      "mr-2 h-5 w-5",
                      isDarkMode ? "text-red-500" : "text-red-600"
                    )}
                  />
                  Favorites
                </h2>
                <Button
                  variant="ghost"
                  size="sm"
                  className={
                    isDarkMode
                      ? "text-red-500 hover:text-red-400"
                      : "text-red-600 hover:text-red-700"
                  }
                  onClick={() => navigate("/favorites")}
                >
                  View all <ChevronRight className="ml-1 h-4 w-4" />
                </Button>
              </div>

              {loadingFavorites ? (
                <div className="space-y-3">
                  {[1, 2, 3].map((i) => (
                    <Skeleton key={i} className="h-16 w-full rounded-lg" />
                  ))}
                </div>
              ) : favoriteBooks?.length > 0 ? (
                <Card
                  className={cn(
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardContent className="p-0">
                    <div className="divide-y divide-gray-200 dark:divide-gray-700">
                      {favoriteBooks.slice(0, 5).map((book: Book) => (
                        <div
                          key={book.id}
                          className={cn(
                            "flex items-center p-3 cursor-pointer",
                            isDarkMode
                              ? "hover:bg-gray-750"
                              : "hover:bg-gray-50"
                          )}
                          onClick={() => navigate(`/book?id=${book.id}`)}
                        >
                          <div className="h-12 w-8 mr-3 rounded overflow-hidden">
                            {book.imageUrl ? (
                              <img
                                src={book.imageUrl}
                                alt={book.title}
                                className="h-full w-full object-cover"
                              />
                            ) : (
                              <div
                                className={cn(
                                  "h-full w-full flex items-center justify-center",
                                  isDarkMode ? "bg-gray-700" : "bg-gray-100"
                                )}
                              >
                                <BookOpen className="h-4 w-4 text-gray-400" />
                              </div>
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <h3 className="font-medium truncate">
                              {book.title}
                            </h3>
                            <p
                              className={cn(
                                "text-sm truncate",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                              )}
                            >
                              {book.author}
                            </p>
                          </div>
                          <Heart className="h-4 w-4 text-red-500 fill-red-500 ml-2" />
                        </div>
                      ))}
                    </div>
                  </CardContent>
                </Card>
              ) : (
                <Card
                  className={cn(
                    "border",
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardContent className="flex flex-col items-center justify-center py-8">
                    <Heart
                      className={cn(
                        "h-12 w-12 mb-4",
                        isDarkMode ? "text-gray-700" : "text-gray-300"
                      )}
                    />
                    <p
                      className={cn(
                        "text-center mb-4",
                        isDarkMode ? "text-gray-400" : "text-gray-600"
                      )}
                    >
                      You haven't added any favorites yet
                    </p>
                    <Button
                      onClick={() => navigate("/library")}
                      className="bg-red-600 hover:bg-red-700 text-white"
                    >
                      Browse your library
                    </Button>
                  </CardContent>
                </Card>
              )}
            </div>

            {/* Collections Section
            <div>
              <div className="flex items-center justify-between mb-4">
                <h2 className="text-xl font-bold flex items-center">
                  <FolderHeart
                    className={cn(
                      "mr-2 h-5 w-5",
                      isDarkMode ? "text-amber-500" : "text-amber-600"
                    )}
                  />
                  Collections
                </h2>
                <Button
                  variant="ghost"
                  size="sm"
                  className={
                    isDarkMode
                      ? "text-amber-500 hover:text-amber-400"
                      : "text-amber-600 hover:text-amber-700"
                  }
                  onClick={() => navigate("/collections")}
                >
                  View all <ChevronRight className="ml-1 h-4 w-4" />
                </Button>
              </div>

              {loadingCollections ? (
                <div className="space-y-3">
                  {[1, 2, 3].map((i) => (
                    <Skeleton key={i} className="h-16 w-full rounded-lg" />
                  ))}
                </div>
              ) : collections?.length > 0 ? (
                <Card
                  className={cn(
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardContent className="p-0">
                    <div className="divide-y divide-gray-200 dark:divide-gray-700">
                      {collections.map((collection) => (
                        <div
                          key={collection.id}
                          className={cn(
                            "flex items-center p-3 cursor-pointer",
                            isDarkMode
                              ? "hover:bg-gray-750"
                              : "hover:bg-gray-50"
                          )}
                          onClick={() =>
                            navigate(`/collections/${collection.id}`)
                          }
                        >
                          <div
                            className={cn(
                              "h-12 w-12 rounded mr-3 flex items-center justify-center",
                              isDarkMode ? "bg-gray-700" : "bg-amber-100"
                            )}
                          >
                            {collection.imageUrl ? (
                              <img
                                src={collection.imageUrl}
                                alt={collection.name}
                                className="h-full w-full object-cover rounded"
                              />
                            ) : (
                              <FolderHeart
                                className={cn(
                                  "h-6 w-6",
                                  isDarkMode
                                    ? "text-amber-500/30"
                                    : "text-amber-500/50"
                                )}
                              />
                            )}
                          </div>
                          <div className="flex-1 min-w-0">
                            <h3 className="font-medium truncate">
                              {collection.name}
                            </h3>
                            <p
                              className={cn(
                                "text-sm truncate",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                              )}
                            >
                              {collection.bookCount || 0}{" "}
                              {collection.bookCount === 1 ? "book" : "books"}
                            </p>
                          </div>
                        </div>
                      ))}
                    </div>
                  </CardContent>
                  <CardFooter
                    className={cn(
                      "border-t p-3",
                      isDarkMode ? "border-gray-700" : "border-gray-200"
                    )}
                  >
                    <Button
                      variant="outline"
                      size="sm"
                      className="w-full"
                      onClick={() => navigate("/collections")}
                    >
                      <Plus className="h-4 w-4 mr-2" />
                      Create new collection
                    </Button>
                  </CardFooter>
                </Card>
              ) : (
                <Card
                  className={cn(
                    "border",
                    isDarkMode
                      ? "bg-gray-800 border-gray-700"
                      : "bg-white border-gray-200"
                  )}
                >
                  <CardContent className="flex flex-col items-center justify-center py-8">
                    <FolderHeart
                      className={cn(
                        "h-12 w-12 mb-4",
                        isDarkMode ? "text-gray-700" : "text-gray-300"
                      )}
                    />
                    <p
                      className={cn(
                        "text-center mb-4",
                        isDarkMode ? "text-gray-400" : "text-gray-600"
                      )}
                    >
                      You haven't created any collections yet
                    </p>
                    <Button
                      onClick={() => navigate("/collections")}
                      className="bg-amber-600 hover:bg-amber-700 text-white"
                    >
                      Create a collection
                    </Button>
                  </CardContent>
                </Card>
              )}
            </div> */}
          </div>

          {/* Recent Activity Section */}
          <div className="mb-8">
            <div className="flex items-center justify-between mb-4">
              <h2 className="text-xl font-bold flex items-center">
                <History
                  className={cn(
                    "mr-2 h-5 w-5",
                    isDarkMode ? "text-blue-500" : "text-blue-600"
                  )}
                />
                Recent Activity
              </h2>
              <Button
                variant="ghost"
                size="sm"
                className={
                  isDarkMode
                    ? "text-blue-500 hover:text-blue-400"
                    : "text-blue-600 hover:text-blue-700"
                }
                onClick={() => navigate("/history")}
              >
                View history <ChevronRight className="ml-1 h-4 w-4" />
              </Button>
            </div>

            {loadingDashboard ? (
              <div className="space-y-3">
                {[1, 2, 3, 4].map((i) => (
                  <Skeleton key={i} className="h-12 w-full rounded-lg" />
                ))}
              </div>
            ) : dashboardData?.recentActivity?.length > 0 ? (
              <Card
                className={cn(
                  isDarkMode
                    ? "bg-gray-800 border-gray-700"
                    : "bg-white border-gray-200"
                )}
              >
                <CardContent className="p-0">
                  <div className="divide-y divide-gray-200 dark:divide-gray-700">
                    {dashboardData.recentActivity
                      .slice(0, 5)
                      .map((activity, index) => (
                        <div
                          key={index}
                          className={cn(
                            "flex justify-between items-center p-3",
                            isDarkMode
                              ? "hover:bg-gray-750"
                              : "hover:bg-gray-50"
                          )}
                        >
                          <p
                            className={
                              isDarkMode ? "text-gray-300" : "text-gray-700"
                            }
                          >
                            {activity.description}
                          </p>
                          <span
                            className={cn(
                              "text-sm",
                              isDarkMode ? "text-gray-400" : "text-gray-500"
                            )}
                          >
                            {formatDate(activity.timestamp)}
                          </span>
                        </div>
                      ))}
                  </div>
                </CardContent>
              </Card>
            ) : (
              <Card
                className={cn(
                  "border",
                  isDarkMode
                    ? "bg-gray-800 border-gray-700"
                    : "bg-white border-gray-200"
                )}
              >
                <CardContent className="flex flex-col items-center justify-center py-8">
                  <History
                    className={cn(
                      "h-12 w-12 mb-4",
                      isDarkMode ? "text-gray-700" : "text-gray-300"
                    )}
                  />
                  <p
                    className={cn(
                      "text-center mb-4",
                      isDarkMode ? "text-gray-400" : "text-gray-600"
                    )}
                  >
                    No reading activity recorded yet
                  </p>
                  <Button
                    onClick={() => navigate("/")}
                    className="bg-blue-600 hover:bg-blue-700 text-white"
                  >
                    Start reading
                  </Button>
                </CardContent>
              </Card>
            )}
          </div>
        </div>
      </main>
    </div>
  );
}

// Stat Card Component
interface StatCardProps {
  title: string;
  value: string;
  icon: React.ReactNode;
  description?: string;
  isLoading?: boolean;
  isDarkMode?: boolean;
}

function StatCard({ title, value, icon, description, isLoading, isDarkMode }: StatCardProps) {
  if (isLoading) {
    return (
      <Card className={cn(
        "border",
        isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
      )}>
        <CardContent className="p-6">
          <div className="flex items-center mb-2">
            <Skeleton className="h-5 w-5 rounded-full mr-2" />
            <Skeleton className="h-4 w-24 rounded" />
          </div>
          <Skeleton className="h-8 w-16 rounded mt-2" />
          <Skeleton className="h-3 w-32 rounded mt-2" />
        </CardContent>
      </Card>
    );
  }
  
  return (
    <Card className={cn(
      "border",
      isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
    )}>
      <CardContent className="p-6">
        <div className="flex items-center mb-2">
          <div className={cn(
            "mr-2",
            isDarkMode ? "text-amber-500" : "text-amber-600"
          )}>
            {icon}
          </div>
          <h3 className={cn(
            "text-sm font-medium",
            isDarkMode ? "text-gray-400" : "text-gray-500"
          )}>
            {title}
          </h3>
        </div>
        <p className="text-2xl font-bold">{value}</p>
        {description && (
          <p className={cn(
            "text-xs mt-1",
            isDarkMode ? "text-gray-400" : "text-gray-500"
          )}>
            {description}
          </p>
        )}
      </CardContent>
    </Card>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-62-modules-librarypage-bookcard-tsx">File 62: Modules/LibraryPage/BookCard.tsx</h2>

```typescript
import { BookOpen, Heart, MoreVertical, Trash2, Star, ExternalLink, Info } from "lucide-react";
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { Button } from "../../components/ui/button";
import {
    Card,
    CardContent,
    CardFooter,
} from "../../components/ui/card";
import {
    Dialog,
    DialogClose,
    DialogContent,
    DialogDescription,
    DialogFooter,
    DialogHeader,
    DialogTitle,
} from "../../components/ui/dialog";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "../../components/ui/dropdown-menu";
import { Book } from "../../endPointTypes/types";
import { cn } from "../../lib/utils";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { Badge } from "../../components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "../../components/ui/tooltip";
import { useAuth } from "../../hooks/userAuth";

type BookCardProps = {
    book: Book;
    deleteBook: (bookId: string) => Promise<void>;
    selectBook: (bookId: string) => void;
    isSelected?: boolean;
};

export default function BookCard({
    book,
    deleteBook,
    selectBook,
    isSelected = false,
}: BookCardProps) {
    const [isLiked, setIsLiked] = useState(book.liked || false);
    const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
    const [isHovering, setIsHovering] = useState(false);
    const navigate = useNavigate();
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const {accessToken} = useAuth();
    useEffect(() => {
        const updateBook = async () => {
            await fetch(`/api/book/${book.id}`, {
                method: "PATCH",
                body: JSON.stringify({ liked: isLiked }),
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": `Bearer ${accessToken}`,
                },
            });
        };
        updateBook();
    }, [isLiked]);
    const handleGoToBook = () => {
        navigate(`/book?id=${book.id}`);
    };
    
    const formatDate = (dateString: string | Date) => {
        const date = new Date(dateString);
        return date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' });
    };

    return (
        <TooltipProvider>
            <Card 
                className={cn(
                    "flex flex-col h-full transition-all duration-200 overflow-hidden group",
                    isDarkMode 
                        ? "bg-zinc-800 border-gray-700 hover:border-gray-600" 
                        : "bg-white border-gray-200 hover:border-gray-300",
                    isSelected && (isDarkMode 
                        ? "ring-2 ring-blue-500" 
                        : "ring-2 ring-blue-400")
                )}
                onMouseEnter={() => setIsHovering(true)}
                onMouseLeave={() => setIsHovering(false)}
            >
                <div className="relative overflow-hidden">
                    <img
                        src={book.imageUrl}
                        alt={book.title}
                        className={cn(
                            "w-full h-64 object-cover transition-all duration-300",
                            isHovering ? "scale-105 brightness-75" : "scale-100"
                        )}
                    />
                    
                    {/* Overlay with read button */}
                    <div className={cn(
                        "absolute inset-0 flex items-center justify-center transition-opacity duration-300",
                        isHovering ? "opacity-100" : "opacity-0"
                    )}>
                        <Button 
                            className="w-3/4 shadow-lg" 
                            onClick={handleGoToBook}
                            variant={isDarkMode ? "default" : "secondary"}
                            size="sm"
                        >
                            <BookOpen className="mr-2 h-4 w-4" /> Read Now
                        </Button>
                    </div>
                    
                    {/* Top action buttons */}
                    <div className="absolute top-2 right-2 flex space-x-1">
                        <Tooltip>
                            <TooltipTrigger asChild>
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className={cn(
                                        "rounded-full bg-black/40 backdrop-blur-sm hover:bg-black/60 transition-all",
                                        isLiked ? "text-red-400 hover:text-red-300" : "text-white hover:text-white",
                                        isHovering ? "opacity-100" : "opacity-0 sm:opacity-100"
                                    )}
                                    onClick={() => setIsLiked(!isLiked)}
                                >
                                    <Heart className={cn(
                                        "h-4 w-4",
                                        isLiked && "fill-current"
                                    )} />
                                </Button>
                            </TooltipTrigger>
                            <TooltipContent>
                                {isLiked ? "Remove from favorites" : "Add to favorites"}
                            </TooltipContent>
                        </Tooltip>
                        
                        <DropdownMenu>
                            <Tooltip>
                                <TooltipTrigger asChild>
                                    <DropdownMenuTrigger asChild>
                                        <Button
                                            variant="ghost"
                                            size="icon"
                                            className={cn(
                                                "rounded-full bg-black/40 backdrop-blur-sm hover:bg-black/60 text-white transition-all",
                                                isHovering ? "opacity-100" : "opacity-0 sm:opacity-100"
                                            )}
                                        >
                                            <MoreVertical className="h-4 w-4" />
                                        </Button>
                                    </DropdownMenuTrigger>
                                </TooltipTrigger>
                                <TooltipContent>
                                    More options
                                </TooltipContent>
                            </Tooltip>
                            <DropdownMenuContent align="end" className={isDarkMode ? "bg-zinc-800 border-gray-700" : "bg-white"}>
                                <DropdownMenuItem 
                                    onClick={() => selectBook(book.id)}
                                    className={isDarkMode ? "hover:bg-zinc-700" : ""}
                                >
                                    <Info className="h-4 w-4 mr-2" />
                                    View Details
                                </DropdownMenuItem>
                                <DropdownMenuItem 
                                    onClick={handleGoToBook}
                                    className={isDarkMode ? "hover:bg-zinc-700" : ""}
                                >
                                    <BookOpen className="h-4 w-4 mr-2" />
                                    Read Book
                                </DropdownMenuItem>
                                <DropdownMenuItem 
                                    onClick={() => window.open(`/book?id=${book.id}`, "_blank")}
                                    className={isDarkMode ? "hover:bg-zinc-700" : ""}
                                >
                                    <ExternalLink className="h-4 w-4 mr-2" />
                                    Open in New Tab
                                </DropdownMenuItem>
                                <DropdownMenuSeparator />
                                <DropdownMenuItem 
                                    onClick={() => setIsDeleteDialogOpen(true)}
                                    className={cn(
                                        "text-red-500",
                                        isDarkMode ? "hover:bg-zinc-700" : ""
                                    )}
                                >
                                    <Trash2 className="h-4 w-4 mr-2" />
                                    Delete
                                </DropdownMenuItem>
                            </DropdownMenuContent>
                        </DropdownMenu>
                    </div>
                    
                    {/* Badges */}
                    {isLiked && (
                        <div className="absolute top-2 left-2">
                            <Badge variant="default" className="bg-red-500 hover:bg-red-600">
                                <Star className="h-3 w-3 mr-1 fill-current" />
                                Favorite
                            </Badge>
                        </div>
                    )}
                </div>
                
                <CardContent className="flex-1 p-4">
                    <div className="flex justify-between items-start">
                        <div className="space-y-1 flex-1">
                            <h3 className={cn(
                                "text-lg font-semibold line-clamp-1",
                                isDarkMode ? "text-gray-200" : "text-gray-800"
                            )}>
                                {book.title}
                            </h3>
                            <p className={cn(
                                "text-sm line-clamp-1",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                            )}>
                                {book.author}
                            </p>
                        </div>
                    </div>
                    
                    <div className="mt-2">
                        <p className={cn(
                            "text-xs",
                            isDarkMode ? "text-gray-500" : "text-gray-500"
                        )}>
                            Added: {formatDate(book.dateAdded)}
                        </p>
                        
                        {book.totalPages && (
                            <p className={cn(
                                "text-xs mt-1",
                                isDarkMode ? "text-gray-500" : "text-gray-500"
                            )}>
                                {book.totalPages} pages
                            </p>
                        )}
                    </div>
                    
                    {book.genres && book.genres.length > 0 && (
                        <div className="mt-3 flex flex-wrap gap-1">
                            {book.genres.slice(0, 2).map((genre, index) => (
                                <span 
                                    key={index}
                                    className={cn(
                                        "text-xs px-2 py-0.5 rounded-full",
                                        isDarkMode 
                                            ? "bg-zinc-700 text-gray-300" 
                                            : "bg-gray-100 text-gray-700"
                                    )}
                                >
                                    {genre}
                                </span>
                            ))}
                            {book.genres.length > 2 && (
                                <span className={cn(
                                    "text-xs px-2 py-0.5 rounded-full",
                                    isDarkMode 
                                        ? "bg-zinc-700 text-gray-300" 
                                        : "bg-gray-100 text-gray-700"
                                )}>
                                    +{book.genres.length - 2}
                                </span>
                            )}
                        </div>
                    )}
                </CardContent>
                
                <CardFooter className="p-4 pt-0">
                    <div className="w-full flex gap-2">
                        <Button 
                            variant="outline"
                            onClick={() => selectBook(book.id)}
                            className={cn(
                                "flex-1",
                                isDarkMode 
                                    ? "border-gray-700 hover:bg-zinc-700 text-gray-300" 
                                    : "border-gray-200 hover:bg-gray-50 text-gray-700"
                            )}
                            size="sm"
                        >
                            <Info className="mr-2 h-4 w-4" />
                            Details
                        </Button>
                        
                        <Button 
                            onClick={handleGoToBook}
                            variant={isDarkMode ? "default" : "secondary"}
                            className="flex-1"
                            size="sm"
                        >
                            <BookOpen className="mr-2 h-4 w-4" />
                            Read
                        </Button>
                    </div>
                </CardFooter>
                
                <Dialog open={isDeleteDialogOpen} onOpenChange={setIsDeleteDialogOpen}>
                    <DialogContent className={cn(
                        "max-w-md",
                        isDarkMode 
                            ? "bg-zinc-800 text-gray-100 border-gray-700" 
                            : "bg-white text-gray-800 border-gray-200"
                    )}>
                        <DialogHeader>
                            <DialogTitle className={cn(
                                "text-xl",
                                isDarkMode ? "text-gray-100" : "text-gray-900"
                            )}>
                                Delete "{book.title}"?
                            </DialogTitle>
                            <DialogDescription className={isDarkMode ? "text-gray-400" : "text-gray-500"}>
                                Are you sure you want to delete this book? This action cannot be undone.
                            </DialogDescription>
                        </DialogHeader>
                        <DialogFooter className="mt-6 flex justify-end space-x-3">
                            <DialogClose asChild>
                                <Button 
                                    variant="outline"
                                    className={isDarkMode 
                                        ? "border-gray-700 hover:bg-zinc-700 text-gray-300" 
                                        : "border-gray-200 hover:bg-gray-50 text-gray-700"
                                    }
                                >
                                    Cancel
                                </Button>
                            </DialogClose>
                            <Button
                                variant="destructive"
                                onClick={() => {
                                    deleteBook(book.id);
                                    setIsDeleteDialogOpen(false);
                                }}
                            >
                                <Trash2 className="mr-2 h-4 w-4" />
                                Delete
                            </Button>
                        </DialogFooter>
                    </DialogContent>
                </Dialog>
            </Card>
        </TooltipProvider>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-63-modules-librarypage-bookcardskeleton-tsx">File 63: Modules/LibraryPage/BookCardSkeleton.tsx</h2>

```typescript
import { cn } from "../../lib/utils";

type BookCardSkeletonProps = {
    isDarkMode?: boolean;
};

export default function BookCardSkeleton({ isDarkMode = false }: BookCardSkeletonProps) {
    return (
        <div className={cn(
            "flex flex-col animate-pulse rounded-lg overflow-hidden border",
            isDarkMode ? "bg-zinc-800 border-gray-700" : "bg-white border-gray-200"
        )}>
            <div className="relative">
                <div className={cn(
                    "w-full h-64",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                )}></div>
                <div className="absolute top-2 right-2 flex space-x-1">
                    <div className={cn(
                        "w-8 h-8 rounded-full",
                        isDarkMode ? "bg-zinc-600" : "bg-gray-300"
                    )}></div>
                    <div className={cn(
                        "w-8 h-8 rounded-full",
                        isDarkMode ? "bg-zinc-600" : "bg-gray-300"
                    )}></div>
                </div>
            </div>
            <div className="flex-1 p-4 space-y-3">
                <div className={cn(
                    "h-5 rounded",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-300"
                )} style={{ width: '70%' }}></div>
                <div className={cn(
                    "h-4 rounded",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                )} style={{ width: '50%' }}></div>
                <div className={cn(
                    "h-3 rounded",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                )} style={{ width: '40%' }}></div>
                <div className="flex space-x-2 pt-2">
                    <div className={cn(
                        "h-5 rounded-full px-3",
                        isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                    )} style={{ width: '25%' }}></div>
                    <div className={cn(
                        "h-5 rounded-full px-3",
                        isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                    )} style={{ width: '25%' }}></div>
                </div>
            </div>
            <div className="p-4 pt-0">
                <div className={cn(
                    "h-9 rounded",
                    isDarkMode ? "bg-zinc-700" : "bg-gray-200"
                )}></div>
            </div>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-64-modules-librarypage-bookcards-tsx">File 64: Modules/LibraryPage/BookCards.tsx</h2>

```typescript
import { Book } from "../../endPointTypes/types";
import BookCard from "./BookCard";
import BookCardSkeleton from "./BookCardSkeleton";

type BookCardsProps = {
    bookData: Book[] | undefined;
    booksLoading: string[];
    deleteBook: (bookId: string) => Promise<void>;
    selectBook: (bookId: string) => void;
};

export default function BookCards({
    bookData,
    booksLoading,
    deleteBook,
    selectBook,
}: BookCardsProps) {
    const bookCards = bookData?.map((book) => (
        <BookCard
            book={book}
            key={book.id}
            deleteBook={deleteBook}
            selectBook={selectBook}
        />
    ));

    const bookSkeletons = booksLoading.map((_, index) => (
        <BookCardSkeleton key={`skeleton-${index}`} />
    ));

    return (
        <div>
            <h1 className="text-4xl font-bold mb-8">Your Library</h1>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 gap-6">
                {bookCards}
                {bookSkeletons}
                {bookData?.length === 0 && booksLoading.length === 0 && (
                    <p className="col-span-full text-center text-gray-400 text-lg">
                        No books available. Start by adding some books to your
                        library!
                    </p>
                )}
            </div>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-65-modules-librarypage-bookinfopage-tsx">File 65: Modules/LibraryPage/BookInfoPage.tsx</h2>

```typescript
import { BookOpen, ChevronLeft, ChevronRight, Calendar, Tag, User, Clock, Star } from "lucide-react";
import { Button } from "../../components/ui/button";
import { useNavigate } from "react-router-dom";
import { Book } from "../../endPointTypes/types";
import { useState, useEffect } from "react";
import { cn } from "../../lib/utils";
import { Badge } from "../../components/ui/badge";

type BookInfoPageProps = {
    infoOpen: boolean;
    selectedBook: Book | null | undefined;
    setInfoOpen: React.Dispatch<React.SetStateAction<boolean>>;
    isDarkMode: boolean;
};

export default function BookInfoPage({
    infoOpen,
    selectedBook,
    setInfoOpen,
    isDarkMode,
}: BookInfoPageProps) {
    const navigate = useNavigate();
    const [contentVisible, setContentVisible] = useState(infoOpen);
    
    // Handle content visibility based on sidebar state
    useEffect(() => {
        if (!infoOpen) {
            setContentVisible(false);
        } else {
            // Small delay to ensure content appears after sidebar expands
            const timer = setTimeout(() => {
                setContentVisible(true);
            }, 150); // Half of the sidebar transition duration
            return () => clearTimeout(timer);
        }
    }, [infoOpen]);
    
    const startReading = () => {
        if (selectedBook) {
            navigate(`/book?id=${selectedBook.id}`);
        }
    };
    console.log(selectedBook);

    return (
        <aside
            className={cn(
                "transform transition-all duration-300 ease-in-out border-l h-screen",
                isDarkMode 
                    ? "bg-gray-900 border-gray-800 text-gray-200" 
                    : "bg-white border-gray-200 text-gray-800",
                infoOpen ? "w-80" : "w-16"
            )}
        >
            <div className="h-full flex flex-col">
                <div className={cn(
                    "p-4 border-b flex items-center justify-between",
                    isDarkMode ? "border-gray-800" : "border-gray-200"
                )}>
                    {infoOpen && contentVisible && (
                        <h3 className={cn(
                            "text-sm font-medium",
                            isDarkMode ? "text-gray-300" : "text-gray-700"
                        )}>
                            Book Details
                        </h3>
                    )}
                    <Button
                        variant="ghost"
                        size="icon"
                        className={cn(
                            "h-8 w-8",
                            isDarkMode 
                                ? "text-gray-400 hover:text-white" 
                                : "text-gray-600 hover:text-gray-900",
                            !infoOpen && "mx-auto"
                        )}
                        onClick={() => setInfoOpen(!infoOpen)}
                    >
                        {infoOpen ? (
                            <ChevronRight className="h-4 w-4" />
                        ) : (
                            <ChevronLeft className="h-4 w-4" />
                        )}
                    </Button>
                </div>
                
                <div className="flex-1 overflow-auto">
                    {infoOpen && contentVisible ? (
                        selectedBook ? (
                            <div className="p-4 space-y-6">
                                <div className="relative">
                                    <div className="flex justify-center">
                                        <img
                                            src={selectedBook.imageUrl}
                                            alt={selectedBook.title}
                                            className="w-48 h-64 object-cover rounded-md shadow-md"
                                        />
                                    </div>
                                    <div className="absolute -top-2 -right-2">
                                        <Badge variant={isDarkMode ? "default" : "secondary"} className="font-normal">
                                            <Star className="h-3 w-3 mr-1 text-amber-400 fill-amber-400" />
                                            Favorite
                                        </Badge>
                                    </div>
                                </div>
                                
                                <div className="space-y-4">
                                    <h2 className={cn(
                                        "text-xl font-serif font-bold text-center",
                                        isDarkMode ? "text-white" : "text-amber-800"
                                    )}>
                                        {selectedBook.title}
                                    </h2>
                                    
                                    <div className="space-y-2">
                                        <div className="flex items-center">
                                            <User className={cn(
                                                "h-4 w-4 mr-2 flex-shrink-0",
                                                isDarkMode ? "text-amber-400" : "text-amber-500"
                                            )} />
                                            <p className={cn(
                                                "text-sm",
                                                isDarkMode ? "text-amber-300" : "text-amber-700"
                                            )}>
                                                {selectedBook.author}
                                            </p>
                                        </div>
                                        
                                        <div className="flex items-center">
                                            <Calendar className={cn(
                                                "h-4 w-4 mr-2 flex-shrink-0",
                                                isDarkMode ? "text-amber-400" : "text-amber-500"
                                            )} />
                                            <p className={cn(
                                                "text-sm",
                                                isDarkMode ? "text-amber-300" : "text-amber-700"
                                            )}>
                                                Added: {new Date(selectedBook.dateAdded).toLocaleDateString()}
                                            </p>
                                        </div>
                                        
                                        <div className="flex items-center">
                                            <Clock className={cn(
                                                "h-4 w-4 mr-2 flex-shrink-0",
                                                isDarkMode ? "text-amber-400" : "text-amber-500"
                                            )} />
                                            <p className={cn(
                                                "text-sm",
                                                isDarkMode ? "text-amber-300" : "text-amber-700"
                                            )}>
                                                {selectedBook.totalPages || 0} pages
                                            </p>
                                        </div>
                                        
                                        {selectedBook.genres && selectedBook.genres.length > 0 && (
                                            <div className="flex items-start">
                                                <Tag className={cn(
                                                    "h-4 w-4 mr-2 mt-1 flex-shrink-0",
                                                    isDarkMode ? "text-amber-400" : "text-amber-500"
                                                )} />
                                                <div className="flex flex-wrap gap-1">
                                                    {selectedBook.genres.map((genre, index) => (
                                                        <span 
                                                            key={index}
                                                            className={cn(
                                                                "text-xs px-2 py-0.5 rounded-full",
                                                                isDarkMode 
                                                                    ? "bg-amber-700 text-amber-300" 
                                                                    : "bg-amber-100 text-amber-700"
                                                            )}
                                                        >
                                                            {String(genre)}
                                                        </span>
                                                    ))}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                    
                                    {selectedBook.description && (
                                        <div className="pt-2">
                                            <h3 className={cn(
                                                "text-sm font-medium mb-2",
                                                isDarkMode ? "text-amber-300" : "text-amber-700"
                                            )}>
                                                Description
                                            </h3>
                                            <p className={cn(
                                                "text-sm",
                                                isDarkMode ? "text-amber-400" : "text-amber-600"
                                            )}>
                                                {selectedBook.description}
                                            </p>
                                        </div>
                                    )}
                                </div>
                                
                                <div className="pt-4">
                                    <Button
                                        className="w-full bg-amber-600 hover:bg-amber-700 text-white"
                                        onClick={startReading}
                                    >
                                        <BookOpen className="mr-2 h-4 w-4" /> 
                                        Start Reading
                                    </Button>
                                </div>
                            </div>
                        ) : (
                            <div className="h-full flex items-center justify-center p-4">
                                <p className={cn(
                                    "text-center",
                                    isDarkMode ? "text-gray-400" : "text-gray-500"
                                )}>
                                    Select a book to view details
                                </p>
                            </div>
                        )
                    ) : (
                        <div className="flex flex-col items-center space-y-4"></div>
                    )}
                </div>
            </div>
        </aside>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-66-modules-librarypage-librarypage-tsx">File 66: Modules/LibraryPage/LibraryPage.tsx</h2>

```typescript
import { useEffect, useState } from "react";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { Moon, Sun, Search, Filter, BookOpen } from "lucide-react";
import { Button } from "../../components/ui/button";
import { Input } from "../../components/ui/input";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useToast } from "../../hooks/use-toast";
import { useAuth } from "../../hooks/userAuth";
import { useSidebar } from "../../hooks/useSidebar";
import BookCard from "./BookCard";
import BookCardSkeleton from "./BookCardSkeleton";
import BookInfoPage from "./BookInfoPage";
import Sidebar from "./Sidebar";
import { Book, BookGenre } from "../../endPointTypes/types";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";

const fetchBooks = async (userId: string | undefined) => {
    if (!userId) {
        throw new Error("No user ID found");
    }
    const token = localStorage.getItem("token");
    if (!token) {
        throw new Error("No token found");
    }
    const data = await apiFetch(
        "GET /book/getUserBooks",
        {
            query: {
                userId: userId,
            },
        },
        {
            headers: {
                Authorization: `Bearer ${token}`,
            },
        }
    );
    return data.data;
};

export default function LibraryPage() {
    const { accessToken, user } = useAuth();
    const [infoOpen, setInfoOpen] = useState(true);
    const [selectedBook, setSelectedBook] = useState<null | string>(null);
    const [mounted, setMounted] = useState(false);
    const [themeMode, setThemeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const [searchQuery, setSearchQuery] = useState("");
    const [filterOpen, setFilterOpen] = useState(false);
    
    const queryClient = useQueryClient();
    const { toast } = useToast();
    
    const { data: bookData } = useQuery<Book[]>({
        queryKey: ["book"],
        queryFn: () => fetchBooks(user?.id) as Promise<Book[]>,
        enabled: !!accessToken && !!user,
    });
    
    const { booksLoading, setBooksLoading, isCollapsed, toggleCollapse } =
        useSidebar(bookData);

    useEffect(() => setMounted(true), []);
    if (!mounted) return null;
    
    const deleteBook = async (bookId: string) => {
        try {
            const bookDeleted = await apiFetch(
                "DELETE /book/:id",
                { params: { id: bookId } },
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
            if (bookDeleted.status === 200) {
                queryClient.invalidateQueries({ queryKey: ["book"] });
                toast({
                    title: "Book Deleted successfully",
                    duration: 5000,
                });
                if (selectedBook === bookId) {
                    setSelectedBook(null);
                }
            } else {
                toast({
                    title: "Failed to delete book",
                    duration: 5000,
                });
            }
        } catch (error) {
            console.error(error);
        }
    };
    
    const selectBook = (bookId: string) => {
        setSelectedBook(bookId);
        setInfoOpen(true);
    };
    
    const filteredBooks = bookData?.filter(book => {
        if (!searchQuery) return true;
        
        const query = searchQuery.toLowerCase();
        return (
            book.title.toLowerCase().includes(query) ||
            book.author.toLowerCase().includes(query) ||
            book.genres?.some((genre: BookGenre) => genre.name.toLowerCase().includes(query))
        );
    });
    
    const book = bookData?.filter((book) => book.id === selectedBook)[0];
    
    if (!bookData) return null;
    
    return (
        <div className={cn(
            "flex h-screen",
            isDarkMode ? "bg-gray-950" : "bg-amber-50"
        )}>
            <Sidebar
                toggleCollapse={toggleCollapse}
                isCollapsed={isCollapsed}
                setBooksLoading={setBooksLoading}
            />
            
            {/* Main Content */}
            <main className={cn(
                "flex-1 p-6 overflow-auto transition-all duration-300 ease-in-out",
                isDarkMode ? "text-gray-200" : "text-gray-900"
            )}>
                <div className="flex flex-col space-y-4 mb-6">
                    <div className="flex justify-between items-center">
                        <h1 className={cn(
                            "text-3xl font-serif font-bold",
                            isDarkMode ? "text-gray-100" : "text-amber-800"
                        )}>My Library</h1>
                        
                    </div>
                    
                    <div className="relative">
                        <Search className={cn(
                            "absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4",
                            isDarkMode ? "text-gray-500" : "text-amber-500"
                        )} />
                        <Input
                            placeholder="Search by title, author, or genre..."
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                            className={cn(
                                "pl-10",
                                isDarkMode 
                                    ? "bg-gray-900 border-gray-800 text-gray-200 placeholder:text-gray-500" 
                                    : "bg-white border-amber-200 text-gray-900 placeholder:text-gray-400"
                            )}
                        />
                    </div>
                   
                </div>
                
                {filteredBooks?.length === 0 ? (
                    <div className={cn(
                        "text-center py-12",
                        isDarkMode ? "text-gray-400" : "text-amber-600"
                    )}>
                        <p className="text-lg">No books found matching your search.</p>
                        {searchQuery && (
                            <Button 
                                variant="link" 
                                onClick={() => setSearchQuery("")}
                                className={isDarkMode ? "text-amber-400" : "text-amber-700"}
                            >
                                Clear search
                            </Button>
                        )}
                    </div>
                ) : (
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4 2xl:grid-cols-5 gap-6">
                        {filteredBooks?.map((book) => (
                            <BookCard
                                key={book.id}
                                deleteBook={deleteBook}
                                book={book}
                                selectBook={selectBook}
                                isSelected={selectedBook === book.id}
                            />
                        ))}
                        {booksLoading.map((bookId) => (
                            <BookCardSkeleton key={bookId} isDarkMode={isDarkMode} />
                        ))}
                    </div>
                )}
                
                {filteredBooks?.length === 0 && bookData.length > 0 && searchQuery && (
                    <div className="mt-8 text-center">
                        <p className={isDarkMode ? "text-gray-400" : "text-amber-600"}>
                            No books match your search criteria.
                        </p>
                    </div>
                )}
                
                {bookData.length === 0 && booksLoading.length === 0 && (
                    <div className={cn(
                        "text-center py-16 px-4 rounded-lg border",
                        isDarkMode 
                            ? "bg-gray-900/30 border-gray-800" 
                            : "bg-amber-50 border-amber-200"
                    )}>
                        <BookOpen className={cn(
                            "mx-auto h-12 w-12 mb-4",
                            isDarkMode ? "text-amber-500" : "text-amber-500"
                        )} />
                        <h3 className={cn(
                            "text-xl font-serif font-medium mb-2",
                            isDarkMode ? "text-gray-200" : "text-amber-800"
                        )}>
                            Your library is empty
                        </h3>
                        <p className={cn(
                            "mb-6 max-w-md mx-auto",
                            isDarkMode ? "text-gray-400" : "text-amber-700"
                        )}>
                            Start by adding some books to your library using the "Add Book" button in the sidebar.
                        </p>
                        <Button
                            className={cn(
                                "bg-amber-600 hover:bg-amber-700 text-white",
                                "transition-all duration-200"
                            )}
                            onClick={() => toggleCollapse(false)}
                        >
                            <BookOpen className="mr-2 h-4 w-4" />
                            Add Your First Book
                        </Button>
                    </div>
                )}
            </main>
            
            <BookInfoPage
                infoOpen={infoOpen}
                selectedBook={book}
                setInfoOpen={setInfoOpen}
                isDarkMode={isDarkMode}
            />
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-67-modules-librarypage-sidebar-tsx">File 67: Modules/LibraryPage/Sidebar.tsx</h2>

```typescript
import {
    ChevronLeft,
    ChevronRight,
    Home,
    Library,
    Settings,
    Sliders,
    Star,
    User,
    BookMarked,
    History,
    Clock,
    BookOpen,
    Bookmark,
    LayoutDashboard,
    FileText,
    FolderHeart,
    Sun,
    Moon
} from "lucide-react";
import React, { useState, useEffect } from "react";
import { Button } from "../../components/ui/button";
import { ScrollArea } from "../../components/ui/scroll-area";
import ImportBook from "./importBook";
import { NavigateFunction, useNavigate, useLocation, useSearchParams } from "react-router-dom";
import { cn } from "../../lib/utils";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { Separator } from "../../components/ui/separator";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "../../components/ui/tooltip";
import { useQuery } from "@tanstack/react-query";
import axios from "axios";
import { useAuth } from "../../hooks/userAuth";

type SidebarProps = {
    isCollapsed: boolean;
    toggleCollapse: () => void;
    setBooksLoading: React.Dispatch<React.SetStateAction<string[]>>;
};

// Function to fetch recent reading activity
const fetchRecentActivity = async (accessToken: string) => {
    const { data } = await axios.get('/api/tracking/sessions/recent?limit=1', {
        headers: {
            Authorization: `Bearer ${accessToken}`
        }
    });
    return data;
};

type SidebarButtonProps = {
    icon: React.ElementType;
    label: string;
    isCollapsed: boolean;
    navigate: NavigateFunction;
    route: string;
    isActive?: boolean;
    textVisible?: boolean;
    badge?: number;
};

const SidebarButton = ({
    icon: Icon,
    label,
    isCollapsed,
    navigate,
    route,
    isActive = false,
    textVisible = true,
    badge
}: SidebarButtonProps) => {
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    
    return (
        <TooltipProvider>
            <Tooltip delayDuration={300}>
                <TooltipTrigger asChild>
                    <Button
                        variant="ghost"
                        size="sm"
                        className={cn(
                            "w-full justify-start",
                            isActive && (isDarkMode 
                                ? "bg-gray-800 text-white" 
                                : "bg-amber-100 text-gray-900"),
                            !isActive && (isDarkMode 
                                ? "text-gray-300 hover:text-white hover:bg-gray-800" 
                                : "text-gray-700 hover:text-gray-900 hover:bg-amber-50")
                        )}
                        onClick={() => navigate(route)}
                    >
                        <Icon size={20} className={isActive ? "text-amber-600" : ""} />
                        {!isCollapsed && textVisible && (
                            <span className="ml-2 transition-opacity duration-150 opacity-100">
                                {label}
                            </span>
                        )}
                        {badge !== undefined && badge > 0 && (
                            <span className={cn(
                                "ml-auto px-2 py-0.5 rounded-full text-xs",
                                isDarkMode 
                                    ? "bg-gray-700 text-gray-200" 
                                    : "bg-amber-100 text-amber-800"
                            )}>
                                {badge}
                            </span>
                        )}
                    </Button>
                </TooltipTrigger>
                {isCollapsed && <TooltipContent side="right">{label}</TooltipContent>}
            </Tooltip>
        </TooltipProvider>
    );
};

export default function Sidebar({
    isCollapsed,
    toggleCollapse,
    setBooksLoading,
}: SidebarProps) {
    const navigate = useNavigate();
    const location = useLocation();
    const [searchParams] = useSearchParams();
    const currentBookId = searchParams.get("id");
    const [textVisible, setTextVisible] = useState(!isCollapsed);
    const [themeMode, setThemeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const { accessToken } = useAuth();

    // Fetch recent reading activity to get the current/last book
    const { data: recentActivity } = useQuery({
        queryKey: ['recentActivity'],
        queryFn: () => fetchRecentActivity(accessToken!),
        enabled: !!accessToken,
    });

    // Handle text visibility based on sidebar state
    useEffect(() => {
        if (isCollapsed) {
            setTextVisible(false);
        } else {
            // Small delay to ensure text appears after sidebar expands
            const timer = setTimeout(() => {
                setTextVisible(true);
            }, 150); // Half of the sidebar transition duration
            return () => clearTimeout(timer);
        }
    }, [isCollapsed]);

    // Check if a route is active
    const isRouteActive = (route: string) => {
        if (route === '/') {
            return location.pathname === '/';
        }
        return location.pathname.startsWith(route);
    };

    // Get the most recent book
    const lastReadBook = recentActivity && recentActivity.length > 0 
        ? recentActivity[0].book 
        : null;

    return (
        <aside
            className={cn(
                "h-screen flex flex-col transition-all duration-300 border-r",
                isDarkMode 
                    ? "bg-gray-900 border-gray-800" 
                    : "bg-white border-gray-200",
                isCollapsed ? "w-16" : "w-64"
            )}
        >
            <div className="p-2">
                <Button
                    variant="ghost"
                    onClick={toggleCollapse}
                    className={cn(
                        "w-full justify-start p-2",
                        isDarkMode 
                            ? "text-gray-400 hover:text-white hover:bg-gray-800" 
                            : "text-gray-600 hover:text-gray-900 hover:bg-amber-50"
                    )}
                >
                    {isCollapsed ? (
                        <ChevronLeft size={20} />
                    ) : (
                        <ChevronRight size={20} />
                    )}
                    {!isCollapsed && textVisible && (
                        <span className="ml-2 transition-opacity duration-150 opacity-100">
                            Collapse
                        </span>
                    )}
                </Button>
            </div>

            <ScrollArea className="flex-grow">
                <div className="space-y-1 p-2">
                    <ImportBook
                        isCollapsed={isCollapsed}
                        setBooksLoading={setBooksLoading}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={Home}
                        label="Home"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/"
                        isActive={isRouteActive('/')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={Library}
                        label="Library"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/library"
                        isActive={isRouteActive('/library')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={BookMarked}
                        label="Currently Reading"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/reading"
                        isActive={isRouteActive('/reading')}
                        textVisible={textVisible}
                    />
                    
                    {/* <SidebarButton
                        icon={FolderHeart}
                        label="Collections"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/collections"
                        isActive={isRouteActive('/collections')}
                        textVisible={textVisible}
                    /> */}
                    
                    <Separator className={cn(
                        "my-2",
                        isDarkMode ? "bg-gray-800" : "bg-gray-200"
                    )} />
                    
                    {/* Current/Last Read Book Section */}
                    {lastReadBook && (!currentBookId || lastReadBook.id !== currentBookId) && (
                        <>
                            <div className={cn(
                                "px-2 py-1 text-xs font-semibold",
                                isDarkMode ? "text-gray-400" : "text-gray-500"
                            )}>
                                {!isCollapsed && textVisible && "CURRENT BOOK"}
                            </div>
                            
                            <TooltipProvider>
                                <Tooltip delayDuration={300}>
                                    <TooltipTrigger asChild>
                                        <Button
                                            variant="ghost"
                                            size="sm"
                                            className={cn(
                                                "w-full justify-start",
                                                isDarkMode 
                                                    ? "text-gray-300 hover:text-white hover:bg-gray-800" 
                                                    : "text-gray-700 hover:text-gray-900 hover:bg-amber-50"
                                            )}
                                            onClick={() => navigate(`/book?id=${lastReadBook.id}`)}
                                        >
                                            <BookOpen size={20} className="text-amber-600" />
                                            {!isCollapsed && textVisible && (
                                                <div className="ml-2 flex flex-col items-start mb-1">
                                                    <span className="text-sm font-medium truncate max-w-[160px]">
                                                        {lastReadBook.title}
                                                    </span>
                                                    <span className="text-xs text-gray-500 dark:text-gray-400 truncate max-w-[160px]">
                                                        {lastReadBook.author}
                                                    </span>
                                                </div>
                                            )}
                                        </Button>
                                    </TooltipTrigger>
                                    {isCollapsed && (
                                        <TooltipContent side="right">
                                            <div>
                                                <div className="font-medium">{lastReadBook.title}</div>
                                                <div className="text-xs text-gray-500">{lastReadBook.author}</div>
                                            </div>
                                        </TooltipContent>
                                    )}
                                </Tooltip>
                            </TooltipProvider>
                            
                            <Separator className={cn(
                                "my-2",
                                isDarkMode ? "bg-gray-800" : "bg-gray-200"
                            )} />
                        </>
                    )}
                    
                    <SidebarButton
                        icon={Star}
                        label="Favorites"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/favorites"
                        isActive={isRouteActive('/favorites')}
                        textVisible={textVisible}
                    />
                    
                    <SidebarButton
                        icon={History}
                        label="Reading History"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/history"
                        isActive={isRouteActive('/history')}
                        textVisible={textVisible}
                    />
                    
                    <Separator className={cn(
                        "my-2",
                        isDarkMode ? "bg-gray-800" : "bg-gray-200"
                    )} />
                    
                    <SidebarButton
                        icon={LayoutDashboard}
                        label="Statistics"
                        isCollapsed={isCollapsed}
                        navigate={navigate}
                        route="/statistics"
                        isActive={isRouteActive('/statistics')}
                        textVisible={textVisible}
                    />
                </div>
            </ScrollArea>

            <div className={cn(
                "p-2 border-t",
                isDarkMode ? "border-gray-800" : "border-gray-200"
            )}>
                {/* Add Dark Mode Toggle Button */}
                <TooltipProvider>
                    <Tooltip delayDuration={300}>
                        <TooltipTrigger asChild>
                            <Button
                                variant="ghost"
                                size="sm"
                                className={cn(
                                    "w-full justify-start",
                                    isDarkMode 
                                        ? "text-gray-300 hover:text-white hover:bg-gray-800" 
                                        : "text-gray-700 hover:text-gray-900 hover:bg-amber-50"
                                )}
                                onClick={() => {
                                    const newMode = themeMode === "dark" ? "light" : "dark";
                                    setThemeMode(newMode);
                                    // Update settings if they exist
                                    if (accessToken) {
                                        axios.patch('/api/settings', { darkMode: newMode === "dark" }, {
                                            headers: { Authorization: `Bearer ${accessToken}` }
                                        }).catch(err => console.error("Failed to update dark mode setting", err));
                                    }
                                }}
                            >
                                {themeMode === "dark" ? (
                                    <Sun size={20} className="text-amber-400" />
                                ) : (
                                    <Moon size={20} className="text-indigo-600" />
                                )}
                                {!isCollapsed && textVisible && (
                                    <span className="ml-2 transition-opacity duration-150 opacity-100">
                                        {themeMode === "dark" ? "Light Mode" : "Dark Mode"}
                                    </span>
                                )}
                            </Button>
                        </TooltipTrigger>
                        {isCollapsed && (
                            <TooltipContent side="right">
                                {themeMode === "dark" ? "Light Mode" : "Dark Mode"}
                            </TooltipContent>
                        )}
                    </Tooltip>
                </TooltipProvider>
                
                <SidebarButton
                    icon={Settings}
                    label="Settings"
                    isCollapsed={isCollapsed}
                    navigate={navigate}
                    route="/settings"
                    isActive={isRouteActive('/settings')}
                    textVisible={textVisible}
                />
                <SidebarButton
                    icon={User}
                    label="Profile"
                    isCollapsed={isCollapsed}
                    navigate={navigate}
                    route="/profile"
                    isActive={isRouteActive('/profile')}
                    textVisible={textVisible}
                />
            </div>
        </aside>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-68-modules-librarypage-components-bookactionsmenu-tsx">File 68: Modules/LibraryPage/components/BookActionsMenu.tsx</h2>

```typescript
import { useState } from "react";
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../../atoms/themeAtom";
import { useAuth } from "../../../hooks/userAuth";
import { cn } from "../../../lib/utils";
import { Book } from "../../../endPointTypes/types";
import { 
  MoreHorizontal, Edit, Trash2, Heart, FolderHeart, Plus, Check, X 
} from "lucide-react";
import { 
  DropdownMenu, 
  DropdownMenuContent, 
  DropdownMenuItem, 
  DropdownMenuSeparator, 
  DropdownMenuTrigger,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuPortal
} from "../../../components/ui/dropdown-menu";
import { Button } from "../../../components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from "../../../components/ui/dialog";
import { Input } from "../../../components/ui/input";
import { 
  fetchUserCollections, 
  addBookToCollection, 
  createCollection, 
  CollectionFormData 
} from "../../../api/collectionsApi";

type BookActionsMenuProps = {
  book: Book;
  onEdit: () => void;
  onDelete: () => void;
  onToggleFavorite: () => void;
  isLoading?: boolean;
  className?: string;
};

export default function BookActionsMenu({ 
  book, 
  onEdit, 
  onDelete, 
  onToggleFavorite,
  isLoading,
  className 
}: BookActionsMenuProps) {
  const [themeMode] = useAtom(themeModeAtom);
  const isDarkMode = themeMode === "dark";
  const { user, accessToken } = useAuth();
  const queryClient = useQueryClient();
  const [showCreateDialog, setShowCreateDialog] = useState(false);
  const [newCollectionName, setNewCollectionName] = useState("");
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);

  // Fetch user collections
  const { data: collectionsData } = useQuery({
    queryKey: ["collections"],
    queryFn: () => fetchUserCollections(user?.id || "", accessToken || ""),
    enabled: !!user?.id && !!accessToken,
  });

  const collections = collectionsData?.success ? collectionsData.data : [];

  // Create collection mutation
  const createMutation = useMutation({
    mutationFn: (data: CollectionFormData) => createCollection(data, accessToken!),
    onSuccess: (data) => {
      queryClient.invalidateQueries({ queryKey: ["collections"] });
      setShowCreateDialog(false);
      setNewCollectionName("");
      
      // If successful, add the book to the newly created collection
      if (data?.id) {
        addBookMutation.mutate(data.id);
      }
    },
    onError: (error) => {
      setError("Failed to create collection");
      console.error("Create error:", error);
    }
  });

  // Add book to collection mutation
  const addBookMutation = useMutation({
    mutationFn: (collectionId: string) => addBookToCollection(collectionId, book.id, accessToken!),
    onSuccess: (_, collectionId) => {
      queryClient.invalidateQueries({ queryKey: ["collections"] });
      // Find collection name for success message
      const collectionName = collections.find(c => c.id === collectionId)?.name || "collection";
      setSuccess(`Added to ${collectionName}`);
      
      // Clear success message after 3 seconds
      setTimeout(() => setSuccess(null), 3000);
    },
    onError: (error) => {
      setError("Failed to add book to collection");
      console.error("Add book error:", error);
    }
  });

  const handleCreateCollection = (e: React.FormEvent) => {
    e.preventDefault();
    if (newCollectionName.trim()) {
      createMutation.mutate({ name: newCollectionName.trim() });
    }
  };

  const handleAddToCollection = (collectionId: string) => {
    addBookMutation.mutate(collectionId);
  };

  return (
    <>
      <DropdownMenu>
        <DropdownMenuTrigger asChild>
          <Button
            variant="ghost"
            size="icon"
            className={cn(
              "h-8 w-8 rounded-full",
              isDarkMode ? "text-gray-400 hover:text-white hover:bg-gray-700" : "",
              className
            )}
            disabled={isLoading}
          >
            <MoreHorizontal className="h-4 w-4" />
          </Button>
        </DropdownMenuTrigger>
        <DropdownMenuContent align="end" className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
          <DropdownMenuItem 
            onClick={onEdit}
            className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
          >
            <Edit className="mr-2 h-4 w-4" />
            Edit
          </DropdownMenuItem>
          
          <DropdownMenuItem 
            onClick={onToggleFavorite}
            className={cn(
              book.liked ? "text-amber-500 focus:text-amber-500" : "",
              isDarkMode ? "focus:bg-gray-700" : ""
            )}
          >
            <Heart className={cn("mr-2 h-4 w-4", book.liked && "fill-amber-500")} />
            {book.liked ? "Remove from Favorites" : "Add to Favorites"}
          </DropdownMenuItem>
          
          <DropdownMenuSub>
            <DropdownMenuSubTrigger className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}>
              <FolderHeart className="mr-2 h-4 w-4" />
              Add to Collection
            </DropdownMenuSubTrigger>
            <DropdownMenuPortal>
              <DropdownMenuSubContent className={isDarkMode ? "bg-gray-800 border-gray-700" : ""}>
                {collections.length > 0 ? (
                  <>
                    {collections.map(collection => (
                      <DropdownMenuItem 
                        key={collection.id}
                        onClick={() => handleAddToCollection(collection.id)}
                        className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
                      >
                        <FolderHeart className="mr-2 h-4 w-4" />
                        {collection.name}
                      </DropdownMenuItem>
                    ))}
                    <DropdownMenuSeparator className={isDarkMode ? "bg-gray-700" : ""} />
                  </>
                ) : null}
                <DropdownMenuItem 
                  onClick={() => setShowCreateDialog(true)}
                  className={isDarkMode ? "text-gray-200 focus:bg-gray-700" : ""}
                >
                  <Plus className="mr-2 h-4 w-4" />
                  Create New Collection
                </DropdownMenuItem>
              </DropdownMenuSubContent>
            </DropdownMenuPortal>
          </DropdownMenuSub>
          
          <DropdownMenuSeparator className={isDarkMode ? "bg-gray-700" : ""} />
          
          <DropdownMenuItem 
            onClick={onDelete}
            className={cn(
              "text-red-600 focus:text-red-600",
              isDarkMode ? "focus:bg-gray-700" : ""
            )}
          >
            <Trash2 className="mr-2 h-4 w-4" />
            Delete
          </DropdownMenuItem>
        </DropdownMenuContent>
      </DropdownMenu>
      
      {/* Create Collection Dialog */}
      <Dialog open={showCreateDialog} onOpenChange={setShowCreateDialog}>
        <DialogContent className={isDarkMode ? "bg-gray-900 border-gray-700" : ""}>
          <DialogHeader>
            <DialogTitle className={isDarkMode ? "text-white" : ""}>Create New Collection</DialogTitle>
            <DialogDescription className={isDarkMode ? "text-gray-400" : ""}>
              Create a new collection and add "{book.title}" to it.
            </DialogDescription>
          </DialogHeader>
          
          <form onSubmit={handleCreateCollection} className="space-y-4 mt-2">
            <div>
              <Input
                placeholder="Collection name"
                value={newCollectionName}
                onChange={(e) => setNewCollectionName(e.target.value)}
                className={isDarkMode ? "bg-gray-800 border-gray-700 text-gray-200" : ""}
                autoFocus
              />
            </div>
            
            <DialogFooter>
              <Button
                type="button"
                variant="outline"
                onClick={() => setShowCreateDialog(false)}
                className={isDarkMode ? "border-gray-700 text-gray-300 hover:bg-gray-800" : ""}
              >
                Cancel
              </Button>
              <Button 
                type="submit"
                disabled={!newCollectionName.trim() || createMutation.isPending}
                className="bg-amber-600 hover:bg-amber-700 text-white"
              >
                {createMutation.isPending ? "Creating..." : "Create & Add"}
              </Button>
            </DialogFooter>
          </form>
        </DialogContent>
      </Dialog>
      
      {/* Success message */}
      {success && (
        <div className="fixed bottom-4 right-4 bg-green-500 text-white p-3 rounded-md shadow-lg flex items-center">
          <Check className="h-4 w-4 mr-2" />
          {success}
        </div>
      )}
      
      {/* Error message */}
      {error && (
        <div className="fixed bottom-4 right-4 bg-red-500 text-white p-3 rounded-md shadow-lg">
          {error}
          <Button 
            variant="ghost" 
            size="sm" 
            className="ml-2 text-white hover:bg-red-600 p-1 h-auto"
            onClick={() => setError(null)}
          >
            <X className="h-4 w-4" />
          </Button>
        </div>
      )}
    </>
  );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-69-modules-librarypage-importbook-tsx">File 69: Modules/LibraryPage/importBook.tsx</h2>

```typescript
import { useMutation, useQueryClient } from "@tanstack/react-query";
import axios from "axios";
import { load } from "cheerio";
import JSZip from "jszip";
import { Plus } from "lucide-react";
import { useRef, useState, useEffect } from "react";
import { Button } from "../../components/ui/button";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useToast } from "../../hooks/use-toast";
import { useAuth } from "../../hooks/userAuth";
import { extractToc } from "../../preprocess/epub/extractToc";
import {
    ProcessedElement,
    processElements,
} from "../../preprocess/epub/htmlToBookElements";
import { preprocessEpub, readEpub } from "../../preprocess/epub/preprocessEpub";
import { ChaptersData } from "../../endPointTypes/types";
import { v4 as uuidv4 } from "uuid";
import { useAtom } from "jotai";
import { bookIdAtom } from "../BookPage/Konva/konvaAtoms";
import { useSettings } from "../../hooks/useSettings";
import { themeModeAtom } from "../../atoms/themeAtom";

type ImportBookProps = {
    isCollapsed: boolean;
    setBooksLoading: React.Dispatch<React.SetStateAction<string[]>>;
};
const importBook = async ({
    bookElements,
    metaData,
    userId,
    accessToken,
    coverImage,
    chaptersData,
    totalPages,
    setBooksLoading,
}: {
    bookElements: ProcessedElement[];
    metaData: Partial<Record<string, string>>;
    userId: string;
    accessToken: string | undefined;
    coverImage: Blob | null;
    chaptersData: ChaptersData[];
    totalPages: number;
    setBooksLoading: React.Dispatch<React.SetStateAction<string[]>>;
}) => {
    if (!accessToken) {
        throw new Error("Access token is null");
    }
    setBooksLoading((prev) => [...prev, "hi"]);

    let url: string = "https://example.com/image.jpg";
    if (coverImage) {
        const formData = new FormData();
        formData.append("file", coverImage);
        formData.append("upload_preset", "rkarvkvu"); // Correct field for the unsigned preset

        const { data } = await axios.post(
            "https://api.cloudinary.com/v1_1/dxgc5hsrr/image/upload",
            formData
        );
        url = data.secure_url;
        console.log("data", data);
    }

    const dataSending = {
        userId: userId, // Send userId as a reference
        title: metaData["dc:title"] || "No Title",
        description: metaData.description || "No Description",
        author: metaData.author || metaData["dc:creator"] || "No Author",
        genres: ["Classic", "Fiction"], // Send genres as plain strings
        bookshelves: [],
        imageUrl: url,
        liked: false,
        bookElements, // Pass raw book elements as received
        dateAdded: new Date(),
        highlights: [], // Same as above
        offsetPosition: { x: -200, y: -200 }, // Raw data for offset position
        chaptersData, // Pass raw chaptersData
        scale: 1, // Include the scale as raw data
        totalPages: totalPages, // Make sure this is included
    };
    
    console.log("Sending book with totalPages:", totalPages);
    
    const data = await apiFetch(
        "POST /book",
        { body: dataSending },
        {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        }
    );

    return data;
};

export default function ImportBook({
    isCollapsed,
    setBooksLoading,
}: ImportBookProps) {
    const [_, setError] = useState<string | null>(null);
    const { accessToken, user } = useAuth();
    const { toast } = useToast();
    const [bookId] = useAtom(bookIdAtom);
    const { settings } = useSettings();
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    // Use the mutation with the correct types
    const queryClient = useQueryClient();
    const mutation = useMutation({
        mutationFn: importBook, // Pass the function directly
        onSuccess: (data) => {
            console.log("Book imported successfully:", data);
            queryClient.invalidateQueries({ queryKey: ["book"] });
            toast({
                title: "Book imported successfully",
                duration: 5000,
            });
        },
        onError: (err) => {
            toast({
                title: "Failed to import book",
                duration: 5000,
            });
            console.error("Failed to import book:", err);
        },
    });
    const fileInputRef = useRef<HTMLInputElement | null>(null);

    const handleButtonClick = () => {
        if (fileInputRef.current) {
            fileInputRef.current.click();
        }
    };

    const processBookElements = async (
        event: React.ChangeEvent<HTMLInputElement>
    ) => {
        const file = event.target.files?.[0];
        if (!file) {
            return null;
        }
        const elements = await handleEpubChange(file);
        if (!elements) {
            console.error("Failed to load EPUB");
            return;
        }
        if (!user) {
            console.error("User not found");
            return;
        }
        const processedElements = processElements(
            elements.epubElements,
            24,
            1200
        );
        
        // Calculate total pages
        const totalPages = calculateTotalPages(processedElements);
        console.log("Calculated totalPages:", totalPages);
        
        const chapterData = elements.chaptersData.map((chapter) => ({
            ...chapter,
            elementId:
                processedElements.find(
                    (element) => element.elementId === chapter.elementId
                )?.lineY + "" || "someId",
            id: uuidv4(),
        }));
        
        mutation.mutate({
            bookElements: processedElements,
            metaData: elements.metaData,
            userId: user.id,
            accessToken: accessToken,
            chaptersData: chapterData,
            coverImage: elements.coverImage,
            totalPages: totalPages, // Make sure this is passed to the mutation
            setBooksLoading,
        });
    };

    const handleEpubChange = async (file: File) => {
        try {
            const { paragraphs, metaData, coverImage } = await readEpub(file);
            console.log("epubElements", paragraphs);
            const epubElements = preprocessEpub(paragraphs);
            console.log("epubElements", epubElements);

            // Extract ToC using preprocessed content
            const zip = await JSZip.loadAsync(file);
            const opfFilePath = await findOpfFilePath(zip);
            if (!opfFilePath) {
                setError("Failed to load opfFilePath.");
                return;
            }
            const toc = await extractToc(zip, opfFilePath);

            // Convert ToC to chapters data
            const chaptersData = toc.map((item) => ({
                elementId: item.id || "someId",
                title: item.title,
                href: item.href || undefined,
                indentLevel: calculateIndentLevel(item.href),
            }));
            console.log("chaptersData", chaptersData);

            return { epubElements, metaData, coverImage, chaptersData };
        } catch (error) {
            console.error("Failed to load EPUB", error);
            setError("Failed to load EPUB. Please try another file.");
        }
    };
    function calculateIndentLevel(href: string | undefined) {
        if (!href) return undefined;
        // Simple example: increase indent level based on depth of href structure
        return (href.match(/\//g) || []).length;
    }

    async function findOpfFilePath(zip: JSZip) {
        const containerXml = await zip
            .file("META-INF/container.xml")
            ?.async("string");
        if (containerXml) {
            const $ = load(containerXml, { xmlMode: true });
            const rootfileElement = $("rootfile");
            if (rootfileElement.length > 0) {
                return rootfileElement.attr("full-path") || null;
            }
        }
        return null;
    }

    // Calculate total pages based on book elements
    const calculateTotalPages = (bookElements: ProcessedElement[], fontSize: number = 16): number => {
        if (!bookElements || bookElements.length === 0) return 0;
        
        // Calculate how many lines fit in a page based on viewport height
        const viewportHeight = window.innerHeight;
        const lineHeight = settings?.lineHeight || 1.5; // Use settings or default
        const linesPerPage = Math.floor(viewportHeight / (fontSize * lineHeight));
        
        // Get the total number of lines in the book
        const lastElement = bookElements[bookElements.length - 1];
        const totalLines = lastElement.lineY + 1; // +1 because lineY is zero-indexed
        
        // Calculate total pages
        return Math.ceil(totalLines / linesPerPage);
    };

    return (
        <Button
            variant="ghost"
            size="sm"
            className="w-full justify-start"
            onClick={handleButtonClick}
        >
            <Plus size={20} className={isDarkMode ? "text-gray-300" : "text-gray-600"} />
            {!isCollapsed && <span className={`ml-2 ${isDarkMode ? "text-gray-300" : "text-gray-600"}`}>Add Book</span>}
            <input
                ref={fileInputRef}
                className="hidden"
                type="file"
                accept=".epub"
                onChange={processBookElements}
            />
        </Button>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-70-modules-profilepage-profilepage-tsx">File 70: Modules/ProfilePage/ProfilePage.tsx</h2>

```typescript
import React, { useState } from "react";
import Sidebar from "../LibraryPage/Sidebar";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import { useAuth } from "../../hooks/userAuth";
import { Button } from "../../components/ui/button";
import { Input } from "../../components/ui/input";
import { Label } from "../../components/ui/label";
import { Separator } from "../../components/ui/separator";
import { useToast } from "../../hooks/use-toast";
import { User, Edit, Save, Key, LogOut } from "lucide-react";
import axios from "axios";
export default function ProfilePage() {
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [booksLoading, setBooksLoading] = useState<string[]>([]);
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const { user, logout, accessToken } = useAuth();
    const { toast } = useToast();
    
    const [isEditing, setIsEditing] = useState(false);
    const [username, setUsername] = useState(user?.username || "");
    const [isChangingPassword, setIsChangingPassword] = useState(false);
    const [currentPassword, setCurrentPassword] = useState("");
    const [newPassword, setNewPassword] = useState("");
    const [confirmPassword, setConfirmPassword] = useState("");
    const toggleCollapse = () => {
        setIsCollapsed(!isCollapsed);
    };

    const handleSaveProfile = async () => {
        // Here you would implement the API call to update the user's profile
        toast({
            title: "Profile updated",
            description: "Your profile has been successfully updated.",
            duration: 3000,
        });
        await axios.put(`/api/user/${user?.id}`, {
            username,
        }, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });
        setIsEditing(false);
    };

    const handleChangePassword = async () => {
        if (newPassword !== confirmPassword) {
            toast({
                title: "Passwords don't match",
                description: "New password and confirmation must match.",
                variant: "destructive",
                duration: 3000,
            });
            return;
        }
        const match = await axios.post("/api/auth/password-match", {
            username: user?.username,
            password: currentPassword,
        });
        if (!match) {
            toast({
                title: "Incorrect password",
                description: "The current password is incorrect.",
                variant: "destructive",
                duration: 3000,
            });
            return;
        }
        await axios.put(`/api/auth/password`, {
            username: user?.username,
            password: newPassword,
        }, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });
        
        // Here you would implement the API call to change the password
        toast({
            title: "Password changed",
            description: "Your password has been successfully updated.",
            duration: 3000,
        });
        
        setIsChangingPassword(false);
        setCurrentPassword("");
        setNewPassword("");
        setConfirmPassword("");
    };

    const handleLogout = () => {
        logout();
        toast({
            title: "Logged out",
            description: "You have been successfully logged out.",
            duration: 3000,
        });
    };

    return (
        <div className="flex h-screen">
            <Sidebar
                isCollapsed={isCollapsed}
                toggleCollapse={toggleCollapse}
                setBooksLoading={setBooksLoading}
            />
            <div className={cn(
                "flex-1 p-6 overflow-auto",
                isDarkMode ? "bg-gray-950 text-gray-200" : "bg-amber-50 text-gray-900"
            )}>
                <div className="max-w-3xl mx-auto">
                    <div className="flex items-center justify-between mb-6">
                        <h1 className={cn(
                            "text-2xl font-bold flex items-center gap-2",
                            isDarkMode ? "text-white" : "text-gray-900"
                        )}>
                            <User className="h-6 w-6" />
                            User Profile
                        </h1>
                        <Button 
                            variant={isDarkMode ? "outline" : "secondary"}
                            size="sm"
                            onClick={handleLogout}
                            className={cn(
                                "flex items-center gap-1",
                                isDarkMode ? "text-gray-300 border-gray-700 hover:bg-gray-800" : ""
                            )}
                        >
                            <LogOut className="h-4 w-4" />
                            Logout
                        </Button>
                    </div>

                    <div className={cn(
                        "p-6 rounded-lg shadow-md mb-6",
                        isDarkMode ? "bg-gray-900 border border-gray-800" : "bg-white border border-gray-200"
                    )}>
                        <div className="flex items-center justify-between mb-4">
                            <h2 className={cn(
                                "text-xl font-semibold",
                                isDarkMode ? "text-gray-200" : "text-gray-800"
                            )}>
                                Account Information
                            </h2>
                            {!isEditing ? (
                                <Button 
                                    variant="ghost" 
                                    size="sm" 
                                    onClick={() => setIsEditing(true)}
                                    className={cn(
                                        "flex items-center gap-1",
                                        isDarkMode ? "text-gray-300 hover:text-white hover:bg-gray-800" : ""
                                    )}
                                >
                                    <Edit className="h-4 w-4" />
                                    Edit
                                </Button>
                            ) : (
                                <Button 
                                    variant="default" 
                                    size="sm" 
                                    onClick={handleSaveProfile}
                                    className="flex items-center gap-1"
                                >
                                    <Save className="h-4 w-4" />
                                    Save
                                </Button>
                            )}
                        </div>

                        <div className="space-y-4">
                            <div>
                                <Label htmlFor="username" className={isDarkMode ? "text-gray-300" : ""}>
                                    Username
                                </Label>
                                {isEditing ? (
                                    <Input 
                                        id="username" 
                                        value={username} 
                                        onChange={(e) => setUsername(e.target.value)}
                                        className={isDarkMode ? "bg-gray-800 border-gray-700 text-gray-200" : ""}
                                    />
                                ) : (
                                    <div className={cn(
                                        "mt-1 p-2 rounded",
                                        isDarkMode ? "bg-gray-800 text-gray-200" : "bg-gray-100 text-gray-800"
                                    )}>
                                        {user?.username || "Not set"}
                                    </div>
                                )}
                            </div>

                            <div>
                                <Label className={isDarkMode ? "text-gray-300" : ""}>
                                    User ID
                                </Label>
                                <div className={cn(
                                    "mt-1 p-2 rounded font-mono text-sm",
                                    isDarkMode ? "bg-gray-800 text-gray-400" : "bg-gray-100 text-gray-600"
                                )}>
                                    {user?.id || "Not available"}
                                </div>
                            </div>
                        </div>
                    </div>

                    <div className={cn(
                        "p-6 rounded-lg shadow-md",
                        isDarkMode ? "bg-gray-900 border border-gray-800" : "bg-white border border-gray-200"
                    )}>
                        <div className="flex items-center justify-between mb-4">
                            <h2 className={cn(
                                "text-xl font-semibold flex items-center gap-2",
                                isDarkMode ? "text-gray-200" : "text-gray-800"
                            )}>
                                <Key className="h-5 w-5" />
                                Security
                            </h2>
                            {!isChangingPassword ? (
                                <Button 
                                    variant="ghost" 
                                    size="sm" 
                                    onClick={() => setIsChangingPassword(true)}
                                    className={cn(
                                        isDarkMode ? "text-gray-300 hover:text-white hover:bg-gray-800" : ""
                                    )}
                                >
                                    Change Password
                                </Button>
                            ) : (
                                <Button 
                                    variant="outline" 
                                    size="sm" 
                                    onClick={() => setIsChangingPassword(false)}
                                    className={cn(
                                        isDarkMode ? "text-gray-300 border-gray-700 hover:bg-gray-800" : ""
                                    )}
                                >
                                    Cancel
                                </Button>
                            )}
                        </div>

                        {isChangingPassword && (
                            <div className="space-y-4 mt-4">
                                <div>
                                    <Label htmlFor="current-password" className={isDarkMode ? "text-gray-300" : ""}>
                                        Current Password
                                    </Label>
                                    <Input 
                                        id="current-password" 
                                        type="password" 
                                        value={currentPassword} 
                                        onChange={(e) => setCurrentPassword(e.target.value)}
                                        className={isDarkMode ? "bg-gray-800 border-gray-700 text-gray-200" : ""}
                                    />
                                </div>
                                
                                <Separator className={isDarkMode ? "bg-gray-800" : ""} />
                                
                                <div>
                                    <Label htmlFor="new-password" className={isDarkMode ? "text-gray-300" : ""}>
                                        New Password
                                    </Label>
                                    <Input 
                                        id="new-password" 
                                        type="password" 
                                        value={newPassword} 
                                        onChange={(e) => setNewPassword(e.target.value)}
                                        className={isDarkMode ? "bg-gray-800 border-gray-700 text-gray-200" : ""}
                                    />
                                </div>
                                
                                <div>
                                    <Label htmlFor="confirm-password" className={isDarkMode ? "text-gray-300" : ""}>
                                        Confirm New Password
                                    </Label>
                                    <Input 
                                        id="confirm-password" 
                                        type="password" 
                                        value={confirmPassword} 
                                        onChange={(e) => setConfirmPassword(e.target.value)}
                                        className={isDarkMode ? "bg-gray-800 border-gray-700 text-gray-200" : ""}
                                    />
                                </div>
                                
                                <div className="flex justify-end">
                                    <Button 
                                        onClick={handleChangePassword}
                                        className={cn(
                                            "mt-2",
                                            isDarkMode ? "bg-amber-600 hover:bg-amber-700 text-white" : ""
                                        )}
                                    >
                                        Update Password
                                    </Button>
                                </div>
                            </div>
                        )}

                        {!isChangingPassword && (
                            <p className={cn(
                                "text-sm",
                                isDarkMode ? "text-gray-400" : "text-gray-600"
                            )}>
                                Manage your account password and security settings.
                            </p>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-71-modules-readingpage-currentlyreadingpage-tsx">File 71: Modules/ReadingPage/CurrentlyReadingPage.tsx</h2>

```typescript
import { useEffect, useState } from "react";
import { useQuery } from "@tanstack/react-query";
import { useNavigate } from "react-router-dom";
import { Book } from "../../endPointTypes/types";
import { apiFetch } from "../../endPointTypes/apiClient";
import { useAuth } from "../../hooks/userAuth";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";
import Sidebar from "../LibraryPage/Sidebar";
import { BookOpen, Clock, Calendar, ChevronRight, User, BarChart3, ArrowRightCircle } from "lucide-react";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "../../components/ui/card";
import { Button } from "../../components/ui/button";
import { Badge } from "../../components/ui/badge";
import { Separator } from "../../components/ui/separator";
import { Progress } from "../../components/ui/progress";

// Types
type BookProgress = {
    id: string;
    percentComplete: number;
    currentPage: number;
    timeSpentReading: number; // in seconds
    lastReadAt: string;
    bookId: string;
};

export default function CurrentlyReadingPage() {
    const { user, accessToken } = useAuth();
    const navigate = useNavigate();
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";
    const [isCollapsed, setIsCollapsed] = useState(false);
    const [booksLoading, setBooksLoading] = useState<string[]>([]);

    const toggleCollapse = () => {
        setIsCollapsed(!isCollapsed);
    };

    // Fetch currently reading books
    const { data: currentlyReadingBooks, isLoading: booksLoading1 } = useQuery({
        queryKey: ["currentlyReadingBooks", user?.id],
        queryFn: async () => {
            const data = await apiFetch(
                "GET /book/getCurrentlyReading",
                {
                    query: {
                        userId: user?.id,
                    },
                },
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
            console.log("currentlyReadingBooks", data);
            return data.data.data as Book[];
        },
        enabled: !!user?.id && !!accessToken,
    });

    // Fetch reading progress for all books
    const { data: bookProgress, isLoading: progressLoading } = useQuery({
        queryKey: ["bookProgress", user?.id],
        queryFn: async () => {
            const data = await apiFetch(
                "GET /tracking/progress/all",
                {},
                {
                    headers: {
                        Authorization: `Bearer ${accessToken}`,
                    },
                }
            );
            console.log("bookProgress", data);
            return data.data as BookProgress[];
        },
        enabled: !!user?.id && !!accessToken,
    });

    // Function to get progress for a specific book
    const getBookProgress = (bookId: string) => {
        if (!bookProgress) return null;
        return bookProgress.find(progress => progress.bookId === bookId);
    };

    // Format time duration (seconds to readable format)
    const formatReadingTime = (seconds: number) => {
        if (!seconds) return "0 min";
        
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        } else {
            return `${minutes} min`;
        }
    };

    // Format date
    const formatDate = (dateString: string) => {
        const date = new Date(dateString);
        return date.toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
    };
    console.log("bookProgress", booksLoading, booksLoading1, progressLoading);
    const isLoading = booksLoading1 || progressLoading;
    console.log("currentlyReadingBooks", currentlyReadingBooks);
    return (
        <div className={cn(
            "flex h-screen",
            isDarkMode ? "bg-gray-900" : "bg-amber-50"
        )}>
            <Sidebar 
                isCollapsed={isCollapsed} 
                toggleCollapse={toggleCollapse} 
                setBooksLoading={setBooksLoading} 
            />
            
            <main className={cn(
                "flex-1 overflow-y-auto p-6",
                isDarkMode ? "text-gray-200" : "text-gray-800"
            )}>
                <div className="max-w-7xl mx-auto">
                    <div className="flex items-center justify-between mb-8">
                        <div className="flex items-center">
                            <BookOpen className={cn(
                                "mr-3 h-7 w-7",
                                isDarkMode ? "text-amber-500" : "text-amber-600"
                            )} />
                            <h1 className={cn(
                                "text-3xl font-serif font-bold",
                                isDarkMode ? "text-white" : "text-amber-800"
                            )}>
                                Currently Reading
                            </h1>
                        </div>
                        
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => navigate('/history')}
                            className={cn(
                                isDarkMode 
                                    ? "border-gray-700 text-gray-300 hover:text-white hover:bg-gray-800" 
                                    : "border-gray-300 text-gray-700 hover:text-gray-900 hover:bg-amber-50"
                            )}
                        >
                            View Reading History
                            <ChevronRight className="ml-1 h-4 w-4" />
                        </Button>
                    </div>
                    
                    {isLoading ? (
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            {[1, 2].map((i) => (
                                <Card key={i} className={cn(
                                    "h-64 animate-pulse",
                                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                )}>
                                    <div className="h-full flex p-6">
                                        <div className={cn(
                                            "w-1/3 rounded",
                                            isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                        )}></div>
                                        <div className="w-2/3 pl-6 space-y-4">
                                            <div className={cn(
                                                "h-6 w-3/4 rounded",
                                                isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                            )}></div>
                                            <div className={cn(
                                                "h-4 w-1/2 rounded",
                                                isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                            )}></div>
                                            <div className={cn(
                                                "h-4 w-3/4 rounded",
                                                isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                            )}></div>
                                            <div className={cn(
                                                "h-2 w-full rounded",
                                                isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                            )}></div>
                                        </div>
                                    </div>
                                </Card>
                            ))}
                        </div>
                    ) : currentlyReadingBooks && currentlyReadingBooks.length > 0 ? (
                        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                            {currentlyReadingBooks.map((book) => {
                                const progress = getBookProgress(book.id);
                                return (
                                    <Card key={book.id} className={cn(
                                        "overflow-hidden hover:shadow-md transition-all duration-200",
                                        isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                    )}>
                                        <div className="flex h-full">
                                            <div 
                                                className="w-1/3 min-h-[230px] bg-cover bg-center"
                                                style={{ backgroundImage: `url(${book.imageUrl})` }}
                                            />
                                            <div className="w-2/3 p-5 flex flex-col">
                                                <CardHeader className="p-0 pb-3">
                                                    <CardTitle className={cn(
                                                        "text-xl font-serif line-clamp-2",
                                                        isDarkMode ? "text-white" : "text-amber-800"
                                                    )}>
                                                        {book.title}
                                                    </CardTitle>
                                                    <CardDescription className="flex items-center mt-1">
                                                        <User className="h-3.5 w-3.5 mr-1.5" />
                                                        {book.author}
                                                    </CardDescription>
                                                </CardHeader>
                                                
                                                <CardContent className="p-0 flex-grow">
                                                    {progress ? (
                                                        <div className="space-y-3 mt-2">
                                                            <div>
                                                                <div className="flex justify-between text-sm mb-1">
                                                                    <span className={cn(
                                                                        isDarkMode ? "text-gray-400" : "text-gray-500"
                                                                    )}>
                                                                        Progress
                                                                    </span>
                                                                    <span className={cn(
                                                                        isDarkMode ? "text-amber-400" : "text-amber-600"
                                                                    )}>
                                                                        {Math.round(progress.percentComplete * 100)}%
                                                                    </span>
                                                                </div>
                                                                <Progress 
                                                                    value={progress.percentComplete * 100} 
                                                                    className={cn(
                                                                        "h-2",
                                                                        isDarkMode ? "bg-gray-700" : "bg-gray-200"
                                                                    )}
                                                                    indicatorClassName="bg-amber-500"
                                                                />
                                                            </div>
                                                            
                                                            <div className="flex items-center text-sm">
                                                                <Clock className="h-4 w-4 mr-1.5" />
                                                                <span className={isDarkMode ? "text-gray-400" : "text-gray-500"}>
                                                                    Read for {formatReadingTime(progress.timeSpentReading)}
                                                                </span>
                                                            </div>
                                                            
                                                            <div className="flex items-center text-sm">
                                                                <Calendar className="h-4 w-4 mr-1.5" />
                                                                <span className={isDarkMode ? "text-gray-400" : "text-gray-500"}>
                                                                    Last read on {formatDate(progress.lastReadAt)}
                                                                </span>
                                                            </div>
                                                            
                                                            <div className="flex items-center text-sm">
                                                                <BarChart3 className="h-4 w-4 mr-1.5" />
                                                                <span className={isDarkMode ? "text-gray-400" : "text-gray-500"}>
                                                                    Page {progress.currentPage} of {book.totalPages || '?'}
                                                                </span>
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <div className={cn(
                                                            "text-sm italic mt-2", 
                                                            isDarkMode ? "text-gray-400" : "text-gray-500"
                                                        )}>
                                                            No reading progress yet
                                                        </div>
                                                    )}
                                                </CardContent>
                                                
                                                <CardFooter className="p-0 pt-3 mt-auto">
                                                    <Button 
                                                        className="w-full bg-amber-600 hover:bg-amber-700 text-white"
                                                        onClick={() => navigate(`/book?id=${book.id}`)}
                                                    >
                                                        <BookOpen className="mr-2 h-4 w-4" />
                                                        Continue Reading
                                                    </Button>
                                                </CardFooter>
                                            </div>
                                        </div>
                                    </Card>
                                );
                            })}
                        </div>
                    ) : (
                        <Card className={cn(
                            "text-center py-16 px-4",
                            isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                        )}>
                            <CardContent>
                                <BookOpen className={cn(
                                    "mx-auto h-12 w-12 mb-4",
                                    isDarkMode ? "text-gray-600" : "text-gray-400"
                                )} />
                                <h3 className={cn(
                                    "text-xl font-serif font-medium mb-2",
                                    isDarkMode ? "text-white" : "text-amber-800"
                                )}>
                                    No books in progress
                                </h3>
                                <p className={cn(
                                    "mb-6 max-w-md mx-auto",
                                    isDarkMode ? "text-gray-400" : "text-gray-600"
                                )}>
                                    You don't have any books in progress. Start reading a book from your library to see it here.
                                </p>
                                <Button
                                    onClick={() => navigate('/')}
                                    className="bg-amber-600 hover:bg-amber-700 text-white"
                                >
                                    <ArrowRightCircle className="mr-2 h-4 w-4" />
                                    Go to Library
                                </Button>
                            </CardContent>
                        </Card>
                    )}
                    
                    {currentlyReadingBooks && currentlyReadingBooks.length > 0 && (
                        <div className="mt-8">
                            <Separator className={cn(
                                "my-8",
                                isDarkMode ? "bg-gray-800" : "bg-gray-200"
                            )} />
                            
                            <div className={cn(
                                "flex items-center justify-between mb-4",
                                isDarkMode ? "text-gray-300" : "text-gray-700"
                            )}>
                                <h2 className="text-xl font-serif font-medium">Reading Stats</h2>
                            </div>
                            
                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4">
                                <Card className={cn(
                                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                )}>
                                    <CardHeader className="pb-2">
                                        <CardTitle className="text-sm font-normal flex items-center text-gray-500">
                                            <Clock className="h-4 w-4 mr-1.5" />
                                            Time Reading
                                        </CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        <p className={cn(
                                            "text-2xl font-bold",
                                            isDarkMode ? "text-white" : "text-amber-800"
                                        )}>
                                            {formatReadingTime(
                                                bookProgress?.reduce((total, p) => total + (p.timeSpentReading || 0), 0) || 0
                                            )}
                                        </p>
                                    </CardContent>
                                </Card>
                                
                                <Card className={cn(
                                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                )}>
                                    <CardHeader className="pb-2">
                                        <CardTitle className="text-sm font-normal flex items-center text-gray-500">
                                            <BookOpen className="h-4 w-4 mr-1.5" />
                                            Books Reading
                                        </CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        <p className={cn(
                                            "text-2xl font-bold",
                                            isDarkMode ? "text-white" : "text-amber-800"
                                        )}>
                                            {currentlyReadingBooks?.length || 0}
                                        </p>
                                    </CardContent>
                                </Card>
                                
                                <Card className={cn(
                                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                )}>
                                    <CardHeader className="pb-2">
                                        <CardTitle className="text-sm font-normal flex items-center text-gray-500">
                                            <BarChart3 className="h-4 w-4 mr-1.5" />
                                            Pages Read
                                        </CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        <p className={cn(
                                            "text-2xl font-bold",
                                            isDarkMode ? "text-white" : "text-amber-800"
                                        )}>
                                            {bookProgress?.reduce((total, p) => total + (p.currentPage || 0), 0) || 0}
                                        </p>
                                    </CardContent>
                                </Card>
                                
                                <Card className={cn(
                                    isDarkMode ? "bg-gray-800 border-gray-700" : "bg-white border-gray-200"
                                )}>
                                    <CardHeader className="pb-2">
                                        <CardTitle className="text-sm font-normal flex items-center text-gray-500">
                                            <Calendar className="h-4 w-4 mr-1.5" />
                                            Last Read
                                        </CardTitle>
                                    </CardHeader>
                                    <CardContent>
                                        <p className={cn(
                                            "text-2xl font-bold",
                                            isDarkMode ? "text-white" : "text-amber-800"
                                        )}>
                                            {bookProgress && bookProgress.length > 0 
                                                ? formatDate(
                                                    bookProgress.sort((a, b) => 
                                                        new Date(b.lastReadAt).getTime() - new Date(a.lastReadAt).getTime()
                                                    )[0].lastReadAt
                                                  )
                                                : "Never"
                                            }
                                        </p>
                                    </CardContent>
                                </Card>
                            </div>
                        </div>
                    )}
                </div>
            </main>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-72-modules-settings-settings-tsx">File 72: Modules/Settings/Settings.tsx</h2>

```typescript
import { useSettings } from "../../hooks/useSettings";
import { SettingsType } from "../../endPointTypes/types";
import { Label } from "../../components/ui/label";
import { Button } from "../../components/ui/button";
import {
    Select,
    SelectContent,
    SelectItem,
    SelectTrigger,
    SelectValue,
} from "../../components/ui/select";
import { Slider } from "../../components/ui/slider";
import { Switch } from "../../components/ui/switch";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { useEffect } from "react";
import { cn } from "../../lib/utils";

export default function Settings() {
    const { settings, updateSettings } = useSettings();
    const [themeMode, setThemeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    // Update document theme when theme mode changes
    useEffect(() => {
        if (themeMode === "dark") {
            document.documentElement.classList.add("dark");
        } else {
            document.documentElement.classList.remove("dark");
        }
    }, [themeMode]);

    // Sync dark mode setting with theme mode
    useEffect(() => {
        if (settings?.darkMode !== undefined) {
            setThemeMode(settings.darkMode ? "dark" : "light");
        }
    }, [settings?.darkMode, setThemeMode]);

    const backgroundOptions = [
        { label: "White", value: "#FFFFFF" },
        { label: "Beige", value: "#F5F5DC" },
        { label: "Black", value: "#000000" },
        { label: "Gray", value: "#808080" },
        { label: "Sepia", value: "#704214" },
    ];

    const textColorOptions = [
        { label: "Black", value: "#000000" },
        { label: "Dark Gray", value: "#333333" },
        { label: "White", value: "#FFFFFF" },
        { label: "Sepia", value: "#5B4636" },
    ];

    const fontFamilyOptions = [
        "Arial",
        "Georgia",
        "Times New Roman",
        "Verdana",
        "Helvetica",
        "Courier New",
        "Open Sans",
        "Roboto",
    ];

    const handleSettingChange = <K extends keyof SettingsType>(
        key: K,
        value: SettingsType[K]
    ) => {
        updateSettings({ [key]: value });
        
        // Update theme mode when dark mode setting changes
        if (key === "darkMode") {
            setThemeMode(value ? "dark" : "light");
        }
    };

    if (!settings) return null;

    return (
        <div className="space-y-6">
            {/* Dark Mode Toggle */}
            <div className="flex items-center justify-between">
                <Label className={isDarkMode ? "text-gray-300" : "text-gray-800 font-medium"}>
                    Dark Mode
                </Label>
                <Switch
                    checked={settings.darkMode}
                    onCheckedChange={(checked) =>
                        handleSettingChange("darkMode", checked)
                    }
                />
            </div>

            {/* Background Color */}
            <div>
                <Label className={isDarkMode ? "text-gray-300" : "text-gray-800 font-medium"}>
                    Background Color
                </Label>
                <Select
                    value={settings.backgroundColor}
                    onValueChange={(value) =>
                        handleSettingChange(
                            "backgroundColor",
                            value
                        )
                    }
                >
                    <SelectTrigger className={cn(
                        "w-full mt-1",
                        isDarkMode 
                            ? "bg-zinc-800 border-gray-700 text-gray-200" 
                            : "bg-white border-gray-300 text-gray-800"
                    )}>
                        <SelectValue placeholder="Select background color" />
                    </SelectTrigger>
                    <SelectContent className={isDarkMode ? "bg-zinc-800 border-gray-700" : "bg-white border-gray-300"}>
                        {backgroundOptions.map((option) => (
                            <SelectItem
                                key={option.value}
                                value={option.value}
                                className={isDarkMode ? "text-gray-200" : "text-gray-800"}
                            >
                                <div className="flex items-center">
                                    <div 
                                        className="w-4 h-4 rounded-full mr-2 border border-gray-600" 
                                        style={{ backgroundColor: option.value }}
                                    />
                                    {option.label}
                                </div>
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>

            {/* Text Color */}
            <div>
                <Label className={isDarkMode ? "text-gray-300" : "text-gray-800 font-medium"}>
                    Text Color
                </Label>
                <Select
                    value={settings.textColor}
                    onValueChange={(value) =>
                        handleSettingChange("textColor", value)
                    }
                >
                    <SelectTrigger className={cn(
                        "w-full mt-1",
                        isDarkMode 
                            ? "bg-zinc-800 border-gray-700 text-gray-200" 
                            : "bg-white border-gray-300 text-gray-800"
                    )}>
                        <SelectValue placeholder="Select text color" />
                    </SelectTrigger>
                    <SelectContent className={isDarkMode ? "bg-zinc-800 border-gray-700" : "bg-white border-gray-300"}>
                        {textColorOptions.map((option) => (
                            <SelectItem
                                key={option.value}
                                value={option.value}
                                className={isDarkMode ? "text-gray-200" : "text-gray-800"}
                            >
                                <div className="flex items-center">
                                    <div 
                                        className="w-4 h-4 rounded-full mr-2 border border-gray-600" 
                                        style={{ backgroundColor: option.value }}
                                    />
                                    {option.label}
                                </div>
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>

            {/* Font Size */}
            <div>
                <Label className={isDarkMode ? "text-gray-300" : "text-gray-800 font-medium"}>
                    Font Size ({settings.fontSize}px)
                </Label>
                <Slider
                    value={[settings.fontSize]}
                    onValueChange={(value) =>
                        handleSettingChange("fontSize", value[0])
                    }
                    min={12}
                    max={50}
                    step={1}
                    className="mt-2"
                />
            </div>

            {/* Font Family */}
            <div>
                <Label className={isDarkMode ? "text-gray-300" : "text-gray-800 font-medium"}>
                    Font Family
                </Label>
                <Select
                    value={settings.fontFamily}
                    onValueChange={(value) =>
                        handleSettingChange("fontFamily", value)
                    }
                >
                    <SelectTrigger className={cn(
                        "w-full mt-1",
                        isDarkMode 
                            ? "bg-zinc-800 border-gray-700 text-gray-200" 
                            : "bg-white border-gray-300 text-gray-800"
                    )}>
                        <SelectValue placeholder="Select font family" />
                    </SelectTrigger>
                    <SelectContent className={isDarkMode ? "bg-zinc-800 border-gray-700" : "bg-white border-gray-300"}>
                        {fontFamilyOptions.map((font) => (
                            <SelectItem 
                                key={font} 
                                value={font} 
                                className={isDarkMode ? "text-gray-200" : "text-gray-800"}
                            >
                                <span style={{ fontFamily: font }}>{font}</span>
                            </SelectItem>
                        ))}
                    </SelectContent>
                </Select>
            </div>

           

            {/* Preview */}
            <div className="mt-6 p-4 rounded-md" style={{ 
                backgroundColor: settings.backgroundColor,
                color: settings.textColor,
                fontFamily: settings.fontFamily,
                fontSize: `${settings.fontSize}px`,
                lineHeight: settings.lineHeight,
                border: isDarkMode ? "none" : "1px solid #e5e7eb"
            }}>
                <p>This is a preview of your text settings.</p>
                <p>Adjust the controls above to customize your reading experience.</p>
            </div>

            {/* Reset to Defaults */}
            <div className="flex justify-end">
                <Button
                    variant={isDarkMode ? "outline" : "secondary"}
                    size="sm"
                    className={cn(
                        isDarkMode 
                            ? "text-gray-300 border-gray-700 hover:bg-zinc-700 hover:text-white" 
                            : "text-gray-700 hover:bg-gray-200 hover:text-gray-900"
                    )}
                    onClick={() => {
                        updateSettings({
                            fontSize: 16,
                            fontFamily: "Arial",
                            lineHeight: 1.5,
                            backgroundColor: "#FFFFFF",
                            textColor: "#000000",
                            darkMode: false,
                        });
                    }}
                >
                    Reset to Defaults
                </Button>
            </div>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-73-modules-settingspage-settingspage-tsx">File 73: Modules/SettingsPage/SettingsPage.tsx</h2>

```typescript
import React from "react";
import { useNavigate } from "react-router-dom";
import Sidebar from "../LibraryPage/Sidebar";
import Settings from "../Settings/Settings";
import { useAtom } from "jotai";
import { themeModeAtom } from "../../atoms/themeAtom";
import { cn } from "../../lib/utils";

export default function SettingsPage() {
    const navigate = useNavigate();
    const [isCollapsed, setIsCollapsed] = React.useState(false);
    const [booksLoading, setBooksLoading] = React.useState<string[]>([]);
    const [themeMode] = useAtom(themeModeAtom);
    const isDarkMode = themeMode === "dark";

    const toggleCollapse = () => {
        setIsCollapsed(!isCollapsed);
    };

    return (
        <div className="flex h-screen">
            <Sidebar
                isCollapsed={isCollapsed}
                toggleCollapse={toggleCollapse}
                setBooksLoading={setBooksLoading}
            />
            <div className={cn(
                "flex-1 p-6 overflow-auto",
                isDarkMode ? "bg-gray-950 text-gray-200" : "bg-amber-50 text-gray-900"
            )}>
                <div className="max-w-3xl mx-auto">
                    <h1 className={cn(
                        "text-2xl font-bold mb-6",
                        isDarkMode ? "text-white" : "text-gray-900"
                    )}>
                        User Settings
                    </h1>
                    <div className={cn(
                        "p-6 rounded-lg shadow-md",
                        isDarkMode ? "bg-gray-900 border border-gray-800" : "bg-white border border-gray-200"
                    )}>
                        <Settings />
                    </div>
                </div>
            </div>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-74-modules-userdatapage-dashboard-tsx">File 74: Modules/UserDataPage/Dashboard.tsx</h2>

```typescript
import { useSidebar } from "../../hooks/useSidebar";
import Sidebar from "../LibraryPage/Sidebar";
import { DashboardHeader } from "./components/DashboardHeader";
import { GenreDistributionChart } from "./components/GenreDistributionChart";
import { ReadingProgressChart } from "./components/ReadingProgressChart";
import { RecentActivity } from "./components/RecentActivity";
import { StatCards } from "./components/StatCards";
import { useQuery } from "@tanstack/react-query";
import { getDashboardData } from "../../api/trackingApi";
import { useAuth } from "../../hooks/userAuth";
import Skeleton from "../../components/ui/skeleton";

export default function Dashboard() {
    const { toggleCollapse, isCollapsed, setBooksLoading } = useSidebar();
    const { user, accessToken } = useAuth();
    console.log("hi"); 
    const { data: dashboardData, isLoading, error, refetch } = useQuery({
        queryKey: ['dashboard', user?.id],
        queryFn: async () => {
            if (!user?.id || !accessToken) {
                // Return empty dashboard data instead of undefined
                return {
                    stats: {
                        totalBooksRead: 0,
                        totalPagesRead: 0,
                        totalReadingTime: 0,
                        averageReadingSpeed: null,
                        favoriteGenre: null
                    },
                    streak: {
                        currentStreak: 0,
                        longestStreak: 0,
                        totalReadDays: 0,
                        lastReadDate: null
                    },
                    recentActivity: [],
                    readingProgressData: [],
                    genreDistribution: []
                };
            }
            return getDashboardData(user.id, accessToken);
        },
        // Only run the query when we have a user ID and access token
        enabled: !!user?.id && !!accessToken
    });
    
    return (
        <div className="flex h-screen bg-background">
            <Sidebar
                toggleCollapse={toggleCollapse}
                isCollapsed={isCollapsed}
                setBooksLoading={setBooksLoading}
            />
            <div className="flex-1 overflow-auto">
                <div className="p-6 space-y-6 max-w-7xl mx-auto">
                    <DashboardHeader onRefresh={() => refetch()} />
                    
                    {isLoading ? (
                        <div className="space-y-6">
                            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
                                {[...Array(4)].map((_, i) => (
                                    <Skeleton key={i} className="h-32 w-full" />
                                ))}
                            </div>
                            <Skeleton className="h-64 w-full" />
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <Skeleton className="h-80 w-full" />
                                <Skeleton className="h-80 w-full" />
                            </div>
                        </div>
                    ) : error ? (
                        <div className="p-6 text-center">
                            <h3 className="text-lg font-medium">Failed to load dashboard data</h3>
                            <p className="text-muted-foreground">Please try again later</p>
                        </div>
                    ) : (
                        <>
                            <StatCards 
                                stats={dashboardData?.stats}
                                streak={dashboardData?.streak}
                            />
                            <RecentActivity activities={dashboardData?.recentActivity || []} />
                            
                            {/* Charts Section */}
                            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                                <ReadingProgressChart data={dashboardData?.readingProgressData || []} />
                            </div>
                        </>
                    )}
                </div>
            </div>
        </div>
    );
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-75-modules-userdatapage-components-dashboardheader-tsx">File 75: Modules/UserDataPage/components/DashboardHeader.tsx</h2>

```typescript
import { Button } from "../../../components/ui/button";
import { RefreshCw } from "lucide-react";

type DashboardHeaderProps = {
    onRefresh?: () => void;
}

export function DashboardHeader({ onRefresh }: DashboardHeaderProps) {
    return (
        <div className="flex justify-between items-center">
            <h1 className="text-3xl font-bold">Statistics</h1>
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-76-modules-userdatapage-components-genredistributionchart-tsx">File 76: Modules/UserDataPage/components/GenreDistributionChart.tsx</h2>

```typescript
import { Card, CardContent, CardHeader, CardTitle } from "../../../components/ui/card";
import { GenreDistribution } from "../../../api/trackingApi";
import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';

type GenreDistributionChartProps = {
    data: GenreDistribution[];
}

export function GenreDistributionChart({ data }: GenreDistributionChartProps) {
    const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884D8'];

    return (
        <Card>
            <CardHeader className="pb-2">
                <CardTitle>Genre Distribution</CardTitle>
            </CardHeader>
            <CardContent className="h-[300px]">
                {data.length === 0 ? (
                    <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>No genre data available</p>
                    </div>
                ) : (
                    <ResponsiveContainer width="100%" height="100%">
                        <PieChart>
                            <Pie
                                data={data}
                                cx="50%"
                                cy="50%"
                                labelLine={false}
                                outerRadius={80}
                                fill="#8884d8"
                                dataKey="count"
                                nameKey="genre"
                                label={({ genre }) => genre}
                            >
                                {data.map((entry, index) => (
                                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                                ))}
                            </Pie>
                            <Tooltip />
                            <Legend />
                        </PieChart>
                    </ResponsiveContainer>
                )}
            </CardContent>
        </Card>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-77-modules-userdatapage-components-readingprogresschart-tsx">File 77: Modules/UserDataPage/components/ReadingProgressChart.tsx</h2>

```typescript
import { Card, CardContent, CardHeader, CardTitle } from "../../../components/ui/card";
import { ChartDataPoint } from "../../../api/trackingApi";
import { BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';

type ReadingProgressChartProps = {
    data: ChartDataPoint[];
}

export function ReadingProgressChart({ data }: ReadingProgressChartProps) {
    // Format date for display
    const formatDate = (dateStr: string) => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    };

    return (
        <Card>
            <CardHeader className="pb-2">
                <CardTitle>Reading Progress</CardTitle>
            </CardHeader>
            <CardContent className="h-[300px]">
                {data.length === 0 ? (
                    <div className="h-full flex items-center justify-center text-muted-foreground">
                        <p>No reading data available</p>
                    </div>
                ) : (
                    <ResponsiveContainer width="100%" height="100%">
                        <BarChart data={data}>
                            <CartesianGrid strokeDasharray="3 3" />
                            <XAxis 
                                dataKey="day" 
                                tickFormatter={formatDate}
                            />
                            <YAxis />
                            <Tooltip 
                                formatter={(value) => [`${value} minutes`, 'Reading Time']}
                                labelFormatter={formatDate}
                            />
                            <Bar 
                                dataKey="totalMinutes" 
                                name="Reading Time" 
                                fill="#8884d8" 
                            />
                        </BarChart>
                    </ResponsiveContainer>
                )}
            </CardContent>
        </Card>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-78-modules-userdatapage-components-recentactivity-tsx">File 78: Modules/UserDataPage/components/RecentActivity.tsx</h2>

```typescript
import { Card, CardContent, CardHeader, CardTitle } from "../../../components/ui/card";
import { ActivityItem as ActivityItemType } from "../../../api/trackingApi";
import { formatDistanceToNow } from "date-fns";
import { Book, BookOpen, CheckCircle } from "lucide-react";
import { Link } from "react-router-dom";

type ActivityItemProps = {
    activity: ActivityItemType;
}

function ActivityItem({ activity }: ActivityItemProps) {
    const formattedTime = formatDistanceToNow(new Date(activity.timestamp), { addSuffix: true });
    
    // Determine icon based on activity type
    const getActivityIcon = () => {
        switch (activity.type) {
            case 'reading':
                return <BookOpen className="h-5 w-5 text-blue-500 mr-3" />;
            case 'completed':
                return <CheckCircle className="h-5 w-5 text-green-500 mr-3" />;
            default:
                return <Book className="h-5 w-5 text-muted-foreground mr-3" />;
        }
    };
    
    return (
        <div className="flex justify-between items-center py-3 border-b border-border last:border-0">
            <div className="flex items-center">
                {getActivityIcon()}
                <div>
                    <p className="text-foreground">{activity.description}</p>
                    {activity.bookId && (
                        <Link 
                            to={`/book/${activity.bookId}`}
                            className="text-xs text-primary hover:underline"
                        >
                            View book
                        </Link>
                    )}
                </div>
            </div>
            <span className="text-sm text-muted-foreground ml-4">{formattedTime}</span>
        </div>
    );
}

type RecentActivityProps = {
    activities: ActivityItemType[];
}

export function RecentActivity({ activities }: RecentActivityProps) {
    return (
        <Card>
            <CardHeader className="pb-2">
                <CardTitle>Recent Activity</CardTitle>
            </CardHeader>
            <CardContent>
                {activities.length === 0 ? (
                    <p className="text-muted-foreground text-center py-4">
                        No recent activity to display
                    </p>
                ) : (
                    <div className="space-y-1">
                        {activities.map((activity, index) => (
                            <ActivityItem 
                                key={index}
                                activity={activity}
                            />
                        ))}
                    </div>
                )}
            </CardContent>
        </Card>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-79-modules-userdatapage-components-statcards-tsx">File 79: Modules/UserDataPage/components/StatCards.tsx</h2>

```typescript
import { Card, CardContent } from "../../../components/ui/card";
import { ReadingStats, ReadingStreak } from "../../../api/trackingApi";

type StatCardProps = {
    title: string;
    value: string;
}

function StatCard({ title, value }: StatCardProps) {
    return (
        <Card>
            <CardContent className="p-6 flex flex-col justify-between">
                <h2 className="text-lg font-medium text-muted-foreground">
                    {title}
                </h2>
                <p className="text-3xl font-bold mt-2">
                    {value}
                </p>
            </CardContent>
        </Card>
    );
}

type StatCardsProps = {
    stats?: ReadingStats;
    streak?: ReadingStreak;
}

export function StatCards({ stats, streak }: StatCardsProps) {
    // Format reading time from seconds to hours and minutes
    const formatReadingTime = (seconds: number = 0) => {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        
        if (hours > 0) {
            return `${hours}h ${minutes}m`;
        }
        return `${minutes} mins`;
    };
    
    const statItems = [
        { 
            title: "Books Read", 
            value: stats?.totalBooksRead?.toString() || "0" 
        },
        { 
            title: "Pages Read", 
            value: stats?.totalPagesRead?.toString() || "0" 
        },
        { 
            title: "Reading Streak", 
            value: `${streak?.currentStreak || 0} Days` 
        },
        { 
            title: "Total Reading Time", 
            value: formatReadingTime(stats?.totalReadingTime) 
        },
    ];

    return (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-6">
            {statItems.map((stat) => (
                <StatCard 
                    key={stat.title} 
                    title={stat.title} 
                    value={stat.value} 
                />
            ))}
        </div>
    );
} 
```

<div style='page-break-after: always;'></div>

<h2 id="file-80-themeprovider-tsx">File 80: ThemeProvider.tsx</h2>

```typescript
import React, { createContext, useState, useEffect, ReactNode, useContext } from "react";

type Theme = "dark" | "light" | "system";

// Define the context types
export interface ThemeContextType {
    theme: Theme;
    setTheme: (theme: Theme) => void;
}

// Create the context with a default value
export const ThemeContext = createContext<ThemeContextType | undefined>(
    undefined
);

interface ThemeProviderProps {
    children: ReactNode;
    defaultTheme?: Theme;
    storageKey?: string;
}

// Create a ThemeProvider that will wrap the app
export function ThemeProvider({
    children,
    defaultTheme = "system",
    storageKey = "theme",
    ...props
}: ThemeProviderProps) {
    const [theme, setTheme] = useState<Theme>(
        () => (localStorage.getItem(storageKey) as Theme) || defaultTheme
    );

    useEffect(() => {
        const root = window.document.documentElement;
        root.classList.remove("light", "dark");

        if (theme === "system") {
            const systemTheme = window.matchMedia("(prefers-color-scheme: dark)")
                .matches
                ? "dark"
                : "light";
            root.classList.add(systemTheme);
            return;
        }

        root.classList.add(theme);
    }, [theme]);

    const value = {
        theme,
        setTheme: (theme: Theme) => {
            localStorage.setItem(storageKey, theme);
            setTheme(theme);
        },
    };

    return (
        <ThemeContext.Provider {...props} value={value}>
            {children}
        </ThemeContext.Provider>
    );
}

export const useTheme = () => {
    const context = useContext(ThemeContext);

    if (context === undefined)
        throw new Error("useTheme must be used within a ThemeProvider");

    return context;
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-81-api-booktrackingapi-ts">File 81: api/bookTrackingApi.ts</h2>

```typescript
import axios from "axios";

// Start a reading session
export const startReadingSession = async (bookId: string, accessToken: string) => {
  const { data } = await axios.post(
    `/api/tracking/session/start`,
    { bookId },
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    }
  );
  return data;
};

// End a reading session
export const endReadingSession = async (
  sessionId: string,
  pagesRead: number,
  lastPosition: number,
  accessToken: string
) => {
  const { data } = await axios.post(
    `/api/tracking/session/end`,
    { sessionId, pagesRead, lastPosition },
    {
      headers: {
        Authorization: `Bearer ${accessToken}`,
      },
    }
  );
  return data;
};

// Get book progress
export const getBookProgress = async (bookId: string, accessToken: string) => {
  const { data } = await axios.get(`/api/tracking/progress/book/${bookId}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });
  return data;
};

// Update book progress
export const updateBookProgress = async (
  bookId: string,
  percentComplete: number,
  currentPage: number,
  accessToken: string
): Promise<any> => {
  const response = await fetch(`/api/tracking/progress/update`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${accessToken}`
    },
    body: JSON.stringify({
      bookId,
      percentComplete,
      currentPage
    })
  });
  
  if (!response.ok) {
    throw new Error('Failed to update book progress');
  }
  
  return response.json();
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-82-api-collectionsapi-ts">File 82: api/collectionsApi.ts</h2>

```typescript
import { apiFetch } from "../endPointTypes/apiClient";

// Types
export type Collection = {
  id: string;
  name: string;
  description: string | null;
  imageUrl: string | null;
  createdAt: string;
  updatedAt: string;
  bookCount?: number;
  books?: CollectionBook[];
};

export type CollectionBook = {
  id: string;
  title: string;
  author: string;
  imageUrl: string | null;
  addedAt: string;
  genres?: string[];
};

export type CollectionFormData = {
  name: string;
  description?: string;
  imageUrl?: string;
};

// Fetch user collections
export const fetchUserCollections = async (userId: string, accessToken: string) => {
  const response = await apiFetch(
    "GET /collection",
    { query: { userId } },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Fetch a specific collection by ID
export const fetchCollectionById = async (id: string, accessToken: string) => {
  const response = await apiFetch(
    "GET /collection/:id",
    { params: { id } },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Create a new collection
export const createCollection = async (data: CollectionFormData, accessToken: string) => {
  const response = await apiFetch(
    "POST /collection",
    { body: data },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Update an existing collection
export const updateCollection = async (id: string, data: CollectionFormData, accessToken: string) => {
  const response = await apiFetch(
    "PUT /collection/:id",
    { params: { id }, body: data },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Delete a collection
export const deleteCollection = async (id: string, accessToken: string) => {
  const response = await apiFetch(
    "DELETE /collection/:id",
    { params: { id } },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Add book to collection
export const addBookToCollection = async (collectionId: string, bookId: string, accessToken: string) => {
  const response = await apiFetch(
    "POST /collection/:collectionId/books/:bookId",
    { params: { collectionId, bookId } },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
};

// Remove book from collection
export const removeBookFromCollection = async (collectionId: string, bookId: string, accessToken: string) => {
  const response = await apiFetch(
    "DELETE /collection/:collectionId/books/:bookId",
    { params: { collectionId, bookId } },
    { headers: { Authorization: `Bearer ${accessToken}` } }
  );
  return response.data;
}; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-83-api-trackingapi-ts">File 83: api/trackingApi.ts</h2>

```typescript
import axios from "axios";
import { apiFetch } from "../endPointTypes/apiClient";

// Types for tracking data
export interface ReadingSession {
  id: string;
  startTime: string;
  endTime: string | null;
  duration: number | null;
  pagesRead: number | null;
  lastPosition: number | null;
  book: {
    id: string;
    title: string;
    author: string;
    imageUrl: string;
  };
}

export interface BookProgress {
  id: string;
  percentComplete: number;
  currentPage: number;
  totalPages: number;
  isCompleted: boolean;
  startedAt: string;
  completedAt: string | null;
  lastReadAt: string | null;
  timeSpentReading: number;
  book: {
    id: string;
    title: string;
    author: string;
    imageUrl: string;
  };
}

export interface ReadingStreak {
  currentStreak: number;
  longestStreak: number;
  totalReadDays: number;
  lastReadDate: string | null;
}

export interface ReadingStats {
  totalBooksRead: number;
  totalPagesRead: number;
  totalReadingTime: number;
  averageReadingSpeed: number | null;
  favoriteGenre: string | null;
}

export interface ActivityItem {
  type: string;
  description: string;
  timestamp: string;
  bookId: string;
}

export interface ChartDataPoint {
  day: string;
  totalMinutes: number;
  pagesRead: number;
}

export interface GenreDistribution {
  genre: string;
  count: number;
}

export interface DashboardData {
  stats: ReadingStats;
  streak: ReadingStreak;
  recentActivity: ActivityItem[];
  readingProgressData: ChartDataPoint[];
  genreDistribution: GenreDistribution[];
}

// Get dashboard data
export const getDashboardData = async (userId: string, accessToken: string) => {
  console.log("labas rytas2");
  const { data } = await axios.get(`/api/tracking/dashboard?userId=${userId}`, {
    headers: {
      Authorization: `Bearer ${accessToken}`,
    },
  });
  console.log("data", data);
  return data;
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-84-atoms-themeatom-ts">File 84: atoms/themeAtom.ts</h2>

```typescript
import { atom } from "jotai";

type ThemeMode = "dark" | "light";

// Default to dark mode to match the current UI
export const themeModeAtom = atom<ThemeMode>("light"); 
```

<div style='page-break-after: always;'></div>

<h2 id="file-85-atoms-ts">File 85: atoms.ts</h2>

```typescript
import { atom } from "jotai";
import { User } from "./endPointTypes/types";

export const userAtom = atom<User | undefined>(undefined);
export const accessTokenAtom = atom<string | undefined>(undefined);

```

<div style='page-break-after: always;'></div>

<h2 id="file-86-components-ui-alert-tsx">File 86: components/ui/alert.tsx</h2>

```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground [&>svg~*]:pl-7",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

```

<div style='page-break-after: always;'></div>

<h2 id="file-87-components-ui-badge-tsx">File 87: components/ui/badge.tsx</h2>

```typescript
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

```

<div style='page-break-after: always;'></div>

<h2 id="file-88-components-ui-button-tsx">File 88: components/ui/button.tsx</h2>

```typescript
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"
import { cn } from "../../lib/utils"


const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

<div style='page-break-after: always;'></div>

<h2 id="file-89-components-ui-card-tsx">File 89: components/ui/card.tsx</h2>

```typescript
import * as React from "react";
import { cn } from "../../lib/utils";

const Card = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
    <div
        ref={ref}
        className={cn(
            "rounded-xl border bg-card text-card-foreground shadow",
            className
        )}
        {...props}
    />
));
Card.displayName = "Card";

const CardHeader = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
    <div
        ref={ref}
        className={cn("flex flex-col space-y-1.5 p-6", className)}
        {...props}
    />
));
CardHeader.displayName = "CardHeader";

const CardTitle = React.forwardRef<
    HTMLParagraphElement,
    React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
    <h3
        ref={ref}
        className={cn("font-semibold leading-none tracking-tight", className)}
        {...props}
    />
));
CardTitle.displayName = "CardTitle";

const CardDescription = React.forwardRef<
    HTMLParagraphElement,
    React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
    <p
        ref={ref}
        className={cn("text-sm text-muted-foreground", className)}
        {...props}
    />
));
CardDescription.displayName = "CardDescription";

const CardContent = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
    <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
));
CardContent.displayName = "CardContent";

const CardFooter = React.forwardRef<
    HTMLDivElement,
    React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
    <div
        ref={ref}
        className={cn("flex items-center p-6 pt-0", className)}
        {...props}
    />
));
CardFooter.displayName = "CardFooter";

export {
    Card,
    CardHeader,
    CardFooter,
    CardTitle,
    CardDescription,
    CardContent,
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-90-components-ui-collapsible-tsx">File 90: components/ui/collapsible.tsx</h2>

```typescript
import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

```

<div style='page-break-after: always;'></div>

<h2 id="file-91-components-ui-dialog-tsx">File 91: components/ui/dialog.tsx</h2>

```typescript
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { Cross2Icon } from "@radix-ui/react-icons"

import { cn } from "../../lib/utils";

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <Cross2Icon className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogTrigger,
  DialogClose,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-92-components-ui-dropdown-menu-tsx">File 92: components/ui/dropdown-menu.tsx</h2>

```typescript
import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { cn } from "@/lib/utils"
import { CheckIcon, ChevronRightIcon, DotFilledIcon } from "@radix-ui/react-icons"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRightIcon className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 max-h-[var(--radix-dropdown-menu-content-available-height)] min-w-[8rem] overflow-y-auto overflow-x-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md",
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&>svg]:size-4 [&>svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <DotFilledIcon className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-93-components-ui-input-tsx">File 93: components/ui/input.tsx</h2>

```typescript
import * as React from "react";
import { cn } from "../../lib/utils";

export interface InputProps
    extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
    ({ className, type, ...props }, ref) => {
        return (
            <input
                type={type}
                className={cn(
                    "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
                    className
                )}
                ref={ref}
                {...props}
            />
        );
    }
);
Input.displayName = "Input";

export { Input };

```

<div style='page-break-after: always;'></div>

<h2 id="file-94-components-ui-label-tsx">File 94: components/ui/label.tsx</h2>

```typescript
import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

```

<div style='page-break-after: always;'></div>

<h2 id="file-95-components-ui-popover-tsx">File 95: components/ui/popover.tsx</h2>

```typescript
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverAnchor = PopoverPrimitive.Anchor

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }

```

<div style='page-break-after: always;'></div>

<h2 id="file-96-components-ui-progress-tsx">File 96: components/ui/progress.tsx</h2>

```typescript
import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-2 w-full overflow-hidden rounded-full bg-primary/20",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

```

<div style='page-break-after: always;'></div>

<h2 id="file-97-components-ui-scroll-area-tsx">File 97: components/ui/scroll-area.tsx</h2>

```typescript
import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "../../lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

```

<div style='page-break-after: always;'></div>

<h2 id="file-98-components-ui-select-tsx">File 98: components/ui/select.tsx</h2>

```typescript
import * as React from "react"
import {
  CaretSortIcon,
  CheckIcon,
  ChevronDownIcon,
  ChevronUpIcon,
} from "@radix-ui/react-icons"
import * as SelectPrimitive from "@radix-ui/react-select"

import { cn } from "../../lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <CaretSortIcon className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUpIcon />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDownIcon />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("px-2 py-1.5 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute right-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <CheckIcon className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>
    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-99-components-ui-separator-tsx">File 99: components/ui/separator.tsx</h2>

```typescript
import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

```

<div style='page-break-after: always;'></div>

<h2 id="file-100-components-ui-skeleton-tsx">File 100: components/ui/skeleton.tsx</h2>

```typescript


const Skeleton = ({ className }: { className?: string }) => {
  return (
    <div className={`animate-pulse bg-gray-300 rounded ${className}`} />
  );
};

export default Skeleton; 
```

<div style='page-break-after: always;'></div>

<h2 id="file-101-components-ui-slider-tsx">File 101: components/ui/slider.tsx</h2>

```typescript
import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "../../lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

```

<div style='page-break-after: always;'></div>

<h2 id="file-102-components-ui-switch-tsx">File 102: components/ui/switch.tsx</h2>

```typescript
import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"
import { cn } from "../../lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-5 w-9 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent shadow-sm transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-4 w-4 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-4 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

```

<div style='page-break-after: always;'></div>

<h2 id="file-103-components-ui-tabs-tsx">File 103: components/ui/tabs.tsx</h2>

```typescript
import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "../../lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

<div style='page-break-after: always;'></div>

<h2 id="file-104-components-ui-textarea-tsx">File 104: components/ui/textarea.tsx</h2>

```typescript
import * as React from "react";

import { cn } from "../../lib/utils";

export interface TextareaProps
    extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
    ({ className, ...props }, ref) => {
        return (
            <textarea
                className={cn(
                    "flex min-h-[60px] w-full rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
                    className
                )}
                ref={ref}
                {...props}
            />
        );
    }
);
Textarea.displayName = "Textarea";

export { Textarea };

```

<div style='page-break-after: always;'></div>

<h2 id="file-105-components-ui-toast-tsx">File 105: components/ui/toast.tsx</h2>

```typescript
import * as React from "react"
import { Cross2Icon } from "@radix-ui/react-icons"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "../../lib/utils";

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-2 overflow-hidden rounded-md border p-4 pr-6 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium transition-colors hover:bg-secondary focus:outline-none focus:ring-1 focus:ring-ring disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-1 top-1 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-1 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <Cross2Icon className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold [&+div]:text-xs", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-106-components-ui-toaster-tsx">File 106: components/ui/toaster.tsx</h2>

```typescript
import { useToast } from "../../hooks/use-toast"
import { Toast, ToastClose, ToastDescription, ToastProvider, ToastTitle, ToastViewport } from "./toast"


export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-107-components-ui-tooltip-tsx">File 107: components/ui/tooltip.tsx</h2>

```typescript
import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "../../lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md bg-primary px-3 py-1.5 text-xs text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

```

<div style='page-break-after: always;'></div>

<h2 id="file-108-endpointtypes-apiclient-ts">File 108: endPointTypes/apiClient.ts</h2>

```typescript
import axios, { AxiosInstance, AxiosRequestConfig } from "axios";
import InputMap from "./inputMap";
import { ApiResponseTypes, Endpoint } from "./endpointTypes";

// Axios instance
const axiosInstance: AxiosInstance = axios.create({
    baseURL: "/api", // Adjust base URL as needed
});

// Generic fetch function accepting the endpoint key and inputs
export async function apiFetch<K extends Endpoint>(
    key: K,
    inputs: InputMap[K],
    config?: AxiosRequestConfig
) {
    try {
        const [method, ...pathParts] = key.split(" ");
        let path = pathParts.join(" "); // Join in case path contains spaces

        // Replace path parameters if any
        if ("params" in inputs && inputs.params) {
            for (const [paramKey, paramValue] of Object.entries(
                inputs.params
            )) {
                path = path.replace(
                    `:${paramKey}`,
                    encodeURIComponent(String(paramValue))
                );
            }
        }

        // Prepare Axios request config
        const axiosConfig: AxiosRequestConfig = {
            method: method.toLowerCase() as AxiosRequestConfig["method"],
            url: path,
            ...config,
        };

        if ("query" in inputs && inputs.query) {
            axiosConfig.params = inputs.query;
        }

        if ("body" in inputs && inputs.body) {
            axiosConfig.data = inputs.body;
        }

        // Perform the Axios request with the inferred type
        const response = await axiosInstance.request<ApiResponseTypes[K]>(
            axiosConfig
        );

        return response;
    } catch (error) {
        if (axios.isAxiosError(error)) {
            // Handle Axios-specific errors
            console.error(
                `API call to ${key} failed:`,
                error.response?.data || error.message
            );
            throw new Error(error.response?.data?.message || "API call failed");
        } else {
            // Handle non-Axios errors
            console.error(`Unexpected error during API call to ${key}:`, error);
            throw new Error("An unexpected error occurred");
        }
    }
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-109-endpointtypes-endpointtypes-ts">File 109: endPointTypes/endpointTypes.ts</h2>

```typescript
// This file is auto-generated from endpointMap.json. Do not modify manually.

export const endpointMap = {
  "GET /book": "{ id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }[]",
  "GET /book/getUserBooks": "{ id: string; title: string; description: string; author: string; }[]",
  "PATCH /book/:id": "{ id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }",
  "GET /book/:id": "{ id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }",
  "POST /book": "{ id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }",
  "DELETE /book/:id": "{ id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }",
  "GET /bookshelve": "{ id: string; userId: string; name: string; createdAt: Date; }[]",
  "POST /bookshelve": "{ id: string; userId: string; name: string; createdAt: Date; }",
  "PUT /bookshelve/:id": "{ id: string; userId: string; name: string; createdAt: Date; }",
  "POST /bookshelve/:bookshelveId/books/:bookId": "{ id: string; userId: string; name: string; createdAt: Date; }",
  "DELETE /bookshelve/:id": "{ id: string; userId: string; name: string; createdAt: Date; }",
  "GET /settings": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }[]",
  "GET /settings/user/:userId": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }",
  "GET /settings/:id": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }",
  "PATCH /settings/:id": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }",
  "PATCH /settings/user/:userId": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }",
  "POST /settings": "{ id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }",
  "POST /user": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "GET /user": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }[]",
  "GET /user/findOneByJwtPayload": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "GET /user/:id": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "GET /user/username/:username": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "PUT /user/:id": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "DELETE /user/:id": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
  "POST /auth/login": "{ access_token: string; user: any; }",
  "POST /auth/register": "{ id: string; username: string; age: number; password: string; comment: string | undefined; }",
} as const;

export type Endpoint = keyof typeof endpointMap;

export type ApiResponseTypes = {
  "GET /book": { id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; }[];
  "GET /book/getUserBooks": { id: string; title: string; description: string; author: string; }[];
  "PATCH /book/:id": { id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; };
  "GET /book/:id": { id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; };
  "POST /book": { id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; };
  "DELETE /book/:id": { id: string; title: string; description: string; author: string; imageUrl: string; liked: boolean; dateAdded: Date; scale: number; userId: string; };
  "GET /bookshelve": { id: string; userId: string; name: string; createdAt: Date; }[];
  "POST /bookshelve": { id: string; userId: string; name: string; createdAt: Date; };
  "PUT /bookshelve/:id": { id: string; userId: string; name: string; createdAt: Date; };
  "POST /bookshelve/:bookshelveId/books/:bookId": { id: string; userId: string; name: string; createdAt: Date; };
  "DELETE /bookshelve/:id": { id: string; userId: string; name: string; createdAt: Date; };
  "GET /settings": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; }[];
  "GET /settings/user/:userId": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; };
  "GET /settings/:id": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; };
  "PATCH /settings/:id": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; };
  "PATCH /settings/user/:userId": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; };
  "POST /settings": { id: string; userId: string; fontSize: number; fontFamily: string; lineHeight: number; backgroundColor: string; textColor: string; darkMode: boolean; };
  "POST /user": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "GET /user": { id: string; username: string; age: number; password: string; comment: string | undefined; }[];
  "GET /user/findOneByJwtPayload": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "GET /user/:id": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "GET /user/username/:username": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "PUT /user/:id": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "DELETE /user/:id": { id: string; username: string; age: number; password: string; comment: string | undefined; };
  "POST /auth/login": { access_token: string; user: any; };
  "POST /auth/register": { id: string; username: string; age: number; password: string; comment: string | undefined; };
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-110-endpointtypes-inputmap-ts">File 110: endPointTypes/inputMap.ts</h2>

```typescript
// This file is auto-generated from inputMap.json and endpointMap.json. Do not modify manually.

export type InputMap = {
    "GET /book": {};
    "GET /book/getUserBooks": {
        query: { userId: string };
    };
    "PATCH /book/:id": {
        params: { id: string };
        body: any;
    };
    "GET /book/:id": {
        params: { id: string };
    };
    "POST /book": {
        body: any;
    };
    "DELETE /book/:id": {
        params: { id: string };
    };
    "GET /bookshelve": {};
    "POST /bookshelve": {
        body: any;
    };
    "PUT /bookshelve/:id": {
        params: { id: string };
        body: any;
    };
    "POST /bookshelve/:bookshelveId/books/:bookId": {
        params: { bookshelveId: string } & { bookId: string };
    };
    "DELETE /bookshelve/:id": {
        params: { id: string };
    };
    "GET /settings": {};
    "GET /settings/user/:userId": {
        params: { userId: string };
    };
    "GET /settings/:id": {
        params: { id: string };
    };
    "PATCH /settings/:id": {
        params: { id: string };
        body: any;
    };
    "PATCH /settings/user/:userId": {
        params: { userId: string };
        body: any;
    };
    "POST /settings": {
        body: any;
    };
    "POST /user": {
        body: any;
    };
    "GET /user": {};
    "GET /user/findOneByJwtPayload": {};
    "GET /user/:id": {
        params: { id: string };
    };
    "GET /user/username/:username": {
        params: { username: string };
    };
    "PUT /user/:id": {
        params: { id: string };
        body: any;
    };
    "DELETE /user/:id": {
        params: { id: string };
    };
    "POST /auth/login": {};
    "POST /auth/register": {
        body: any;
    };
};

export default InputMap;

```

<div style='page-break-after: always;'></div>

<h2 id="file-111-endpointtypes-typeguards-tsx">File 111: endPointTypes/typeGuards.tsx</h2>

```typescript
import {
    CanvaElementSkeleton,
    SpecificCircleElement,
    SpecificRectElement,
    SpecificTextElement,
} from "./types";

export function isSpecificTextElement(
    item: CanvaElementSkeleton
): item is SpecificTextElement {
    return item.type === "text" && !!item.textElement;
}

export function isSpecificRectElement(
    item: CanvaElementSkeleton
): item is SpecificRectElement {
    return item.type === "rect" && !!item.rectElement;
}

export function isSpecificCircleElement(
    item: CanvaElementSkeleton
): item is SpecificCircleElement {
    return item.type === "circle" && !!item.circleElement;
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-112-endpointtypes-types-ts">File 112: endPointTypes/types.ts</h2>

```typescript
// Types for Prisma Models

export type SettingsType = {
  id: string;
  userId: string;
  fontSize: number;
  fontFamily: string;
  lineHeight: number;
  backgroundColor: string;
  textColor: string;
  darkMode: boolean;
  user?: User; // Optional reference
};

export type User = {
  id: string;
  username: string;
  password: string;
  comment?: string;
  books?: Book[]; // Optional reference array
  bookshelves?: Bookshelve[]; // Optional reference array
  settings?: SettingsType; // Optional reference
};

export type Genre = {
  id: string;
  name: string;
  books?: BookGenre[]; // Optional reference array
};

export type BookGenre = {
  bookId: string;
  genreId: string;
  book?: Book; // Optional reference
  genre?: Genre; // Optional reference
};

export type Book = {
  id: string;
  title: string;
  description: string;
  author: string;
  genres?: BookGenre[]; // Optional reference array
  bookshelves?: Bookshelve[]; // Optional reference array
  imageUrl: string;
  liked: boolean;
  dateAdded: string;
  scale: number;
  offsetPosition?: OffsetPosition; // Optional reference
  userId: string;
  user?: User; // Optional reference
  bookElements?: ProcessedElement[]; // Optional reference array
  highlights?: Highlight[]; // Optional reference array
  canvaElements?: CanvaElementSkeleton[]; // Optional reference array
  curveElements?: CurveElementSkeleton[]; // Optional reference array
  chaptersData?: ChaptersData[]; // Optional reference array
  totalPages: number;
};

export type Bookshelve = {
  id: string;
  name: string;
  createdAt: Date;
  userId: string;
  user?: User; // Optional reference
  books?: Book[]; // Optional reference array
};

export type ProcessedElement = {
  id: string;
  text: string;
  lineX: number;
  lineWidth: number;
  lineY: number;
  bookId: string;
  book?: Book; // Optional reference
};

export type Highlight = {
  id: string;
  startingX: number;
  startingY: number;
  endX: number;
  endY: number;
  bookId: string;
  highlightedText?: string;
  book?: Book; // Optional reference
};

export type OffsetPosition = {
  id: string;
  x: number;
  y: number;
  bookId: string;
  book?: Book; // Optional reference
};

export type ChaptersData = {
  id: string;
  title: string;
  href?: string;
  indentLevel?: number;
  bookId: string;
  book?: Book; // Optional reference
};

export type Point = {
  id?: string;
  x: number;
  y: number;
  curveId?: string;
  canvaId?: string;
  curve?: CurveElementSkeleton; // Optional reference
  canva?: CanvaElementSkeleton; // Optional reference
};

export type CanvaElementSkeleton = {
  id: string;
  fill: string;
  x: number;
  y: number;
  width: number;
  height: number;
  strokeColor: string;
  strokeWidth: number;
  opacity: number;
  type: "text" | "rect" | "circle";
  rotation: number;
  points?: Point[]; // Optional reference array
  outgoingArrows?: ArrowElement[]; // Optional reference array
  incomingArrows?: ArrowElement[]; // Optional reference array
  outgoingArrowIds?: string[]; // Optional reference array
  incomingArrowIds?: string[]; // Optional reference array
  bookId: string;
  book?: Book; // Optional reference
  circleElement?: CircleElement; // Optional reference array
  rectElement?: RectElement; // Optional reference array
  textElement?: TextElementType; // Optional reference array
};

export type CurveElementSkeleton = {
  id: string;
  points: Point[]; // Optional reference array
  fill: string;
  text?: string;
  roughness: number;
  bowing: number;
  seed: number;
  strokeWidth: number;
  strokeStyle: string;
  stroke: string;
  fillStyle: string;
  fillWeight: number;
  hachureAngle: number;
  hachureGap: number;
  type: "arrow" | "other";
  bookId: string;
  book?: Book; // Optional reference
  arrowElement?: ArrowElement; // Optional reference array
};

export type ArrowElement = {
  id?: string;
  startId?: string;
  endId?: string;
  type: "arrow";
  startType?: string;
  endType?: string;
  from?: CanvaElementSkeleton; // Optional reference
  to?: CanvaElementSkeleton; // Optional reference
  fromId?: string;
  toId?: string;
  curveId: string;
  curve?: CurveElementSkeleton; // Optional reference
};

export type CircleElement = {
  id?: string;
  fillStyle: string;
  roughness: number;
  seed: number;
  hachureGap: number;
  hachureAngle: number;
  radius: number;
  type: "circle";
  canvaId: string;
  canva?: CanvaElementSkeleton; // Optional reference
};

export type RectElement = {
  id?: string;
  fillStyle: string;
  roughness: number;
  seed: number;
  hachureGap: number;
  hachureAngle: number;
  type: "rect";
  canvaId: string;
  canva?: CanvaElementSkeleton; // Optional reference
};

export type TextElementType = {
  id?: string;
  text: string;
  fontFamily: string;
  fontSize: number;
  type: "text";
  canvaId: string;
  canva?: CanvaElementSkeleton; // Optional reference
  fontWeight: string;
  fontStyle: string;
  textDecoration: string;
};
export type SpecificTextElement = CanvaElementSkeleton & {
  type: "text";
  textElement: TextElementType;
};
export type SpecificRectElement = CanvaElementSkeleton & {
  type: "rect";
  rectElement: RectElement;
};
export type SpecificCircleElement = CanvaElementSkeleton & {
  type: "circle";
  circleElement: CircleElement;
};
export type SpecificArrowElement = CurveElementSkeleton & {
  type: "arrow";
  arrowElement: ArrowElement;
};

export type StartType =
  | "text"
  | "rect"
  | "circle"
  | "bookText"
  | undefined
  | string;

```

<div style='page-break-after: always;'></div>

<h2 id="file-113-hooks-use-toast-ts">File 113: hooks/use-toast.ts</h2>

```typescript
import * as React from "react";
import { ToastActionElement, ToastProps } from "../components/ui/toast";

const TOAST_LIMIT = 1;
const TOAST_REMOVE_DELAY = 1000000;

type ToasterToast = ToastProps & {
    id: string;
    title?: React.ReactNode;
    description?: React.ReactNode;
    action?: ToastActionElement;
};

const actionTypes = {
    ADD_TOAST: "ADD_TOAST",
    UPDATE_TOAST: "UPDATE_TOAST",
    DISMISS_TOAST: "DISMISS_TOAST",
    REMOVE_TOAST: "REMOVE_TOAST",
} as const;

let count = 0;

function genId() {
    count = (count + 1) % Number.MAX_SAFE_INTEGER;
    return count.toString();
}

type ActionType = typeof actionTypes;

type Action =
    | {
          type: ActionType["ADD_TOAST"];
          toast: ToasterToast;
      }
    | {
          type: ActionType["UPDATE_TOAST"];
          toast: Partial<ToasterToast>;
      }
    | {
          type: ActionType["DISMISS_TOAST"];
          toastId?: ToasterToast["id"];
      }
    | {
          type: ActionType["REMOVE_TOAST"];
          toastId?: ToasterToast["id"];
      };

interface State {
    toasts: ToasterToast[];
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>();

const addToRemoveQueue = (toastId: string) => {
    if (toastTimeouts.has(toastId)) {
        return;
    }

    const timeout = setTimeout(() => {
        toastTimeouts.delete(toastId);
        dispatch({
            type: "REMOVE_TOAST",
            toastId: toastId,
        });
    }, TOAST_REMOVE_DELAY);

    toastTimeouts.set(toastId, timeout);
};

export const reducer = (state: State, action: Action): State => {
    switch (action.type) {
        case "ADD_TOAST":
            return {
                ...state,
                toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
            };

        case "UPDATE_TOAST":
            return {
                ...state,
                toasts: state.toasts.map((t) =>
                    t.id === action.toast.id ? { ...t, ...action.toast } : t
                ),
            };

        case "DISMISS_TOAST": {
            const { toastId } = action;

            // ! Side effects ! - This could be extracted into a dismissToast() action,
            // but I'll keep it here for simplicity
            if (toastId) {
                addToRemoveQueue(toastId);
            } else {
                state.toasts.forEach((toast) => {
                    addToRemoveQueue(toast.id);
                });
            }

            return {
                ...state,
                toasts: state.toasts.map((t) =>
                    t.id === toastId || toastId === undefined
                        ? {
                              ...t,
                              open: false,
                          }
                        : t
                ),
            };
        }
        case "REMOVE_TOAST":
            if (action.toastId === undefined) {
                return {
                    ...state,
                    toasts: [],
                };
            }
            return {
                ...state,
                toasts: state.toasts.filter((t) => t.id !== action.toastId),
            };
    }
};

const listeners: Array<(state: State) => void> = [];

let memoryState: State = { toasts: [] };

function dispatch(action: Action) {
    memoryState = reducer(memoryState, action);
    listeners.forEach((listener) => {
        listener(memoryState);
    });
}

type Toast = Omit<ToasterToast, "id">;

function toast({ ...props }: Toast) {
    const id = genId();

    const update = (props: ToasterToast) =>
        dispatch({
            type: "UPDATE_TOAST",
            toast: { ...props, id },
        });
    const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id });

    dispatch({
        type: "ADD_TOAST",
        toast: {
            ...props,
            id,
            open: true,
            onOpenChange: (open) => {
                if (!open) dismiss();
            },
        },
    });

    return {
        id: id,
        dismiss,
        update,
    };
}

function useToast() {
    const [state, setState] = React.useState<State>(memoryState);

    React.useEffect(() => {
        listeners.push(setState);
        return () => {
            const index = listeners.indexOf(setState);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        };
    }, [state]);

    return {
        ...state,
        toast,
        dismiss: (toastId?: string) =>
            dispatch({ type: "DISMISS_TOAST", toastId }),
    };
}

export { useToast, toast };

```

<div style='page-break-after: always;'></div>

<h2 id="file-114-hooks-usesettings-ts">File 114: hooks/useSettings.ts</h2>

```typescript
// src/hooks/useSettings.ts

import {useAtom} from 'jotai';
import {useCallback, useEffect} from 'react';
import {useNavigate} from 'react-router-dom';

import {apiFetch} from '../endPointTypes/apiClient';
import {SettingsType} from '../endPointTypes/types';
import {settingsAtom} from '../Modules/BookPage/Konva/konvaAtoms';

import {useAuth} from './userAuth';

export const useSettings = () => {
  const [settings, setSettings] = useAtom(settingsAtom);
  const {accessToken, user} = useAuth();
  const navigate = useNavigate();

  const fetchSettings =
      useCallback(async (accessToken: string, userId: string) => {
        if (!accessToken || !userId) {
          return;
        }
        // Fetch settings
        const settingsData = await apiFetch(
            'GET /settings/user/:userId', {
              params: {userId},
            },
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

        return settingsData.data;
      }, []);

  const createSettings =
      useCallback(async (accessToken: string, userId: string) => {
        // Create default settings
        const defaultSettings: any = {
          user: {connect: {id: userId}},
          fontSize: 16,
          fontFamily: 'Arial',
          lineHeight: 1.5,
          backgroundColor: '#FFFFFF',
          textColor: '#000000',
          darkMode: false,
        };

        const settingsData =
            await apiFetch('POST /settings', {body: defaultSettings}, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

        return settingsData.data;
      }, []);

  const updateSettingsFunc = useCallback(
      async (
          accessToken: string, userId: string,
          updatedSettings: Partial<SettingsType>) => {
        // Update user settings
        const updatedData = await apiFetch(
            'PATCH /settings/user/:userId', {
              params: {userId},
              body: updatedSettings,
            },
            {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

        return updatedData.data;
      },
      []);

  // Ensure settings are fetched or created when the hook is used
  const ensureSettings = useCallback(async () => {
    if (!user || !accessToken) {
      navigate('/login');
      return;
    }
    try {
      const fetchedSettings = await fetchSettings(accessToken, user.id);
      if (JSON.stringify(fetchedSettings) !== JSON.stringify(settings)) {
        setSettings(fetchedSettings);
      }
    } catch (error) {
      console.warn('Settings not found, creating new settings.');
      try {
        const newSettings = await createSettings(accessToken, user.id);
        setSettings(newSettings);
      } catch (creationError) {
        console.error('Error creating new settings:', creationError);
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [accessToken, user, setSettings]);

  useEffect(() => {
    ensureSettings();
  }, [ensureSettings]);

  // Optimistic update of settings
  const updateSettings =
      useCallback(async (updatedSettings: Partial<SettingsType>) => {
        if (!user || !accessToken) {
          throw new Error('User or access token is missing');
        }

        // Keep a reference to the previous settings for potential rollback
        const previousSettings = {...settings} as SettingsType;

        // Optimistically update the local settings
        setSettings((oldSettings) => oldSettings && {
          ...oldSettings,
          ...updatedSettings,
        });

        try {
          // Make the API call in the background
          await updateSettingsFunc(accessToken, user.id, updatedSettings);
          // Optionally, refresh settings from the server to ensure consistency
          // const updatedFromServer = await fetchSettings(accessToken,
          // user._id); setSettings(updatedFromServer);
        } catch (error) {
          console.error('Error updating settings:', error);

          // Roll back to previous settings if the API call fails
          setSettings(previousSettings);

          // Optionally, notify the user about the error
          // e.g., show a toast notification
        }
      }, [accessToken, user, settings, setSettings, updateSettingsFunc]);

  return {settings, updateSettings};
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-115-hooks-usesidebar-ts">File 115: hooks/useSidebar.ts</h2>

```typescript
import { useEffect, useState } from "react";
import { Book } from "../endPointTypes/types";

export const useSidebar = (bookData: Book[] |undefined | null = null) => {
    const [booksLoading, setBooksLoading] = useState<string[]>([]);
    const [isCollapsed, setIsCollapsed] = useState(false);

    const toggleCollapse = () => setIsCollapsed((prev) => !prev);

    useEffect(() => {
        // Perform an operation when bookData changes
        if (bookData) {
            setBooksLoading((prev) => prev.slice(0, prev.length - 1));
        }
    }, [bookData]);

    return {
        booksLoading,
        setBooksLoading,
        isCollapsed,
        toggleCollapse,
    };
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-116-hooks-userauth-tsx">File 116: hooks/userAuth.tsx</h2>

```typescript
// src/hooks/userAuth.tsx
import axios from "axios";
import { useAtom } from "jotai";
import { useEffect, useState, useCallback } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { accessTokenAtom, userAtom } from "../atoms";
import { apiFetch } from "../endPointTypes/apiClient";

const fetchUser = async (accessToken: string | undefined) => {
    if (!accessToken) {
        throw new Error("Access token is null");
    }
    const userData = await apiFetch(
        "GET /user/findOneByJwtPayload",
        {},
        {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        }
    );

    return userData.data;
};

// Define the mutation function
const loginUser = async (username: string, password: string) => {
    const response = await axios.post("/api/auth/login", {
        username,
        password,
    });
    return response.data;
};

export const useAuth = () => {
    const [accessToken, setAccessToken] = useAtom(accessTokenAtom);
    const [user, setUser] = useAtom(userAtom);
    const navigate = useNavigate();
    const location = useLocation();
    const [isAuthenticating, setIsAuthenticating] = useState(true);
    const [authError, setAuthError] = useState<string | null>(null);

    const authenticate = useCallback(async () => {
        // Don't try to authenticate if we're already on the login page
        if (location.pathname === "/login") {
            setIsAuthenticating(false);
            return;
        }

        try {
            setIsAuthenticating(true);
            setAuthError(null);
            
            // First check if we have a token in state or localStorage
            let token = accessToken || localStorage.getItem("token");
            
            if (token) {
                // We have a token, set it in state if not already there
                if (!accessToken) {
                    setAccessToken(token);
                }
                
                // If we have a token but no user, fetch the user data
                if (!user) {
                    try {
                        const userData = await fetchUser(token);
                        setUser(userData);
                    } catch (error) {
                        console.error("Error fetching user with token:", error);
                        // Token might be invalid, clear it
                        setAccessToken(undefined);
                        localStorage.removeItem("token");
                        setAuthError("Session expired. Please login again.");
                        navigate("/login", { state: { from: location.pathname } });
                    }
                }
            } else if (user?.username && user?.password) {
                // No token but we have credentials, try to login
                try {
                    const data = await loginUser(user.username, user.password);
                    const newToken = data.access_token;
                    
                    if (newToken) {
                        setAccessToken(newToken);
                        localStorage.setItem("token", newToken);
                    } else {
                        setAuthError("Login failed. Please try again.");
                        navigate("/login", { state: { from: location.pathname } });
                    }
                } catch (error) {
                    console.error("Login failed:", error);
                    setAuthError("Login failed. Please try again.");
                    navigate("/login", { state: { from: location.pathname } });
                }
            } else {
                // No token and no credentials, redirect to login
                navigate("/login", { state: { from: location.pathname } });
            }
        } finally {
            setIsAuthenticating(false);
        }
    }, [accessToken, user, navigate, setAccessToken, setUser, location.pathname]);

    useEffect(() => {
        authenticate();
    }, [authenticate]);

    // Add logout function
    const logout = () => {
        // Clear the access token from state and localStorage
        setAccessToken(undefined);
        localStorage.removeItem("token");
        
        // Clear the user from state
        setUser(undefined);
        
        // Redirect to login page
        navigate("/login");
    };

    return { 
        accessToken, 
        user, 
        logout, 
        isAuthenticating, 
        authError,
        authenticate // Expose the authenticate function so it can be called manually
    };
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-117-lib-utils-ts">File 117: lib/utils.ts</h2>

```typescript
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-118-main-tsx">File 118: main.tsx</h2>

```typescript
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "./index.css";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ThemeProvider } from "./ThemeProvider";
import App from "./App";
import { Toaster } from "./components/ui/toaster";

const queryClient = new QueryClient();

createRoot(document.getElementById("root")!).render(
    <StrictMode>
        <QueryClientProvider client={queryClient}>
            <ThemeProvider>
                <App />
                <Toaster />
            </ThemeProvider>
        </QueryClientProvider>
    </StrictMode>
);

```

<div style='page-break-after: always;'></div>

<h2 id="file-119-preprocess-epub-extracttoc-ts">File 119: preprocess/epub/extractToc.ts</h2>

```typescript
import { load, CheerioAPI } from "cheerio";
import JSZip from "jszip";
import type { Element } from "domhandler";
export type Toc = {
    title: string;
    href: string | undefined;
    id: string;
    playOrder?: string; // Optional: useful for ordering or other metadata
    children?: Toc[]; // Optional: to support hierarchical ToCs
};

export async function extractToc(
    zip: JSZip,
    opfFilePath: string
): Promise<Toc[]> {
    const opfContent = await zip.file(opfFilePath)?.async("string");
    if (!opfContent) {
        throw new Error("OPF file must be present");
    }
    const $opf = load(opfContent, { xmlMode: true });

    // EPUB 3 Navigation Document
    let tocFilePath = $opf('item[properties="nav"]').attr("href");
    if (tocFilePath) {
        return await parseEpub3Nav(zip, tocFilePath);
    }

    // EPUB 2 NCX
    const ncxItemId = $opf("spine").attr("toc");
    tocFilePath = $opf(`item[id="${ncxItemId}"]`).attr("href");
    if (tocFilePath) {
        return await parseEpub2Ncx(zip, tocFilePath);
    }

    throw new Error("No valid ToC found in the EPUB.");
}

async function parseEpub2Ncx(zip: JSZip, ncxFilePath: string): Promise<Toc[]> {
    const ncxContent = await zip.file(ncxFilePath)?.async("string");
    if (!ncxContent) {
        throw new Error("NCX file must be present");
    }
    const $ncx = load(ncxContent, { xmlMode: true });
    const toc: Toc[] = [];

    $ncx("navMap > navPoint").each((_, navPoint) => {
        const href = $ncx(navPoint).find("content").attr("src");
        const id = href?.split("#")[1] || "";
        const playOrder = $ncx(navPoint).attr("playOrder");
        const title = $ncx(navPoint).find("navLabel > text").text();

        // Recursively parse children if they exist
        const children: Toc[] = parseNcxChildren($ncx, navPoint);

        toc.push({
            title,
            href,
            id,
            playOrder,
            children: children.length > 0 ? children : undefined,
        });
    });
    return toc;
}

function parseNcxChildren($: CheerioAPI, navPoint: Element): Toc[] {
    const children: Toc[] = [];
    $(navPoint)
        .find("navPoint")
        .each((_, child) => {
            const href = $(child).find("content").attr("src");
            const id = href?.split("#")[1] || "";
            const playOrder = $(child).attr("playOrder");
            const title = $(child).find("navLabel > text").text();

            children.push({
                title,
                href,
                id,
                playOrder,
                children: parseNcxChildren($, child),
            });
        });
    return children;
}

async function parseEpub3Nav(zip: JSZip, navFilePath: string): Promise<Toc[]> {
    const navContent = await zip.file(navFilePath)?.async("string");
    if (!navContent) {
        throw new Error("Navigation file must be present");
    }
    const $nav = load(navContent, { xmlMode: true });

    const toc: Toc[] = [];
    $nav('nav[epub\\:type="toc"] ol > li').each((_, listItem) => {
        const href = $nav(listItem).find("a").attr("href");
        const id = href?.split("#")[1] || "";
        const title = $nav(listItem).find("a").text();

        // Recursively parse children if they exist
        const children: Toc[] = parseNavChildren($nav, listItem);

        toc.push({
            title,
            href,
            id,
            children: children.length > 0 ? children : undefined,
        });
    });
    return toc;
}
function parseNavChildren($: CheerioAPI, listItem: Element): Toc[] {
    const children: Toc[] = [];
    $(listItem)
        .find("ol > li")
        .each((_, child) => {
            const href = $(child).find("a").attr("href");
            const fragment = href?.split("#")[1] || "";
            const title = $(child).find("a").text();

            children.push({
                title,
                href,
                id: fragment,
                children: parseNavChildren($, child),
            });
        });
    return children;
}

```

<div style='page-break-after: always;'></div>

<h2 id="file-120-preprocess-epub-htmltobookelements-ts">File 120: preprocess/epub/htmlToBookElements.ts</h2>

```typescript
import { HtmlElementObject, HtmlObject } from "./preprocessEpub";

export type ProcessedElement = {
    text: string;
    lineX: number;
    lineWidth: number;
    lineY: number;
};
export const processElements = (
    bookElements: (HtmlObject | null)[],
    fontSize: number,
    width: number
    
) => {
    let indexStart = 0;

    return bookElements
        .filter((elements) => elements !== null)
        .flatMap((elements) => {
            const result = processBookElement(
                elements,
                indexStart,
                fontSize,
                width
            );
            indexStart += result.length;
            return result;
        });
};

const processBookElement = (
    elements: HtmlObject,
    indexStart: number,
    fontSize: number,
    width: number
) => {
    let currentIndex = indexStart;

    const processedLines = elements.elements.flatMap((element) => {
        const lines = processTextIntoLines(
            element,
            currentIndex,
            fontSize,
            width,
            element.elementTocId
        );
        currentIndex += lines.length;
        return lines;
    });

    return processedLines;
};

const processTextIntoLines = (
    element: HtmlElementObject,
    indexStart: number,
    fontSize: number,
    width: number,
    id: string
) => {
    if (id.split("-").length === 1) {
        element.text = "Chapter " + id + " " + element.text;
    }
    let textLines: string[][] = [[]];
    let currentLineWidth = 0;
    for (let i = 0, j = 0; i < element.text.length; i++) {
        if (currentLineWidth + fontSize <= width && element.text[i] !== "\n") {
            textLines[j].push(element.text[i]);
            currentLineWidth += fontSize;
        } else {
            j++;
            textLines.push([]);
            if (element.text[i] === "\n") {
                currentLineWidth = 0;
            } else {
                currentLineWidth = fontSize;
                textLines[j].push(element.text[i]);
            }
        }
    }
    return textLines
        .filter((line) => line.length > 0)
        .map((line, lineIndex) => ({
            text: line.join(""),
            lineX: 0,
            lineWidth: line.length * fontSize,
            lineY: lineIndex + indexStart,
            elementId: id,
        }));
};

```

<div style='page-break-after: always;'></div>

<h2 id="file-121-preprocess-epub-preprocessepub-ts">File 121: preprocess/epub/preprocessEpub.ts</h2>

```typescript
import { load } from "cheerio";
import JSZip from "jszip";

export type HighlightRange = {
    startElementId: string;
    startOffset: number;
    endElementId: string;
    endOffset: number;
    highlightedText: string; // Optional, for debugging
    intermediateElementIds?: string[]; // New field to store IDs of elements in between
    highlightId: string;
};

export type ParagraphObject = {
    type: "paragraph";
    id: string;
    text: string; // Store the full text of the paragraph
    highlights: HighlightRange[]; // Store highlighted ranges within the text
    style?: React.CSSProperties;
};

export type HeadingObject = {
    type: "heading";
    id: string;
    tagName: string;
    text: string; // Store the full text of the heading
    style?: React.CSSProperties;
};
export type HtmlElementObject = {
    elementTocId: string;
    type: string; // The tag name of the element (e.g., 'p', 'h1', 'div', etc.)
    id: string;
    text: string; // Store the full text of the element
    highlights: HighlightRange[]; // Store highlighted ranges within the text
    style?: React.CSSProperties;
};
export type HtmlObject = {
    type: "html";
    elements: HtmlElementObject[]; // Use the new generic HtmlElementObject type
};
export async function readEpub(file: File) {
    const arrayBuffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(arrayBuffer);

    const opfFilePath = await findOpfFilePath(zip);
    if (!opfFilePath) {
        throw new Error("Unable to find content.opf file.");
    }

    const { content, metaData, coverImage } = await parseOpfFile(
        zip,
        opfFilePath
    );
    console.log("metaData", metaData);
    const paragraphs: string[] = [];
    for (const file of content) {
        const fileData = await zip.file(file.href)?.async("string");
        if (fileData) {
            paragraphs.push(fileData);
        }
    }

    return { paragraphs, metaData, coverImage };
}

async function findOpfFilePath(zip: JSZip): Promise<string | null> {
    const containerXml = await zip
        .file("META-INF/container.xml")
        ?.async("string");
    if (containerXml) {
        const $ = load(containerXml, { xmlMode: true });
        const rootfileElement = $("rootfile");
        if (rootfileElement.length > 0) {
            return rootfileElement.attr("full-path") || null;
        }
    }
    return null;
}

async function parseOpfFile(zip: JSZip, opfFilePath: string) {
    const opfContent = await zip.file(opfFilePath)?.async("string");
    if (!opfContent) {
        throw new Error("Unable to read content.opf file.");
    }

    const $ = load(opfContent, { xmlMode: true });

    // Get the manifest items
    const manifestItems: Record<string, string> = {};
    $("manifest item").each((_, item) => {
        const id = $(item).attr("id");
        const href = $(item).attr("href");
        if (id && href) {
            manifestItems[id] = href;
        }
    });

    const metaData: Record<string, string> = {};
    $("metadata")
        .children()
        .each((_, element) => {
            const tagName = element.tagName;
            const textContent = $(element).text();
            if (tagName && textContent) {
                metaData[tagName] = textContent;
            }
        });
    // Get the spine items in the correct order
    const spineItems = $("spine itemref")
        .map((_, itemref) => {
            const idref = $(itemref).attr("idref");
            if (idref && manifestItems[idref]) {
                return { id: idref, href: manifestItems[idref] };
            }
            throw new Error(`Spine references non-existent item: ${idref}`);
        })
        .get();
    // Find the cover image id
    let coverImageId = "";
    $("meta").each((_, meta) => {
        if ($(meta).attr("name") === "cover") {
            coverImageId = $(meta).attr("content") || "";
        }
    });
    let coverImage: Blob | null = null;
    if (coverImageId) {
        const coverImageHref = manifestItems[coverImageId];
        console.log("Cover image found:", coverImageHref);
        if (!coverImageHref) {
            throw new Error("Cover image reference not found in manifest.");
        }
        const newImage = await zip.file(coverImageHref)?.async("blob");
        if (!newImage) {
            coverImage = null;
            throw new Error("Unable to extract cover image from the EPUB.");
        }
        coverImage = newImage;
        console.log("Cover image extracted:", coverImageHref);
    }
    return { content: spineItems, metaData: metaData, coverImage };
}
export function preprocessEpub(epub: string[]): HtmlObject[] {
    return epub.map((html, index) => {
        const $ = load(html);

        const elements = $("body")
            .find("*") // Use find to traverse all elements within the body
            .map((i, elem) => {
                const textContent = $(elem).text();
                // Preserve existing id or generate a new one
                const id =
                    $(elem).attr("id") || `${elem.tagName}-${index}-${i}`;

                // No need to set the id back to the element unless required

                return {
                    elementTocId: id,
                    type: elem.tagName,
                    id,
                    tagName: elem.tagName,
                    text: textContent,
                    highlights: [],
                };
            })
            .get()
            .filter(Boolean);

        return {
            type: "html",
            elements,
        };
    });
}

```

